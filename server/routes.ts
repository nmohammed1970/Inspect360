// Backend API routes for Inspect360
import express, { type Express, type Request, type Response, type NextFunction } from "express";
import sharp from "sharp";
import ExcelJS from "exceljs";
import { createServer, type Server } from "http";
import { randomUUID, createHash } from "crypto";
import { promises as fs } from "fs";
import path from "path";
import os from "os";
import { storage } from "./storage";
import { getUncachableStripeClient, getStripeSecretKey } from "./stripeClient";

/**
 * Detect file MIME type from file buffer using magic bytes
 * Returns the detected MIME type or 'application/octet-stream' if unknown
 */
function detectFileMimeType(buffer: Buffer): string {
  // Validate buffer
  if (!buffer || buffer.length < 4) {
    return 'application/octet-stream';
  }

  // PDF: %PDF
  if (buffer[0] === 0x25 && buffer[1] === 0x50 && buffer[2] === 0x44 && buffer[3] === 0x46) {
    return 'application/pdf';
  }

  // JPEG: FF D8 FF
  if (buffer[0] === 0xFF && buffer[1] === 0xD8 && buffer[2] === 0xFF) {
    return 'image/jpeg';
  }

  // PNG: 89 50 4E 47
  if (buffer[0] === 0x89 && buffer[1] === 0x50 && buffer[2] === 0x4E && buffer[3] === 0x47) {
    return 'image/png';
  }

  // GIF: 47 49 46 38 or 47 49 46 39
  if (buffer[0] === 0x47 && buffer[1] === 0x49 && buffer[2] === 0x46 &&
    (buffer[3] === 0x38 || buffer[3] === 0x39)) {
    return 'image/gif';
  }

  // WebP: RIFF...WEBP
  if (buffer.length >= 12 &&
    buffer[0] === 0x52 && buffer[1] === 0x49 && buffer[2] === 0x46 && buffer[3] === 0x46 &&
    buffer[8] === 0x57 && buffer[9] === 0x45 && buffer[10] === 0x42 && buffer[11] === 0x50) {
    return 'image/webp';
  }

  // Microsoft Office files (DOCX, XLSX, PPTX): PK (ZIP signature)
  // These are ZIP archives, so check for ZIP signature and then look inside
  if (buffer[0] === 0x50 && buffer[1] === 0x4B && buffer[2] === 0x03 && buffer[3] === 0x04) {
    // Read more bytes to check for Office file signatures
    const bufferStr = buffer.toString('utf8', 0, Math.min(buffer.length, 2000));
    if (bufferStr.includes('word/')) {
      return 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
    }
    if (bufferStr.includes('xl/') || bufferStr.includes('worksheets/')) {
      return 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
    }
    if (bufferStr.includes('ppt/')) {
      return 'application/vnd.openxmlformats-officedocument.presentationml.presentation';
    }
    // Generic ZIP
    return 'application/zip';
  }

  // Microsoft Office 97-2003 (DOC, XLS, PPT): OLE compound document
  // D0 CF 11 E0 A1 B1 1A E1
  if (buffer[0] === 0xD0 && buffer[1] === 0xCF && buffer[2] === 0x11 && buffer[3] === 0xE0) {
    // Try to determine which Office type
    const bufferStr = buffer.toString('utf8', 0, Math.min(buffer.length, 2000));
    if (bufferStr.includes('WordDocument')) {
      return 'application/msword';
    }
    if (bufferStr.includes('Workbook') || bufferStr.includes('Worksheet')) {
      return 'application/vnd.ms-excel';
    }
    return 'application/msword'; // Default to Word
  }

  // BMP: 42 4D
  if (buffer[0] === 0x42 && buffer[1] === 0x4D) {
    return 'image/bmp';
  }

  return 'application/octet-stream';
}

/**
 * Map check-out sectionRef to corresponding check-in sectionRef
 * This handles the naming difference between check-in and check-out templates
 * e.g., "section_checkout_general_info" -> "section_checkin_general_info"
 * or "section_checkout_entry_hallway" -> "section_checkin_entry_hallway"
 */
function mapCheckOutToCheckInSectionRef(checkOutSectionRef: string): string {
  if (!checkOutSectionRef) return "";

  const normalized = checkOutSectionRef.toLowerCase().trim();

  // Replace "checkout" with "checkin" in the sectionRef
  // This handles patterns like: section_checkout_* -> section_checkin_*
  if (normalized.includes("checkout")) {
    return normalized.replace(/checkout/g, "checkin");
  }

  // If it doesn't match the pattern, return as-is (might be a custom section)
  return normalized;
}

/**
 * Map check-in sectionRef to corresponding check-out sectionRef
 * This handles the reverse mapping
 * e.g., "section_checkin_general_info" -> "section_checkout_general_info"
 */
function mapCheckInToCheckOutSectionRef(checkInSectionRef: string): string {
  if (!checkInSectionRef) return "";

  const normalized = checkInSectionRef.toLowerCase().trim();

  // Replace "checkin" with "checkout" in the sectionRef
  if (normalized.includes("checkin")) {
    return normalized.replace(/checkin/g, "checkout");
  }

  // If it doesn't match the pattern, return as-is (might be a custom section)
  return normalized;
}

/**
 * Normalize sectionRef for matching between check-in and check-out inspections
 * Handles variations like "Entry Hallway" vs "Entry / Hallway" vs "Entry/Hallway"
 * Also handles "Bedroom" vs "Bedrooms/Bedroom 1" by extracting the base section name
 */
function normalizeSectionRef(sectionRef: string): string {
  if (!sectionRef) return "";

  // Convert to lowercase for case-insensitive matching
  let normalized = sectionRef.toLowerCase().trim();

  // Normalize common separators: "/", " / ", " /", "/ " to a single space
  normalized = normalized.replace(/\s*\/\s*/g, " ");

  // Replace underscores and hyphens with spaces
  normalized = normalized.replace(/[_\-]/g, " ");

  // Normalize multiple spaces to single space
  normalized = normalized.replace(/\s+/g, " ");

  // Remove leading/trailing spaces
  normalized = normalized.trim();

  // For hierarchical paths like "Bedrooms/Bedroom 1", extract the last part
  // This helps match "Bedroom 1" with "Bedrooms/Bedroom 1"
  const parts = normalized.split(/\s+/);
  if (parts.length > 1) {
    // If it looks like a hierarchical path, try to match on the last meaningful part
    // But keep the full normalized string as primary match
    return normalized;
  }

  return normalized;
}

/**
 * Normalize fieldKey for matching (usually just lowercase and trim)
 */
function normalizeFieldKey(fieldKey: string): string {
  if (!fieldKey) return "";
  // Lowercase, trim, and replace underscores/hyphens with spaces to allow matching "Floor Condition" with "floor_condition"
  return fieldKey.toLowerCase().trim().replace(/[_\-]/g, " ").replace(/\s+/g, " ");
}

/**
 * Map check-out field key to corresponding check-in field key
 * This handles the naming difference between check-in and check-out templates
 * e.g., "field_checkout_entry_door_condition" -> "field_checkin_entry_door_condition"
 */
function mapCheckOutToCheckInFieldKey(checkOutFieldKey: string): string {
  if (!checkOutFieldKey) return "";

  // Replace "checkout" with "checkin" in the field key
  // This handles the pattern: field_checkout_* -> field_checkin_*
  const normalized = checkOutFieldKey.toLowerCase().trim();

  // Direct replacement pattern - replace all occurrences
  if (normalized.includes("checkout")) {
    return normalized.replace(/checkout/g, "checkin");
  }

  // If it doesn't match the pattern, return as-is (might be a custom field)
  return normalized;
}

/**
 * Map check-in field key to corresponding check-out field key
 * This handles the reverse mapping
 * e.g., "field_checkin_entry_door_condition" -> "field_checkout_entry_door_condition"
 */
function mapCheckInToCheckOutFieldKey(checkInFieldKey: string): string {
  if (!checkInFieldKey) return "";

  const normalized = checkInFieldKey.toLowerCase().trim();

  // Direct replacement pattern - replace all occurrences
  if (normalized.includes("checkin")) {
    return normalized.replace(/checkin/g, "checkout");
  }

  // If it doesn't match the pattern, return as-is (might be a custom field)
  return normalized;
}

/**
 * Check if two field keys match, considering the check-in/check-out mapping
 */
function fieldKeysMatch(checkInFieldKey: string, checkOutFieldKey: string): boolean {
  if (!checkInFieldKey || !checkOutFieldKey) {
    console.log(`[fieldKeysMatch] Missing keys: checkIn=${checkInFieldKey}, checkOut=${checkOutFieldKey}`);
    return false;
  }

  const normalizedCheckIn = normalizeFieldKey(checkInFieldKey);
  const normalizedCheckOut = normalizeFieldKey(checkOutFieldKey);

  // Direct match after normalization
  if (normalizedCheckIn === normalizedCheckOut) {
    console.log(`[fieldKeysMatch] Direct match: ${normalizedCheckIn}`);
    return true;
  }

  // Try mapping check-out to check-in and compare
  const mappedCheckOut = mapCheckOutToCheckInFieldKey(checkOutFieldKey);
  const normalizedMappedCheckOut = normalizeFieldKey(mappedCheckOut);
  if (normalizedCheckIn === normalizedMappedCheckOut) {
    console.log(`[fieldKeysMatch] Matched via checkout->checkin mapping: ${checkOutFieldKey} -> ${mappedCheckOut} -> ${normalizedMappedCheckOut} === ${normalizedCheckIn}`);
    return true;
  }

  // Try mapping check-in to check-out and compare
  const mappedCheckIn = mapCheckInToCheckOutFieldKey(checkInFieldKey);
  const normalizedMappedCheckIn = normalizeFieldKey(mappedCheckIn);
  if (normalizedCheckOut === normalizedMappedCheckIn) {
    console.log(`[fieldKeysMatch] Matched via checkin->checkout mapping: ${checkInFieldKey} -> ${mappedCheckIn} -> ${normalizedMappedCheckIn} === ${normalizedCheckOut}`);
    return true;
  }

  console.log(`[fieldKeysMatch] No match: checkIn="${checkInFieldKey}" (normalized: "${normalizedCheckIn}") vs checkOut="${checkOutFieldKey}" (normalized: "${normalizedCheckOut}")`);
  console.log(`[fieldKeysMatch] Mapped checkout->checkin: "${mappedCheckOut}" (normalized: "${normalizedMappedCheckOut}")`);
  console.log(`[fieldKeysMatch] Mapped checkin->checkout: "${mappedCheckIn}" (normalized: "${normalizedMappedCheckIn}")`);
  return false;
}

/**
 * Check if two sectionRefs match after normalization and checkin/checkout mapping
 */
function sectionRefsMatch(ref1: string, ref2: string): boolean {
  if (!ref1 || !ref2) return false;

  const normalized1 = normalizeSectionRef(ref1);
  const normalized2 = normalizeSectionRef(ref2);

  // Exact match after normalization
  if (normalized1 === normalized2) return true;

  // Try mapping check-out to check-in and compare
  const mappedRef2 = mapCheckOutToCheckInSectionRef(ref2);
  if (normalized1 === normalizeSectionRef(mappedRef2)) return true;

  // Try mapping check-in to check-out and compare
  const mappedRef1 = mapCheckInToCheckOutSectionRef(ref1);
  if (normalized2 === normalizeSectionRef(mappedRef1)) return true;

  // Also try matching the last part of hierarchical paths
  // e.g., "bedrooms/bedroom 1" should match "bedroom 1"
  const parts1 = normalized1.split(/\s+/);
  const parts2 = normalized2.split(/\s+/);

  // If one is a subset of the other (last parts match), consider it a match
  if (parts1.length > parts2.length) {
    const lastParts = parts1.slice(-parts2.length).join(" ");
    if (lastParts === normalized2) return true;
  } else if (parts2.length > parts1.length) {
    const lastParts = parts2.slice(-parts1.length).join(" ");
    if (lastParts === normalized1) return true;
  }

  return false;
}

/**
 * Detect image MIME type from file buffer using magic bytes
 * Returns a valid image MIME type (always starts with 'image/')
 */
function detectImageMimeType(buffer: Buffer): string {
  // Validate buffer
  if (!buffer || buffer.length === 0) {
    console.warn('[detectImageMimeType] Empty buffer, defaulting to image/jpeg');
    return 'image/jpeg';
  }

  // Check file signatures (magic bytes)
  if (buffer.length < 4) {
    console.warn('[detectImageMimeType] Buffer too small, defaulting to image/jpeg');
    return 'image/jpeg';
  }

  // JPEG: FF D8 FF (can be followed by E0, E1, etc.)
  if (buffer[0] === 0xFF && buffer[1] === 0xD8 && buffer[2] === 0xFF) {
    return 'image/jpeg';
  }

  // PNG: 89 50 4E 47 0D 0A 1A 0A
  if (buffer[0] === 0x89 && buffer[1] === 0x50 && buffer[2] === 0x4E && buffer[3] === 0x47) {
    return 'image/png';
  }

  // GIF: 47 49 46 38 (GIF8) or 47 49 46 39 (GIF9)
  if (buffer[0] === 0x47 && buffer[1] === 0x49 && buffer[2] === 0x46 &&
    (buffer[3] === 0x38 || buffer[3] === 0x39)) {
    return 'image/gif';
  }

  // WebP: Check for RIFF...WEBP
  if (buffer.length >= 12 &&
    buffer[0] === 0x52 && buffer[1] === 0x49 && buffer[2] === 0x46 && buffer[3] === 0x46 &&
    buffer[8] === 0x57 && buffer[9] === 0x45 && buffer[10] === 0x42 && buffer[11] === 0x50) {
    return 'image/webp';
  }

  // BMP: 42 4D
  if (buffer[0] === 0x42 && buffer[1] === 0x4D) {
    return 'image/bmp';
  }

  // Default to JPEG if we can't detect (most common image format)
  // This ensures we always return a valid image MIME type
  console.warn('[detectImageMimeType] Could not detect image type from magic bytes, defaulting to image/jpeg. First bytes:',
    Array.from(buffer.slice(0, 8)).map(b => `0x${b.toString(16).padStart(2, '0')}`).join(' '));
  return 'image/jpeg';
}
import { setupAuth, isAuthenticated, requireRole, hashPassword, comparePasswords } from "./auth";

// Middleware that allows both regular users and admins
const isUserOrAdmin = (req: any, res: any, next: any) => {
  // Check for admin session
  if (req.session && (req.session as any).adminUser) {
    return next();
  }
  // Check for regular user authentication
  if (req.isAuthenticated()) {
    return next();
  }
  res.status(401).json({ message: "Unauthorized" });
};
import { ObjectStorageService, ObjectNotFoundError } from "./objectStorage";
import { ObjectPermission, getObjectAclPolicy } from "./objectAcl";
import { db } from "./db";
import { eq, and, lt, gt, desc, inArray, or, sql } from "drizzle-orm";
import OpenAI, { toFile } from "openai";
import bcrypt from "bcryptjs";
import { z } from "zod";
import multer from "multer";
import { format } from "date-fns";

/**
 * Safely log error without causing serialization issues
 * Handles circular references and un-serializable properties
 */
function safeErrorLog(message: string, error: any): void {
  try {
    const errorMessage = error?.message || error?.toString() || "Unknown error";
    console.error(message, errorMessage);
    if (error?.stack) {
      console.error("Stack trace:", error.stack);
    }
    // Log additional error properties if they exist and are safe
    if (error?.name) {
      console.error("Error name:", error.name);
    }
    if (error?.code) {
      console.error("Error code:", error.code);
    }
  } catch (logError) {
    // If even logging fails, just log a basic message
    console.error(message, "Failed to log error details");
  }
}
import { devRouter } from "./devRoutes";
import { sendInspectionCompleteEmail, sendTeamWorkOrderNotification, sendContractorWorkOrderNotification, sendComparisonReportToFinance } from "./resend";
import { DEFAULT_TEMPLATES } from "./defaultTemplates";
import { generateInspectionPDF } from "./pdfService";
import { extractTextFromFile, findRelevantChunks } from "./documentProcessor";
import {
  insertBlockSchema,
  insertContactSchema,
  insertInventoryTemplateSchema,
  insertInventorySchema,
  insertInventoryItemSchema,
  insertWorkOrderSchema,
  insertWorkLogSchema,
  insertAssetInventorySchema,
  insertTagSchema,
  insertTemplateCategorySchema,
  insertInspectionTemplateSchema,
  insertTemplateInventoryLinkSchema,
  insertInspectionEntrySchema,
  insertAiImageAnalysisSchema,
  insertPropertySchema,
  insertComplianceDocumentSchema,
  insertMaintenanceRequestSchema,
  insertInspectionSchema,
  createOrganizationSchema,
  createTeamMemberSchema,
  updateTeamMemberSchema,
  updateUserRoleSchema,
  updateUserStatusSchema,
  updateSelfProfileSchema,
  updatePropertySchema,
  updateComplianceDocumentSchema,
  updateMaintenanceRequestSchema,
  analyzePhotoSchema,
  inspectFieldSchema,
  generateComparisonSchema,
  analyzeMaintenanceImageSchema,
  updateContactSchema,
  updateTagSchema,
  updateDashboardPreferencesSchema,
  updateTemplateCategorySchema,
  updateInspectionSchema,
  updateBlockSchema,
  insertMessageTemplateSchema,
  updateMessageTemplateSchema,
  insertTenantAssignmentSchema,
  updateTenantAssignmentSchema,
  quickAddAssetSchema,
  quickAddMaintenanceSchema,
  quickUpdateAssetSchema,
  maintenanceRequests,
  teams,
  teamMembers,
  teamCategories,
  insertPlanSchema,
  insertCreditBundleSchema,
  insertCountryPricingOverrideSchema,
  creditBatches,
  subscriptions,
  tenantAssignments,
  properties,
  comparisonReportItems,
  insertInstanceSubscriptionSchema,
  insertInstanceModuleSchema,
  instanceModules,
  organizations,
  inspections,
  adminUsers,
  type User,
} from "@shared/schema";
import { pricingService } from "./pricingService";

// Initialize OpenAI using Replit AI Integrations (lazy initialization)
// Using gpt-5 for vision analysis - the newest OpenAI model (released August 7, 2025), supports images and provides excellent results

// Detect if running in a cloud/sandboxed environment (AWS Lambda, Vercel, Netlify, Replit)
const isCloudEnvironment = !!(
  process.env.AWS_LAMBDA_FUNCTION_NAME ||
  process.env.VERCEL ||
  process.env.NETLIFY ||
  process.env.REPLIT_ENVIRONMENT ||
  process.env.REPLIT_CLUSTER
);

// Helper function to launch Puppeteer with appropriate configuration
async function launchPuppeteerBrowser() {
  if (isCloudEnvironment) {
    // Cloud/sandboxed environment (Replit, AWS Lambda, etc.) - use @sparticuz/chromium
    const chromium = await import("@sparticuz/chromium");
    const puppeteer = await import("puppeteer-core");

    return await puppeteer.default.launch({
      args: [
        ...chromium.default.args,
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-accelerated-2d-canvas',
        '--no-first-run',
        '--no-zygote',
        '--disable-gpu',
        '--single-process',
      ],
      executablePath: await chromium.default.executablePath(),
      headless: true,
    });
  } else {
    // Local development - use Puppeteer's bundled Chromium
    const puppeteer = await import("puppeteer");
    return await puppeteer.default.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu'
      ],
    });
  }
}

/**
 * Normalizes content for OpenAI Responses API format.
 * Converts legacy chat.completions format to responses.create format.
 * @param content - Array of content items with type "text" or "image_url"
 * @returns Array of normalized content items with type "input_text" or "input_image"
 * @throws Error if content type is not supported
 */
/**
 * Clean and format markdown text for display
 * Removes markdown syntax and formats it nicely
 */
function cleanMarkdownText(text: string): string {
  if (!text) return text;

  // Remove markdown bold (**text** or __text__)
  let cleaned = text.replace(/\*\*(.*?)\*\*/g, '$1');
  cleaned = cleaned.replace(/__(.*?)__/g, '$1');

  // Remove markdown italic (*text* or _text_)
  cleaned = cleaned.replace(/\*(.*?)\*/g, '$1');
  cleaned = cleaned.replace(/_(.*?)_/g, '$1');

  // Remove markdown headers (# Header)
  cleaned = cleaned.replace(/^#{1,6}\s+(.*)$/gm, '$1');

  // Remove markdown code blocks (```code```)
  cleaned = cleaned.replace(/```[\s\S]*?```/g, '');

  // Remove inline code (`code`)
  cleaned = cleaned.replace(/`([^`]+)`/g, '$1');

  // Remove markdown links [text](url) -> text
  cleaned = cleaned.replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1');

  // Clean up extra whitespace
  cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
  cleaned = cleaned.trim();

  return cleaned;
}

function normalizeApiContent(content: any[]): any[] {
  return content.map((item: any, index: number) => {
    if (item.type === "text") {
      return { type: "input_text", text: item.text };
    } else if (item.type === "image_url") {
      // Extract URL from object or use directly if already a string
      const url = typeof item.image_url === 'string' ? item.image_url : item.image_url?.url;
      if (!url) {
        throw new Error(`[normalizeApiContent] Missing image URL at index ${index}`);
      }
      return { type: "input_image", image_url: url };
    } else if (item.type === "input_text") {
      // Already normalized - pass through
      return item;
    } else if (item.type === "input_image") {
      // Already normalized - ensure URL is a string
      if (typeof item.image_url !== 'string') {
        throw new Error(`[normalizeApiContent] image_url must be a string at index ${index}, got ${typeof item.image_url}`);
      }
      return item;
    } else {
      throw new Error(`[normalizeApiContent] Unsupported content type at index ${index}: ${item.type}`);
    }
  });
}
let openai: OpenAI | null = null;
function getOpenAI(): OpenAI {
  if (!openai) {
    if (!process.env.AI_INTEGRATIONS_OPENAI_BASE_URL || !process.env.AI_INTEGRATIONS_OPENAI_API_KEY) {
      throw new Error("OpenAI integration not configured. Please set up the AI Integrations.");
    }
    openai = new OpenAI({
      baseURL: process.env.AI_INTEGRATIONS_OPENAI_BASE_URL,
      apiKey: process.env.AI_INTEGRATIONS_OPENAI_API_KEY
    });
  }
  return openai;
}

/**
 * Generate an AI banner for a community discussion group.
 * Uses DALL-E to create a relevant banner image and composites the organization logo.
 */
async function generateGroupBanner(
  groupName: string,
  groupDescription: string | null,
  organizationLogoUrl: string | null,
  objectStorageService: ObjectStorageService
): Promise<string | null> {
  try {
    console.log(`[BannerGen] Generating banner for group: "${groupName}"`);

    const client = getOpenAI();

    // Create a prompt for DALL-E that generates a relevant abstract banner
    const prompt = `Create a professional, abstract banner image for a community discussion group called "${groupName}". ${groupDescription ? `The group is about: ${groupDescription}.` : ''} 
Style: Modern, clean, gradient colors using teal (#3B7A8C) and cyan (#00D5CC) accents. Abstract geometric patterns or soft gradients. Professional and welcoming. No text, no people, no logos. Suitable as a wide banner header image. Aspect ratio 16:9.`;

    console.log(`[BannerGen] Calling DALL-E with prompt`);

    // Generate image using DALL-E 3
    const response = await client.images.generate({
      model: "dall-e-3",
      prompt: prompt,
      n: 1,
      size: "1792x1024",
      quality: "standard",
      style: "vivid",
    });

    const generatedImageUrl = response.data?.[0]?.url;
    if (!generatedImageUrl) {
      console.error("[BannerGen] No image URL in DALL-E response");
      return null;
    }

    console.log(`[BannerGen] DALL-E image generated, fetching...`);

    // Fetch the generated image
    const imageResponse = await fetch(generatedImageUrl);
    if (!imageResponse.ok) {
      console.error("[BannerGen] Failed to fetch generated image");
      return null;
    }

    let bannerBuffer = Buffer.from(await imageResponse.arrayBuffer());

    // Validate the buffer is a valid image
    if (!bannerBuffer || bannerBuffer.length < 100) {
      console.error("[BannerGen] Invalid or empty image buffer from DALL-E");
      return null;
    }

    // Verify it's a valid image by checking with sharp
    try {
      const metadata = await sharp(bannerBuffer).metadata();
      if (!metadata.width || !metadata.height) {
        console.error("[BannerGen] Generated image has no dimensions");
        return null;
      }
      console.log(`[BannerGen] Generated image: ${metadata.width}x${metadata.height} ${metadata.format}`);
    } catch (validationError: any) {
      console.error(`[BannerGen] Invalid image data: ${validationError.message}`);
      return null;
    }

    // If organization has a logo, composite it onto the banner
    if (organizationLogoUrl) {
      try {
        console.log(`[BannerGen] Compositing organization logo`);

        // Fetch the organization logo
        let logoBuffer: Buffer;

        if (organizationLogoUrl.startsWith('/objects/')) {
          // Local object storage
          const logoFile = await objectStorageService.getObjectEntityFile(organizationLogoUrl);
          logoBuffer = await fs.readFile(logoFile.name);
        } else if (organizationLogoUrl.startsWith('http')) {
          // Remote URL
          const logoResponse = await fetch(organizationLogoUrl);
          if (!logoResponse.ok) {
            throw new Error("Failed to fetch logo");
          }
          logoBuffer = Buffer.from(await logoResponse.arrayBuffer());
        } else {
          throw new Error("Unsupported logo URL format");
        }

        // Get banner dimensions
        const bannerMetadata = await sharp(bannerBuffer).metadata();
        const bannerWidth = bannerMetadata.width || 1792;
        const bannerHeight = bannerMetadata.height || 1024;

        // Resize logo to appropriate size (max 120px height, maintain aspect ratio)
        const maxLogoHeight = 120;
        const maxLogoWidth = 200;
        const resizedLogo = await sharp(logoBuffer)
          .resize({
            width: maxLogoWidth,
            height: maxLogoHeight,
            fit: 'inside',
            background: { r: 0, g: 0, b: 0, alpha: 0 },
          })
          .png()
          .toBuffer();

        const logoMetadata = await sharp(resizedLogo).metadata();
        const logoWidth = logoMetadata.width || maxLogoWidth;
        const logoHeight = logoMetadata.height || maxLogoHeight;

        // Position logo in top-right corner with padding
        const padding = 20;
        const logoX = bannerWidth - logoWidth - padding;
        const logoY = padding;

        // Create a semi-transparent white background for the logo for better visibility
        const logoBgSize = Math.max(logoWidth, logoHeight) + 20;
        const logoBg = await sharp({
          create: {
            width: logoWidth + 20,
            height: logoHeight + 20,
            channels: 4,
            background: { r: 255, g: 255, b: 255, alpha: 0.85 },
          },
        })
          .png()
          .toBuffer();

        // Composite the background and logo onto the banner
        bannerBuffer = await sharp(bannerBuffer)
          .composite([
            {
              input: logoBg,
              left: logoX - 10,
              top: logoY - 10,
              blend: 'over',
            },
            {
              input: resizedLogo,
              left: logoX,
              top: logoY,
              blend: 'over',
            },
          ])
          .png()
          .toBuffer();

        console.log(`[BannerGen] Logo composited successfully`);
      } catch (logoError: any) {
        console.warn(`[BannerGen] Failed to composite logo: ${logoError.message}`);
        // Continue without logo
      }
    }

    // Save the banner to object storage
    const bannerId = randomUUID();
    const bannerPath = await objectStorageService.saveUploadedFile(
      `community-banners/${bannerId}.png`,
      bannerBuffer,
      'image/png'
    );

    // Set the banner as public so it can be accessed without authentication
    try {
      await objectStorageService.trySetObjectEntityAclPolicy(bannerPath, {
        owner: '', // No specific owner needed for public banners
        visibility: 'public',
      });
      console.log(`[BannerGen] Banner set as public: ${bannerPath}`);
    } catch (aclError: any) {
      console.warn(`[BannerGen] Failed to set banner ACL to public: ${aclError.message}`);
      // Continue anyway - the banner is saved, just might require auth
    }

    console.log(`[BannerGen] Banner saved to: ${bannerPath}`);
    return bannerPath;
  } catch (error: any) {
    console.error(`[BannerGen] Error generating banner: ${error.message}`);
    return null;
  }
}

/**
 * Background process to analyze all inspection entries with photos using AI.
 * Updates progress on the inspection record as each entry is processed.
 */
async function processInspectionAIAnalysis(
  inspectionId: string,
  entriesWithPhotos: any[],
  inspection: any,
  organization: any,
  organizationId: string
): Promise<void> {
  console.log(`[FullInspectAI] Starting background analysis for inspection ${inspectionId} with ${entriesWithPhotos.length} entries`);

  const objectStorageService = new ObjectStorageService();

  // Get template settings for AI configuration
  let aiMaxWords: number = 150;
  let aiInstruction: string = "";

  if (inspection.templateId) {
    const template = await storage.getInspectionTemplate(inspection.templateId);
    if (template) {
      aiMaxWords = template.aiMaxWords ?? organization.defaultAiMaxWords ?? 150;
      aiInstruction = template.aiInstruction || organization.defaultAiInstruction || "";
    }
  } else {
    aiMaxWords = organization.defaultAiMaxWords ?? 150;
    aiInstruction = organization.defaultAiInstruction || "";
  }

  let processedCount = 0;
  let totalCreditsUsed = 0;

  for (const entry of entriesWithPhotos) {
    try {
      console.log(`[FullInspectAI] Processing entry ${processedCount + 1}/${entriesWithPhotos.length}: ${entry.fieldKey}`);

      // Convert photos to base64 data URLs
      const photoUrls: string[] = [];
      for (const photo of entry.photos) {
        try {
          if (photo.startsWith("http")) {
            photoUrls.push(photo);
            continue;
          }

          const photoPath = photo.startsWith('/objects/') ? photo : `/objects/${photo}`;
          const objectFile = await objectStorageService.getObjectEntityFile(photoPath);
          const fileBuffer = await fs.readFile(objectFile.name);

          let contentType = detectImageMimeType(fileBuffer);
          if (!contentType || !contentType.startsWith('image/')) {
            contentType = 'image/jpeg';
          }

          const base64Data = fileBuffer.toString('base64');
          const dataUrl = `data:${contentType};base64,${base64Data}`;
          photoUrls.push(dataUrl);
        } catch (photoError: any) {
          console.error(`[FullInspectAI] Error loading photo ${photo}:`, photoError.message);
          // Skip this photo but continue with others
        }
      }

      if (photoUrls.length === 0) {
        console.log(`[FullInspectAI] No valid photos for entry ${entry.fieldKey}, skipping`);
        processedCount++;
        continue;
      }

      // Build the field label from sectionRef and fieldKey
      // sectionRef = Category (e.g., "Kitchen", "Bathroom", "Living Room")
      // fieldKey = Inspection Point Title (e.g., "Oven Condition", "Sink and Taps")
      const category = entry.sectionRef || "General";
      const inspectionPointTitle = entry.fieldKey || "Item";
      const fieldLabel = `${category}${entry.itemRef ? ` - ${entry.itemRef}` : ''} - ${inspectionPointTitle}`;

      // Build prompt with explicit Category and Inspection Point context
      let promptText: string;
      if (aiInstruction) {
        promptText = `${aiInstruction}

INSPECTION CONTEXT:
- Category: "${category}"
- Inspection Point: "${inspectionPointTitle}"

I have ${photoUrls.length} image(s) uploaded for this specific inspection point. Analyze ALL images in the context of "${inspectionPointTitle}" within the "${category}" category.

CRITICAL: Focus your analysis EXCLUSIVELY on "${inspectionPointTitle}". The photo may show the entire ${category} area, but you must ONLY analyze and report on "${inspectionPointTitle}".

IMPORTANT FORMATTING RULES:
- Keep your response under ${aiMaxWords} words
- Write in plain text only - do NOT use asterisks (*), hash symbols (#), bullet points, or numbered lists
- Do NOT use any markdown formatting
- Do NOT include emojis
- Write in professional, flowing paragraphs`;
      } else {
        promptText = `You are a property inspector analyzing photos for a specific inspection point.

INSPECTION CONTEXT:
- Category: "${category}"
- Inspection Point: "${inspectionPointTitle}"

CRITICAL: I have ${photoUrls.length} image(s) uploaded specifically for "${inspectionPointTitle}" in the "${category}". The photo may show the entire ${category} area, but you MUST focus your analysis EXCLUSIVELY on "${inspectionPointTitle}". Do NOT describe or analyze any other elements visible in the photo.

Provide a focused assessment for "${inspectionPointTitle}" covering:
- Overall condition assessment of "${inspectionPointTitle}" specifically
- Any visible damage, defects, or wear on "${inspectionPointTitle}"
- Cleanliness and maintenance issues related to "${inspectionPointTitle}"
- Brief recommendation (only if action is needed for "${inspectionPointTitle}")

IMPORTANT FORMATTING RULES:
- Keep your response under ${aiMaxWords} words
- Write in plain text only - do NOT use asterisks (*), hash symbols (#), bullet points, or numbered lists
- Do NOT use any markdown formatting
- Do NOT include emojis
- Write in professional, flowing paragraphs

Be thorough but concise, specific, and objective about "${inspectionPointTitle}" in the "${category}". This will be used in a professional property inspection report.`;
      }

      // Build content array
      const content: any[] = [{ type: "text", text: promptText }];
      photoUrls.forEach(url => {
        content.push({ type: "image_url", image_url: url });
      });

      // Call OpenAI Vision API
      const response = await getOpenAI().responses.create({
        model: "gpt-5",
        input: [{ role: "user", content: normalizeApiContent(content) }],
        max_output_tokens: 10000,
      });

      // Extract analysis text from response
      let analysis: string | null = null;

      if (response.output_text) {
        analysis = response.output_text;
      } else if (response.output && response.output.length > 0) {
        for (const outputItem of response.output) {
          if ((outputItem as any).content && Array.isArray((outputItem as any).content)) {
            for (const contentItem of (outputItem as any).content) {
              if (contentItem.type === 'output_text' && contentItem.text) {
                analysis = contentItem.text;
                break;
              }
              if (contentItem.type === 'text' && contentItem.text) {
                analysis = contentItem.text;
                break;
              }
            }
            if (analysis) break;
          }
        }
      }

      if (!analysis || analysis.trim().length === 0) {
        console.error(`[FullInspectAI] Empty analysis for entry ${entry.fieldKey}`);
        processedCount++;
        await storage.updateInspection(inspectionId, {
          aiAnalysisProgress: processedCount
        } as any);
        continue;
      }

      // Strip forbidden characters
      analysis = analysis
        .replace(/\*+/g, '')
        .replace(/#+/g, '')
        // Remove emojis (simplified approach for compatibility)
        .replace(/([\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2580-\u27BF]|\uD83E[\uDD10-\uDDFF])/g, '')
        .replace(/\n{3,}/g, '\n\n')
        .trim();

      // Update entry note - append if existing notes
      const existingNote = entry.note || "";
      const newNote = existingNote
        ? `${existingNote}\n\n${analysis}`
        : `${analysis}`;

      await storage.updateInspectionEntry(entry.id, { note: newNote });

      // Deduct credit
      // Consume credit using credit batch system
      const { subscriptionService } = await import("./subscriptionService");
      await subscriptionService.consumeCredits(
        organization.id,
        1,
        "inspection",
        inspectionId,
        `InspectAI full report analysis: ${fieldLabel}`
      );
      totalCreditsUsed++;

      processedCount++;

      // Update progress
      await storage.updateInspection(inspectionId, {
        aiAnalysisProgress: processedCount
      } as any);

      console.log(`[FullInspectAI] Completed entry ${processedCount}/${entriesWithPhotos.length}: ${entry.fieldKey}`);

    } catch (entryError: any) {
      console.error(`[FullInspectAI] Error processing entry ${entry.fieldKey}:`, entryError.message);
      // Continue with next entry rather than failing completely
      processedCount++;
      await storage.updateInspection(inspectionId, {
        aiAnalysisProgress: processedCount
      } as any);
    }
  }

  // Mark as completed
  await storage.updateInspection(inspectionId, {
    aiAnalysisStatus: "completed",
    aiAnalysisProgress: entriesWithPhotos.length,
    aiAnalysisError: null
  } as any);

  console.log(`[FullInspectAI] Completed analysis for inspection ${inspectionId}. Processed ${processedCount} entries, used ${totalCreditsUsed} credits.`);
}

// Helper function to get the base URL from request, respecting proxy headers
function getBaseUrl(req: any): string {
  // 1. Check environment variable first
  if (process.env.BASE_URL) {
    console.log(`[getBaseUrl] Using BASE_URL from env: ${process.env.BASE_URL}`);
    return process.env.BASE_URL;
  }

  // 2. Check for proxy headers (X-Forwarded-Proto and X-Forwarded-Host)
  const forwardedProto = req.headers['x-forwarded-proto'];
  const forwardedHost = req.headers['x-forwarded-host'];
  if (forwardedProto && forwardedHost) {
    const url = `${forwardedProto}://${forwardedHost}`;
    console.log(`[getBaseUrl] Using forwarded headers: ${url}`);
    return url;
  }

  // 3. Check request origin header
  if (req.headers.origin) {
    try {
      const url = new URL(req.headers.origin).origin;
      console.log(`[getBaseUrl] Using origin header: ${url}`);
      return url;
    } catch (e) {
      // Invalid origin, continue to next option
    }
  }

  // 4. Check referer header (often more reliable than origin)
  if (req.headers.referer || req.headers.referrer) {
    try {
      const referer = req.headers.referer || req.headers.referrer;
      const url = new URL(referer).origin;
      console.log(`[getBaseUrl] Using referer header: ${url}`);
      return url;
    } catch (e) {
      // Invalid referer, continue to next option
    }
  }

  // 5. Use req.protocol and req.get('host') (works with trust proxy)
  const protocol = req.protocol || 'http';
  const host = req.get('host');
  if (host) {
    const url = `${protocol}://${host}`;
    console.log(`[getBaseUrl] Using req.protocol/host: ${url}`);
    return url;
  }

  // 6. Fallback to localhost
  const fallback = `http://localhost:${process.env.PORT || 5005}`;
  console.log(`[getBaseUrl] Using fallback: ${fallback}`);
  console.log(`[getBaseUrl] Debug info:`, {
    hasOrigin: !!req.headers.origin,
    hasReferer: !!(req.headers.referer || req.headers.referrer),
    hasForwardedProto: !!forwardedProto,
    hasForwardedHost: !!forwardedHost,
    protocol: req.protocol,
    host: req.get('host'),
    headers: {
      origin: req.headers.origin,
      referer: req.headers.referer || req.headers.referrer,
      'x-forwarded-proto': forwardedProto,
      'x-forwarded-host': forwardedHost,
    }
  });
  return fallback;
}

/**
 * Helper function to check if a module is available for an organization
 */
async function isModuleAvailableForInstance(moduleKey: string, organizationId: string): Promise<boolean> {
  try {
    // 1. Check if module is globally enabled
    const module = await storage.getMarketplaceModuleByKey(moduleKey);
    if (!module || !module.isAvailableGlobally) {
      return false;
    }

    // 2. Check if instance has active subscription
    const instanceSub = await storage.getInstanceSubscription(organizationId);
    if (!instanceSub) {
      return false;
    }

    // 3. Check if module is enabled for this instance
    const instanceModule = await storage.getInstanceModuleByModuleKey(instanceSub.id, moduleKey);
    return instanceModule?.isEnabled === true;
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : (typeof error === 'object' && error !== null && 'message' in error ? String((error as any).message) : String(error));
    console.error(`Error checking module availability for ${moduleKey}:`, errorMessage);
    return false;
  }
}

export async function registerRoutes(app: Express): Promise<Server> {
  // ==================== CONFIG ROUTES ====================

  // Get Google Maps API key (public endpoint, but API key is restricted by domain in Google Console)
  // Geolocation proxy endpoint to avoid CORS issues
  app.get("/api/geolocation", async (req: any, res) => {
    try {
      // Proxy request to ipapi.co to avoid CORS issues
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
      
      const response = await fetch("https://ipapi.co/json/", {
        headers: {
          "User-Agent": "Inspect360/1.0",
        },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        return res.json({ 
          countryCode: "GB", // Default fallback
          countryName: "United Kingdom"
        });
      }

      const data = await response.json();
      
      // Return only the data we need
      res.json({
        countryCode: data.country_code || "GB",
        countryName: data.country_name || "United Kingdom",
        city: data.city,
        timezone: data.timezone,
      });
    } catch (error: any) {
      // Return default values on error (fail silently)
      res.json({
        countryCode: "GB",
        countryName: "United Kingdom",
      });
    }
  });

  app.get("/api/config/google-maps-key", async (req: any, res) => {
    try {
      // Check all possible ways the key might be set
      const apiKey = process.env.GOOGLE_MAPS_API_KEY?.trim() ||
        process.env['GOOGLE_MAPS_API_KEY']?.trim();

      console.log('[Google Maps API] Checking API key:', {
        exists: !!apiKey,
        length: apiKey?.length || 0,
        startsWith: apiKey?.substring(0, 10) || 'N/A',
        rawEnvValue: process.env.GOOGLE_MAPS_API_KEY ? 'present' : 'missing',
        allEnvKeys: Object.keys(process.env).filter(k => k.includes('GOOGLE')).join(', ')
      });

      if (!apiKey || apiKey.length === 0) {
        console.warn('[Google Maps API] API key not configured in environment variables');
        console.warn('[Google Maps API] Available env vars with GOOGLE:',
          Object.keys(process.env).filter(k => k.toUpperCase().includes('GOOGLE')));
        // Return 200 with null to indicate API key is not configured
        // This allows the client to gracefully handle missing API key
        return res.json({ apiKey: null, configured: false });
      }
      console.log('[Google Maps API] API key found, returning to client (length:', apiKey.length, ')');
      res.json({ apiKey, configured: true });
    } catch (error: any) {
      const errorMessage = error instanceof Error ? error.message : (error?.message || error?.toString() || "Unknown error");
      console.error("Error fetching Google Maps API key:", errorMessage);
      res.status(500).json({ error: "Failed to fetch API key", apiKey: null, configured: false });
    }
  });
  // Auth middleware
  const authStartTime = Date.now();
  await setupAuth(app);
  console.log(`âœ… Auth setup completed (took ${Date.now() - authStartTime}ms)`);

  // ==================== ERROR HANDLING MIDDLEWARE ====================
  // Handle Passport deserialization errors gracefully
  // This must be placed AFTER setupAuth so Passport middleware is initialized
  app.use((err: any, req: any, res: any, next: any) => {
    // Check if this is a Passport deserialization error
    if (err && err.message && err.message.includes('Failed to deserialize user out of session')) {
      console.warn('[Deserialize Error] Clearing invalid session for user:', req.session?.passport?.user);
      // Clear the invalid session
      if (req.logout) {
        req.logout((logoutErr: any) => {
          if (logoutErr) {
            console.error('[Deserialize Error] Error clearing session:', logoutErr);
          }
        });
      }
      // Destroy the session
      if (req.session && req.session.destroy) {
        req.session.destroy((destroyErr: any) => {
          if (destroyErr) {
            console.error('[Deserialize Error] Error destroying session:', destroyErr);
          }
        });
      }
      // Return 401 for API requests, or continue for non-API requests
      if (req.path && req.path.startsWith('/api')) {
        return res.status(401).json({ message: 'Session expired. Please log in again.' });
      }
      // For non-API requests, just continue (they'll be handled by auth middleware)
      return next();
    }
    // For other errors, pass to next error handler
    next(err);
  });

  // Configure multer for file uploads (memory storage for local file system)
  const upload = multer({
    storage: multer.memoryStorage(),
    limits: {
      fileSize: 100 * 1024 * 1024, // 100MB limit
    },
  });

  // ==================== DEV ROUTES (Development Only) ====================
  if (process.env.NODE_ENV === "development") {
    app.use("/api/dev", devRouter);
  }

  // ==================== AUTH ROUTES ====================

  app.get('/api/auth/user', isUserOrAdmin, async (req: any, res) => {
    try {
      // Check if admin is logged in
      if (req.session && (req.session as any).adminUser) {
        const adminUser = (req.session as any).adminUser;
        // Return admin user in compatible format
        return res.json({
          id: adminUser.id,
          email: adminUser.email,
          firstName: adminUser.firstName,
          lastName: adminUser.lastName,
          role: "admin",
          isAdmin: true,
          // Admin doesn't have organization, return null
          organization: null,
          organizationId: null,
        });
      }

      // Regular user authentication
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Include organization info if user belongs to one
      let organization = null;
      if (user.organizationId) {
        organization = await storage.getOrganization(user.organizationId);
      }

      // Exclude password from response for security
      const { password, resetToken, resetTokenExpiry, ...userWithoutPassword } = user;

      // Add organization currency and country code to user object for easy access
      const responseData: any = { ...userWithoutPassword, organization };
      if (organization) {
        responseData.organizationCountryCode = organization.countryCode;
        responseData.organizationCurrency = organization.preferredCurrency || "GBP";
      }

      // Return user object directly (not wrapped in { user: ... })
      // This matches what the frontend expects
      res.json(responseData);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });

  app.get('/api/auth/profile', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Exclude password from response for security
      const { password, ...userWithoutPassword } = user;
      res.json(userWithoutPassword);
    } catch (error) {
      console.error("Error fetching profile:", error);
      res.status(500).json({ message: "Failed to fetch profile" });
    }
  });

  app.patch('/api/auth/profile', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;

      // Log the incoming request for debugging
      console.log('[PATCH /api/auth/profile] Request body:', JSON.stringify(req.body));

      // Validate request body using the self-profile update schema
      const validation = updateSelfProfileSchema.safeParse(req.body);
      if (!validation.success) {
        console.error('[PATCH /api/auth/profile] Validation failed:', validation.error.errors);
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      console.log('[PATCH /api/auth/profile] Validated data:', JSON.stringify(validation.data));
      console.log('[PATCH /api/auth/profile] Validated data keys:', Object.keys(validation.data));

      if (Object.keys(validation.data).length === 0) {
        console.error('[PATCH /api/auth/profile] No valid fields after validation. Original body:', JSON.stringify(req.body));
        return res.status(400).json({ message: "No valid fields to update" });
      }

      const updatedUser = await storage.updateUser(userId, validation.data);

      // Exclude password from response
      const { password, ...userWithoutPassword } = updatedUser;
      res.json(userWithoutPassword);
    } catch (error) {
      console.error("Error updating profile:", error);
      res.status(500).json({ message: "Failed to update profile" });
    }
  });

  // Complete onboarding for first-time users
  app.post('/api/auth/complete-onboarding', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;

      const updatedUser = await storage.updateUser(userId, { onboardingCompleted: true });

      // Exclude password from response
      const { password, ...userWithoutPassword } = updatedUser;
      res.json(userWithoutPassword);
    } catch (error) {
      console.error("Error completing onboarding:", error);
      res.status(500).json({ message: "Failed to complete onboarding" });
    }
  });

  // Change password endpoint
  app.patch('/api/auth/change-password', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const { currentPassword, newPassword } = req.body;

      if (!currentPassword || !newPassword) {
        return res.status(400).json({ message: "Current password and new password are required" });
      }

      if (newPassword.length < 6) {
        return res.status(400).json({ message: "Password must be at least 6 characters" });
      }

      // Get user from users table to verify current password
      const user = await storage.getUser(userId);
      if (!user || !user.password) {
        return res.status(404).json({ message: "User not found" });
      }

      // Verify current password using comparePasswords (supports both scrypt and bcrypt formats)
      const isPasswordValid = await comparePasswords(currentPassword, user.password);
      if (!isPasswordValid) {
        return res.status(401).json({ message: "Current password is incorrect" });
      }

      // Hash new password using the same method as registration (scrypt)
      const hashedPassword = await hashPassword(newPassword);

      // Update password in users table (same table used for login)
      await storage.updatePassword(userId, hashedPassword);

      console.log(`[Change Password] Password updated successfully for user ${userId} (${user.email})`);
      res.json({ message: "Password changed successfully" });
    } catch (error) {
      console.error("Error changing password:", error);
      res.status(500).json({ message: "Failed to change password" });
    }
  });

  // ==================== ORGANIZATION ROUTES ====================

  app.post("/api/organizations", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;

      // Validate request body
      const validation = createOrganizationSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      // Get current user data
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Create organization
      const organization = await storage.createOrganization({
        name: validation.data.name,
        ownerId: userId,
        // Credits are now granted via credit batch system (see below)
      });

      // Update user with organization ID and set role to owner (preserving all existing fields)
      await storage.upsertUser({
        ...user,
        organizationId: organization.id,
        role: "owner",
      });

      // Create initial credit transaction for free credits
      await storage.createCreditTransaction({
        organizationId: organization.id,
        amount: 5,
        type: "purchase",
        description: "Welcome credits",
      });

      // Create default inspection templates (Check In and Check Out)
      // Use defensive error handling so org creation succeeds even if template seeding fails
      try {
        for (const template of DEFAULT_TEMPLATES) {
          await storage.createInspectionTemplate({
            organizationId: organization.id,
            name: template.name,
            description: template.description,
            scope: template.scope,
            version: 1,
            isActive: true,
            structureJson: template.structureJson,
            categoryId: template.categoryId,
            createdBy: userId,
          });
        }
        console.log(`âœ“ Created ${DEFAULT_TEMPLATES.length} default templates for organization ${organization.id}`);
      } catch (templateError) {
        // Log the error but don't fail the entire organization creation
        console.error("Warning: Failed to create default templates, but organization was created successfully:", templateError);
      }

      // Create sample data for new organization (Block A, Property A, Joe Bloggs tenant)
      // Use timestamp-based unique suffix for idempotency
      try {
        const uniqueSuffix = Date.now().toString(36); // Convert timestamp to base36 for shorter suffix

        // Create Block A
        const blockA = await storage.createBlock({
          organizationId: organization.id,
          name: "Block A",
          address: "123 Sample Street, Sample City, SC 12345",
          notes: "Sample block created automatically for demonstration purposes",
        });
        console.log(`âœ“ Created sample Block A for organization ${organization.id}`);

        // Create Property A linked to Block A
        const propertyA = await storage.createProperty({
          organizationId: organization.id,
          blockId: blockA.id,
          name: "Property A",
          address: "Unit 101, Block A, 123 Sample Street, Sample City, SC 12345",
          sqft: 850,
        });
        console.log(`âœ“ Created sample Property A for organization ${organization.id}`);

        // Create sample tenant user "Joe Bloggs" with unique timestamp suffix
        const tenantPassword = await hashPassword("password123");
        const joeBloggs = await storage.createUser({
          email: `joe.bloggs+${uniqueSuffix}@inspect360.demo`,
          username: `joe_bloggs_${uniqueSuffix}`,
          password: tenantPassword,
          firstName: "Joe",
          lastName: "Bloggs",
          role: "tenant",
          organizationId: organization.id,
          isActive: true,
        });
        console.log(`âœ“ Created sample tenant Joe Bloggs (${joeBloggs.email}) for organization ${organization.id}`);

        // Create contact record for Joe Bloggs
        await storage.createContact({
          organizationId: organization.id,
          type: 'tenant',
          firstName: "Joe",
          lastName: "Bloggs",
          email: `joe.bloggs+${uniqueSuffix}@inspect360.demo`,
          phone: "+44 7700 900123",
          linkedUserId: joeBloggs.id,
          notes: "Sample tenant contact created automatically for demonstration purposes",
        });
        console.log(`âœ“ Created contact record for Joe Bloggs`);

        // Create tenant assignment linking Joe Bloggs to Property A
        const tenantAssignment = await storage.createTenantAssignment({
          organizationId: organization.id,
          propertyId: propertyA.id,
          tenantId: joeBloggs.id,
          leaseStartDate: new Date(),
          leaseEndDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 year from now
          monthlyRent: "1200.00",
          depositAmount: "1200.00",
          isActive: true,
          notes: "Sample tenant assignment created for demonstration purposes",
        });
        console.log(`âœ“ Created tenant assignment for Joe Bloggs in Property A`);
        console.log(`âœ“ Sample data setup complete - Block A, Property A, and tenant Joe Bloggs created successfully`);
      } catch (sampleDataError) {
        // Log detailed error for debugging but don't fail the organization creation
        console.error("Warning: Failed to create sample data (organization was still created successfully):", {
          error: sampleDataError instanceof Error ? sampleDataError.message : String(sampleDataError),
          organizationId: organization.id,
        });
      }

      res.json(organization);
    } catch (error) {
      console.error("Error creating organization:", error);
      res.status(500).json({ message: "Failed to create organization" });
    }
  });

  app.get("/api/organizations/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const organizationId = req.params.id;

      const user = await storage.getUser(userId);
      if (!user?.organizationId || user.organizationId !== organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const organization = await storage.getOrganization(organizationId);
      if (!organization) {
        return res.status(404).json({ message: "Organization not found" });
      }

      // Get credit balance from batch system (not legacy creditsRemaining)
      const creditBalance = await storage.getCreditBalance(organizationId);
      
      // Return organization with credit balance from batch system
      const orgResponse: any = { ...organization };
      // Remove legacy creditsRemaining if it exists
      delete orgResponse.creditsRemaining;
      // Add credit balance from batch system
      orgResponse.creditBalance = {
        total: creditBalance.total,
        current: creditBalance.current,
        rolled: creditBalance.rolled,
        expiresOn: creditBalance.expiresOn,
      };
      
      res.json(orgResponse);
    } catch (error) {
      console.error("Error fetching organization:", error);
      res.status(500).json({ message: "Failed to fetch organization" });
    }
  });

  // Update organization branding (white-label settings)
  app.patch("/api/organizations/:id/branding", isAuthenticated, requireRole("owner"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const organizationId = req.params.id;

      const user = await storage.getUser(userId);
      if (!user?.organizationId || user.organizationId !== organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { logoUrl, trademarkUrl, brandingName, brandingEmail, brandingPhone, brandingAddress, brandingWebsite, financeEmail, comparisonAlertThreshold } = req.body;

      const organization = await storage.updateOrganization(organizationId, {
        logoUrl: logoUrl || null,
        trademarkUrl: trademarkUrl || null,
        brandingName: brandingName || null,
        brandingEmail: brandingEmail || null,
        brandingPhone: brandingPhone || null,
        brandingAddress: brandingAddress || null,
        brandingWebsite: brandingWebsite || null,
        financeEmail: financeEmail || null,
        comparisonAlertThreshold: typeof comparisonAlertThreshold === 'number' ? comparisonAlertThreshold : undefined,
      });

      res.json(organization);
    } catch (error) {
      console.error("Error updating organization branding:", error);
      res.status(500).json({ message: "Failed to update organization branding" });
    }
  });

  // Update tenant portal configuration
  app.patch("/api/organizations/:id/tenant-portal-config", isAuthenticated, requireRole("owner"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const organizationId = req.params.id;

      const user = await storage.getUser(userId);
      if (!user?.organizationId || user.organizationId !== organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const {
        tenantPortalCommunityEnabled,
        tenantPortalComparisonEnabled,
        tenantPortalChatbotEnabled,
        tenantPortalMaintenanceEnabled,
        checkInApprovalPeriodDays
      } = req.body;

      const organization = await storage.updateOrganization(organizationId, {
        tenantPortalCommunityEnabled: typeof tenantPortalCommunityEnabled === 'boolean' ? tenantPortalCommunityEnabled : undefined,
        tenantPortalComparisonEnabled: typeof tenantPortalComparisonEnabled === 'boolean' ? tenantPortalComparisonEnabled : undefined,
        tenantPortalChatbotEnabled: typeof tenantPortalChatbotEnabled === 'boolean' ? tenantPortalChatbotEnabled : undefined,
        tenantPortalMaintenanceEnabled: typeof tenantPortalMaintenanceEnabled === 'boolean' ? tenantPortalMaintenanceEnabled : undefined,
        checkInApprovalPeriodDays: typeof checkInApprovalPeriodDays === 'number' ? checkInApprovalPeriodDays : undefined,
      });

      res.json(organization);
    } catch (error) {
      console.error("Error updating tenant portal configuration:", error);
      res.status(500).json({ message: "Failed to update tenant portal configuration" });
    }
  });

  // ==================== MARKETPLACE & PRICING ROUTES ====================

  app.get("/api/marketplace/modules", isAuthenticated, async (req: any, res) => {
    try {
      const organizationId = req.user.organizationId;
      if (!organizationId) {
        return res.status(400).json({ message: "Organization ID is required" });
      }

      const instanceSub = await storage.getInstanceSubscription(organizationId);
      const modules = await storage.getMarketplaceModules();
      let instanceModules: any[] = [];
      let instanceBundles: any[] = [];

      if (instanceSub) {
        instanceModules = await storage.getInstanceModules(instanceSub.id);
        instanceBundles = await storage.getInstanceBundles(instanceSub.id);
      }

      // Get instance subscription currency for pricing
      const currency = instanceSub?.registrationCurrency || "GBP";
      const billingCycle = instanceSub?.billingCycle || "monthly";

      const modulesWithStatus = await Promise.all(modules.map(async (m) => {
        const status = instanceModules.find(im => im.moduleId === m.id);
        const modulePricing = await storage.getModulePricing(m.id, currency);

        return {
          ...m,
          isEnabled: status?.isEnabled || false,
          enabledDate: status?.enabledDate,
          monthlyPrice: modulePricing?.priceMonthly || 0,
          annualPrice: modulePricing?.priceAnnual || 0,
          currentUsage: status?.currentUsage || 0,
          currency: currency
        };
      }));

      // Fetch bundles
      const bundles = await storage.getModuleBundles();
      const bundlesWithStatus = await Promise.all(bundles.map(async (b) => {
        const active = instanceBundles.find(ib => ib.bundleId === b.id);
        const bPricing = await storage.getBundlePricing(b.id, currency);
        const bModules = await storage.getBundleModules(b.id);

        return {
          ...b,
          isEnabled: !!active,
          monthlyPrice: bPricing?.priceMonthly || 0,
          annualPrice: bPricing?.priceAnnual || 0,
          currency: currency,
          modules: bModules.map(bm => bm.moduleId)
        };
      }));

      res.json({
        modules: modulesWithStatus,
        bundles: bundlesWithStatus,
        billingCycle,
        currency
      });
    } catch (error) {
      console.error("Error fetching marketplace modules:", error);
      res.status(500).json({ message: "Failed to fetch marketplace modules" });
    }
  });

  app.post("/api/marketplace/modules/:id/purchase", isAuthenticated, async (req: any, res) => {
    try {
      const organizationId = req.user.organizationId;
      const moduleId = req.params.id;
      const { billingCycle = "monthly", autoCredit = false } = req.body;

      if (!organizationId) {
        return res.status(400).json({ message: "Organization ID is required" });
      }

      const org = await storage.getOrganization(organizationId);
      if (!org) {
        return res.status(404).json({ message: "Organization not found" });
      }

      // Get or create instance subscription
      let instanceSub = await storage.getInstanceSubscription(organizationId);
      if (!instanceSub) {
        instanceSub = await storage.createInstanceSubscription({
          organizationId,
          registrationCurrency: org?.preferredCurrency || "GBP",
          inspectionQuotaIncluded: 0,
          billingCycle: "monthly",
          subscriptionStatus: "active"
        });
      }

      // Get module and pricing
      const modules = await storage.getMarketplaceModules();
      const module = modules.find(m => m.id === moduleId);
      if (!module) {
        return res.status(404).json({ message: "Module not found" });
      }

      if (!module.isAvailableGlobally) {
        return res.status(400).json({ message: "Module is not available" });
      }

      // Check if module is already enabled
      const instanceModules = await storage.getInstanceModules(instanceSub.id);
      const existingModule = instanceModules.find(im => im.moduleId === moduleId && im.isEnabled);
      if (existingModule) {
        // Check if module is covered by a bundle (in which case purchase might be for renewal)
        const { pricingService } = await import("./pricingService");
        const isInBundle = await pricingService.isModuleInActiveBundle(instanceSub.id, moduleId);
        
        if (isInBundle) {
          return res.status(400).json({ 
            message: "Module is already active as part of a bundle",
            details: {
              moduleId: moduleId,
              moduleName: module.name,
              suggestion: "This module is already enabled as part of an active bundle. Bundle pricing covers this module."
            }
          });
        } else {
          return res.status(400).json({ 
            message: "Module is already enabled",
            details: {
              moduleId: moduleId,
              moduleName: module.name,
              suggestion: "This module is already active. If you need to update your subscription, please contact support."
            }
          });
        }
      }

      // Get currency from subscription or organization, fallback to GBP
      const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
      const modulePricing = await storage.getModulePricing(moduleId, currency);
      if (!modulePricing) {
        return res.status(400).json({ message: "Module pricing not configured" });
      }

      const fullPrice = billingCycle === "annual" ? modulePricing.priceAnnual : modulePricing.priceMonthly;

      // Import pro-rata service
      const { calculateProRataWithPriority } = await import("./proRataService");
      
      // Create Stripe checkout session
      const { getUncachableStripeClient } = await import("./stripeClient");
      const stripe = await getUncachableStripeClient();

      // Check for existing subscriptions to support pro-rata
      // IMPORTANT: Always prioritize instanceSubscriptions.subscriptionRenewalDate as source of truth
      // This ensures proration uses the CURRENT subscription state (after tier changes, etc.)
      // Only fall back to legacy subscription if instanceSubscriptions doesn't have the data
      let finalPrice = fullPrice;
      let proRataResult = null;
      let isProrated = false;

      // Use shared function that consistently prioritizes instanceSubscriptions dates
      const proRataData = await calculateProRataWithPriority(
          fullPrice,
        organizationId,
        billingCycle,
        storage
        );
        
      // Get tier subscription renewal date to align module billing cycle
      let tierRenewalDate: Date | null = null;
      if (instanceSub?.subscriptionRenewalDate && instanceSub?.billingCycle === billingCycle) {
        tierRenewalDate = typeof instanceSub.subscriptionRenewalDate === 'string' 
          ? new Date(instanceSub.subscriptionRenewalDate)
          : instanceSub.subscriptionRenewalDate;
      } else {
        // Fallback to legacy subscription
        const legacySub = await storage.getSubscriptionByOrganization(organizationId);
        if (legacySub?.currentPeriodEnd && legacySub.billingInterval === billingCycle) {
          tierRenewalDate = typeof legacySub.currentPeriodEnd === 'string'
            ? new Date(legacySub.currentPeriodEnd)
            : legacySub.currentPeriodEnd;
        }
      }
        
      if (proRataData && proRataData.result.isProrated) {
        proRataResult = proRataData.result;
          finalPrice = proRataResult.proratedPrice;
          isProrated = true;
        const renewalDate = proRataData.source === "instanceSubscriptions" 
          ? instanceSub.subscriptionRenewalDate 
          : (await storage.getSubscriptionByOrganization(organizationId))?.currentPeriodEnd;
        console.log(`[Pro-Rata] Module ${module.name}: Using ${proRataData.source} dates - Charging ${finalPrice/100} ${currency} (prorated) instead of ${fullPrice/100} ${currency} for ${proRataResult.remainingDays} remaining days${renewalDate ? ` (renewal: ${renewalDate.toISOString()})` : ''}`);
      }

      // Build description with pro-rata info if applicable
      let description = module.description || `Subscribe to ${module.name} module`;
      if (isProrated && proRataResult) {
        description += ` (Pro-rated for ${proRataResult.remainingDays} remaining days in current billing cycle)`;
      }

      const checkoutSession = await stripe.checkout.sessions.create({
        customer: org.stripeCustomerId || undefined,
        payment_method_types: ["card"],
        line_items: [
          {
            price_data: {
              currency: currency.toLowerCase(),
              product_data: {
                name: module.name,
                description: description,
              },
              unit_amount: finalPrice, // Use prorated price if applicable
              recurring: {
                interval: billingCycle === "annual" ? "year" : "month"
              },
            },
            quantity: 1,
          },
        ],
        mode: "subscription",
        success_url: `${req.headers.origin || "http://localhost:5000"}/marketplace?payment=success&session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${req.headers.origin || "http://localhost:5000"}/marketplace?payment=cancelled`,
        client_reference_id: organizationId,
        metadata: {
          organizationId,
          moduleId,
          type: "module_purchase",
          billingCycle,
          fullPrice: fullPrice.toString(),
          proratedPrice: finalPrice.toString(),
          isProrated: isProrated.toString(),
          remainingDays: proRataResult?.remainingDays?.toString() || "0",
          tierRenewalDate: tierRenewalDate ? tierRenewalDate.toISOString() : ""
        },
      });

      res.json({ url: checkoutSession.url });
    } catch (error: any) {
      console.error("Error creating module purchase checkout:", error);
      res.status(500).json({ message: "Failed to create checkout session", error: error.message });
    }
  });

  // Bundle purchase endpoint
  app.post("/api/marketplace/bundles/:id/purchase", isAuthenticated, async (req: any, res) => {
    try {
      const organizationId = req.user.organizationId;
      const bundleId = req.params.id;
      const { billingCycle = "monthly", autoCredit = false } = req.body;

      if (!organizationId) {
        return res.status(400).json({ message: "Organization ID is required" });
      }

      const org = await storage.getOrganization(organizationId);
      if (!org) {
        return res.status(404).json({ message: "Organization not found" });
      }

      // Get or create instance subscription
      let instanceSub = await storage.getInstanceSubscription(organizationId);
      if (!instanceSub) {
        instanceSub = await storage.createInstanceSubscription({
          organizationId,
          registrationCurrency: org?.preferredCurrency || "GBP",
          inspectionQuotaIncluded: 0,
          billingCycle: "monthly",
          subscriptionStatus: "active"
        });
      }

      // Get bundle and pricing
      const bundles = await storage.getModuleBundles();
      const bundle = bundles.find(b => b.id === bundleId);
      if (!bundle) {
        return res.status(404).json({ message: "Bundle not found" });
      }

      if (!bundle.isActive) {
        return res.status(400).json({ message: "Bundle is not available" });
      }

      // Check if bundle is already active
      const instanceBundles = await storage.getInstanceBundles(instanceSub.id);
      const existingBundle = instanceBundles.find(ib => ib.bundleId === bundleId && ib.isActive);
      if (existingBundle) {
        return res.status(400).json({ message: "Bundle is already active" });
      }

      // Validate: Check if any modules in the bundle are already purchased separately
      // This prevents customers from paying for modules twice
      const bundleModules = await storage.getBundleModules(bundleId);
      const instanceModules = await storage.getInstanceModules(instanceSub.id);
      
      // Get all modules covered by active bundles (to exclude from check)
      const { pricingService } = await import("./pricingService");
      const coveredModuleIds = await pricingService.getBundledModuleIds(instanceSub.id);
      
      // Find modules that are already purchased separately (not covered by another bundle)
      const alreadyPurchasedModules = bundleModules.filter(bm => {
        const instanceModule = instanceModules.find(im => im.moduleId === bm.moduleId && im.isEnabled);
        // Module is already purchased if:
        // 1. It's enabled in instance modules
        // 2. It's not covered by another active bundle
        // 3. It has a non-zero price (not already free from another bundle)
        if (instanceModule) {
          const isCoveredByBundle = coveredModuleIds.has(bm.moduleId);
          const hasPrice = (instanceModule.monthlyPrice && instanceModule.monthlyPrice > 0) ||
                          (instanceModule.annualPrice && instanceModule.annualPrice > 0);
          return !isCoveredByBundle && hasPrice;
        }
        return false;
      });

      if (alreadyPurchasedModules.length > 0) {
        const modules = await storage.getMarketplaceModules();
        const moduleNames = alreadyPurchasedModules.map(bm => {
          const module = modules.find(m => m.id === bm.moduleId);
          return module?.name || bm.moduleId;
        }).join(", ");

        // Calculate total credit for individual module purchases
        let totalCredit = 0;
        const moduleCredits: Array<{ moduleId: string; moduleName: string; credit: number }> = [];
        
        for (const bm of alreadyPurchasedModules) {
          const instanceModule = instanceModules.find(im => im.moduleId === bm.moduleId && im.isEnabled);
          if (instanceModule) {
            // Calculate prorated credit based on remaining days in billing cycle
            const { calculateProRataWithPriority } = await import("./proRataService");
            const modulePrice = instanceSub.billingCycle === "annual" 
              ? (instanceModule.annualPrice || 0)
              : (instanceModule.monthlyPrice || 0);
            
            if (modulePrice > 0 && instanceSub.subscriptionRenewalDate) {
              const proRataData = await calculateProRataWithPriority(
                modulePrice,
                organizationId,
                instanceSub.billingCycle,
                storage
              );
              
              if (proRataData && proRataData.result.isProrated) {
                const proratedCredit = proRataData.result.proratedPrice;
                totalCredit += proratedCredit;
                const module = modules.find(m => m.id === bm.moduleId);
                moduleCredits.push({
                  moduleId: bm.moduleId,
                  moduleName: module?.name || bm.moduleId,
                  credit: proratedCredit
                });
              }
            }
          }
        }

        // Offer automatic credit option
        const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
        
        // If autoCredit is enabled, process the credit and allow bundle purchase
        if (autoCredit && totalCredit > 0) {
          try {
            // Create Stripe credit note for the prorated module purchases
            if (org.stripeCustomerId) {
              const { getUncachableStripeClient } = await import("./stripeClient");
              const stripe = await getUncachableStripeClient();
              
              await stripe.invoiceItems.create({
                customer: org.stripeCustomerId,
                amount: -totalCredit, // Negative amount = credit
                currency: currency.toLowerCase(),
                description: `Credit for individual module purchases (${moduleNames}) - replaced by bundle`,
                metadata: {
                  organizationId: organizationId,
                  type: "module_to_bundle_credit",
                  bundleId: bundleId,
                  modules: alreadyPurchasedModules.map(bm => bm.moduleId).join(",")
                }
              });
              
              console.log(`[Bundle Purchase] Created credit of ${(totalCredit / 100).toFixed(2)} ${currency} for individual modules replaced by bundle ${bundleId}`);
            }
            
            // Disable individual modules (they'll be re-enabled by bundle purchase)
            const { instanceModules: instanceModulesTable } = await import("@shared/schema");
            const { db } = await import("./db");
            const { eq } = await import("drizzle-orm");
            
            for (const bm of alreadyPurchasedModules) {
              const instanceModule = instanceModules.find(im => im.moduleId === bm.moduleId);
              if (instanceModule) {
                await db.update(instanceModulesTable)
                  .set({ isEnabled: false })
                  .where(eq(instanceModulesTable.id, instanceModule.id));
              }
            }
            
            console.log(`[Bundle Purchase] Disabled ${alreadyPurchasedModules.length} individual modules to allow bundle purchase with auto-credit`);
          } catch (creditError: any) {
            console.error(`[Bundle Purchase] Failed to process auto-credit:`, creditError);
            return res.status(500).json({
              message: "Failed to process automatic credit",
              error: creditError.message,
              details: {
                suggestion: "Please contact support to arrange credit manually, or disable individual modules first."
              }
            });
          }
        } else {
          // Return error with credit option
          return res.status(400).json({ 
            message: "Some modules in this bundle are already purchased separately",
            details: {
              conflictingModules: alreadyPurchasedModules.map(bm => bm.moduleId),
              moduleNames: moduleNames,
              suggestion: "Please disable the individual modules first, or contact support for assistance with bundle pricing.",
              creditOption: totalCredit > 0 ? {
                available: true,
                totalCredit: totalCredit / 100, // Convert to major units
                currency: currency,
                moduleCredits: moduleCredits.map(mc => ({
                  moduleName: mc.moduleName,
                  credit: mc.credit / 100
                })),
                message: `We can automatically credit you ${(totalCredit / 100).toFixed(2)} ${currency} for the remaining value of your individual module purchases. Add 'autoCredit: true' to your request to proceed.`
              } : {
                available: false,
                message: "Contact support to arrange credit for your individual module purchases."
              }
            }
          });
        }
      }

      // Get currency from subscription or organization, fallback to GBP
      const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
      const bundlePricing = await storage.getBundlePricing(bundleId, currency);
      if (!bundlePricing) {
        return res.status(400).json({ message: "Bundle pricing not configured" });
      }

      const fullPrice = billingCycle === "annual" ? bundlePricing.priceAnnual : bundlePricing.priceMonthly;

      // Import pro-rata service
      const { calculateProRata } = await import("./proRataService");
      
      // Create Stripe checkout session
      const { getUncachableStripeClient } = await import("./stripeClient");
      const stripe = await getUncachableStripeClient();

      // Import pro-rata service
      const { calculateProRataWithPriority } = await import("./proRataService");
      
      // Check for existing subscriptions to support pro-rata
      // IMPORTANT: Always prioritize instanceSubscriptions.subscriptionRenewalDate as source of truth
      // This ensures proration uses the CURRENT subscription state (after tier changes, etc.)
      // Only fall back to legacy subscription if instanceSubscriptions doesn't have the data
      let finalPrice = fullPrice;
      let proRataResult = null;
      let isProrated = false;

      // Use shared function that consistently prioritizes instanceSubscriptions dates
      const proRataData = await calculateProRataWithPriority(
          fullPrice,
        organizationId,
        billingCycle,
        storage
        );
        
      if (proRataData && proRataData.result.isProrated) {
        proRataResult = proRataData.result;
          finalPrice = proRataResult.proratedPrice;
          isProrated = true;
        const renewalDate = proRataData.source === "instanceSubscriptions" 
          ? instanceSub.subscriptionRenewalDate 
          : (await storage.getSubscriptionByOrganization(organizationId))?.currentPeriodEnd;
        console.log(`[Pro-Rata] Bundle ${bundle.name}: Using ${proRataData.source} dates - Charging ${finalPrice/100} ${currency} (prorated) instead of ${fullPrice/100} ${currency} for ${proRataResult.remainingDays} remaining days${renewalDate ? ` (renewal: ${renewalDate.toISOString()})` : ''}`);
      }

      // Build description with pro-rata info if applicable
      let description = bundle.description || `Subscribe to ${bundle.name} bundle`;
      if (isProrated && proRataResult) {
        description += ` (Pro-rated for ${proRataResult.remainingDays} remaining days in current billing cycle)`;
      }

      const checkoutSession = await stripe.checkout.sessions.create({
        customer: org.stripeCustomerId || undefined,
        payment_method_types: ["card"],
        line_items: [
          {
              price_data: {
              currency: currency.toLowerCase(),
              product_data: {
                name: bundle.name,
                description: description,
              },
              unit_amount: finalPrice, // Use prorated price if applicable
              recurring: {
                interval: billingCycle === "annual" ? "year" : "month"
              },
            },
            quantity: 1,
          },
        ],
        mode: "subscription",
        success_url: `${req.headers.origin || "http://localhost:5000"}/marketplace?payment=success&session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${req.headers.origin || "http://localhost:5000"}/marketplace?payment=cancelled`,
        client_reference_id: organizationId,
        metadata: {
          organizationId,
          bundleId,
          type: "bundle_purchase",
          billingCycle,
          fullPrice: fullPrice.toString(),
          proratedPrice: finalPrice.toString(),
          isProrated: isProrated.toString(),
          remainingDays: proRataResult?.remainingDays?.toString() || "0"
        },
      });

      res.json({ url: checkoutSession.url });
    } catch (error: any) {
      console.error("Error creating bundle purchase checkout:", error);
      res.status(500).json({ message: "Failed to create checkout session", error: error.message });
    }
  });

  // Keep toggle endpoint for backward compatibility (used by admin)
  // Deactivate a bundle
  app.post("/api/marketplace/bundles/:id/deactivate", isAuthenticated, async (req: any, res) => {
    try {
      const organizationId = req.user.organizationId;
      const bundleId = req.params.id;
      const { immediate = false } = req.body; // If true, deactivate immediately; if false, at end of billing cycle

      if (!organizationId) {
        return res.status(400).json({ message: "Organization ID is required" });
      }

      const org = await storage.getOrganization(organizationId);
      if (!org) {
        return res.status(404).json({ message: "Organization not found" });
      }

      // Get instance subscription
      let instanceSub = await storage.getInstanceSubscription(organizationId);
      if (!instanceSub) {
        return res.status(404).json({ message: "Instance subscription not found" });
      }

      // Get active bundles
      const instanceBundles = await storage.getInstanceBundles(instanceSub.id);
      const activeBundle = instanceBundles.find(ib => ib.bundleId === bundleId && ib.isActive);
      
      if (!activeBundle) {
        return res.status(404).json({ 
          message: "Bundle not found or not active",
          details: {
            bundleId: bundleId,
            suggestion: "This bundle is not currently active for your organization."
          }
        });
      }

      // Get bundle details
      const bundles = await storage.getModuleBundles();
      const bundle = bundles.find(b => b.id === bundleId);
      if (!bundle) {
        return res.status(404).json({ message: "Bundle configuration not found" });
      }

      // Get bundle modules
      const bundleModules = await storage.getBundleModules(bundleId);
      if (bundleModules.length === 0) {
        return res.status(400).json({ message: "Bundle has no modules" });
      }

      // Import required modules
      const { instanceBundles: instanceBundlesTable, instanceModules: instanceModulesTable } = await import("@shared/schema");
      const { db } = await import("./db");
      const { eq, and } = await import("drizzle-orm");
      const { pricingService } = await import("./pricingService");
      const { calculateProRataWithPriority } = await import("./proRataService");

      // Get currency
      const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";

      // IMPORTANT: If bundle is in Stripe subscription, remove it
      // Bundles can be added as subscription line items or invoice items
      if (org.stripeCustomerId) {
        try {
          const { getUncachableStripeClient } = await import("./stripeClient");
          const stripe = await getUncachableStripeClient();
          
          // Get all active subscriptions for this organization
          const subscriptions = await stripe.subscriptions.list({
            customer: org.stripeCustomerId,
            status: "active",
            limit: 100
          });
          
          // Find and remove bundle from subscription line items
          for (const subscription of subscriptions.data) {
            const subscriptionItems = subscription.items.data;
            
            // Find line item that matches this bundle (by product name)
            for (const item of subscriptionItems) {
              const product = item.price?.product;
              const productName = (typeof product === 'object' && product && 'name' in product) 
                ? (product.name || '') 
                : (item.price?.nickname || '');
              
              // Check if this line item matches the bundle name
              if (productName && (productName === bundle.name || productName.includes(bundle.name))) {
                console.log(`[Bundle Deactivation] Removing bundle ${bundle.name} (${bundleId}) from subscription ${subscription.id}`);
                
                // Remove the subscription item
                await stripe.subscriptionItems.del(item.id);
                console.log(`[Bundle Deactivation] Successfully removed bundle ${bundle.name} from subscription ${subscription.id}`);
                
                // Update subscription metadata to remove bundle name if present
                const bundleNames = subscription.metadata?.bundleNames?.split(',').filter(Boolean) || [];
                const updatedBundleNames = bundleNames.filter(name => name.trim() !== bundle.name).join(',');
                
                if (bundleNames.length > 0) {
                  await stripe.subscriptions.update(subscription.id, {
                    metadata: {
                      ...subscription.metadata,
                      bundleNames: updatedBundleNames,
                      bundleCount: updatedBundleNames ? updatedBundleNames.split(',').length.toString() : "0"
                    }
                  });
                  console.log(`[Bundle Deactivation] Updated subscription metadata - removed ${bundle.name}`);
                }
                break; // Found and removed, no need to check other items
              }
            }
          }
          
          // Also check for pending invoice items for this bundle
          // These are invoice items that haven't been invoiced yet
          try {
            const pendingInvoiceItems = await stripe.invoiceItems.list({
              customer: org.stripeCustomerId,
              limit: 100
            });
            
            for (const invoiceItem of pendingInvoiceItems.data) {
              const itemBundleId = invoiceItem.metadata?.bundleId;
              const itemType = invoiceItem.metadata?.type;
              
              // If this invoice item is for this bundle and hasn't been invoiced, delete it
              if (itemBundleId === bundleId && (itemType === "bundle_renewal" || itemType === "bundle_purchase")) {
                console.log(`[Bundle Deactivation] Removing pending invoice item ${invoiceItem.id} for bundle ${bundle.name}`);
                await stripe.invoiceItems.del(invoiceItem.id);
                console.log(`[Bundle Deactivation] Successfully removed pending invoice item for bundle ${bundle.name}`);
              }
            }
          } catch (invoiceItemError: any) {
            console.warn(`[Bundle Deactivation] Error checking pending invoice items:`, invoiceItemError.message);
            // Continue with deactivation even if invoice item check fails
          }
        } catch (stripeError: any) {
          console.error(`[Bundle Deactivation] Failed to remove bundle from Stripe subscription:`, stripeError.message);
          // Don't fail the bundle deactivation if Stripe update fails - bundle is still deactivated in database
        }
      }

      // Use transaction to ensure atomicity: bundle deactivation + module pricing updates succeed or all fail
      await db.transaction(async (tx) => {
        // Deactivate bundle
        await tx.update(instanceBundlesTable)
          .set({
            isActive: false,
            endDate: new Date() // Record when bundle was deactivated
          })
          .where(and(
            eq(instanceBundlesTable.instanceId, instanceSub.id),
            eq(instanceBundlesTable.bundleId, bundleId),
            eq(instanceBundlesTable.isActive, true)
          ));

        // Revert module pricing to individual pricing (bundle no longer covers the cost)
        // Modules remain enabled - user can continue using them but will be charged individually
        for (const bm of bundleModules) {
          // Get current instance module
          const instanceModulesList = await storage.getInstanceModules(instanceSub.id);
          const instanceModule = instanceModulesList.find(im => im.moduleId === bm.moduleId);
          
          if (instanceModule && instanceModule.isEnabled) {
            // Get individual module pricing
            const modulePricing = await storage.getModulePricing(bm.moduleId, currency);
            
            if (modulePricing) {
              // Check if module is covered by another active bundle
              const isInOtherBundle = await pricingService.isModuleInActiveBundle(instanceSub.id, bm.moduleId);
              
              if (!isInOtherBundle) {
                // Revert to individual module pricing
                await tx.update(instanceModulesTable)
                  .set({
                    monthlyPrice: modulePricing.priceMonthly,
                    annualPrice: modulePricing.priceAnnual,
                    currencyCode: currency,
                    billingStartDate: new Date() // Reset billing start date
                  })
                  .where(eq(instanceModulesTable.id, instanceModule.id));
              } else {
                // Module is covered by another bundle, keep price at 0
                console.log(`[Bundle Deactivation] Module ${bm.moduleId} is covered by another bundle, keeping price at 0`);
              }
            } else {
              console.warn(`[Bundle Deactivation] Module pricing not found for module ${bm.moduleId} in currency ${currency}`);
            }
          }
        }
      });

      // Note: No refund is provided on bundle deactivation
      // Bundle is deactivated and modules revert to individual pricing
      // User continues to have access to modules but will be charged individually going forward

      // Return response
      res.json({
        success: true,
        bundleId: bundleId,
        bundleName: bundle.name,
        deactivated: true,
        immediate: immediate,
        message: immediate 
          ? `Bundle ${bundle.name} deactivated. Modules remain enabled but will now be charged at individual pricing.`
          : `Bundle ${bundle.name} will be deactivated at the end of your billing cycle.`,
        details: {
          modulesRemainEnabled: true,
          modulesRevertedToIndividualPricing: true,
          note: "Modules remain enabled but will now be charged at individual pricing. You can disable them separately if needed.",
          noRefund: "No refund is provided on bundle deactivation. You will continue to have access to modules but will be charged individually going forward."
        }
      });
    } catch (error: any) {
      console.error("Error deactivating bundle:", error);
      res.status(500).json({ 
        message: "Failed to deactivate bundle",
        error: error.message 
      });
    }
  });

  app.post("/api/marketplace/modules/:id/toggle", isAuthenticated, async (req: any, res) => {
    try {
      const organizationId = req.user.organizationId;
      const moduleId = req.params.id;
      const { enable, billingStartDate } = req.body;

      if (!organizationId) {
        return res.status(400).json({ message: "Organization ID is required" });
      }

      let instanceSub = await storage.getInstanceSubscription(organizationId);
      if (!instanceSub) {
        // Create a default instance subscription if it doesn't exist
        const org = (await storage.getOrganization(organizationId)) as any;
        instanceSub = await storage.createInstanceSubscription({
          organizationId,
          registrationCurrency: org?.preferredCurrency || "GBP",
          inspectionQuotaIncluded: org?.includedInspectionsPerMonth || 0,
          billingCycle: "monthly",
          subscriptionStatus: "active"
        });
      }

      // Prevent enabling modules if subscription is inactive
      if (enable && instanceSub.subscriptionStatus !== "active") {
        return res.status(403).json({ 
          message: "Cannot enable modules. Your subscription is inactive. Please subscribe to a plan to enable modules.",
          error: "subscription_inactive"
        });
      }

      // Get module details
      const modules = await storage.getMarketplaceModules();
      const module = modules.find(m => m.id === moduleId);
      if (!module) {
        return res.status(404).json({ message: "Module not found" });
      }

      // Get organization for Stripe customer ID
      const org = await storage.getOrganization(organizationId);
      if (!org) {
        return res.status(404).json({ message: "Organization not found" });
      }

      // Get current pricing
      // Get currency from subscription or organization, fallback to GBP
      const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
      const modulePricing = await storage.getModulePricing(moduleId, currency);
      
      // Calculate prorated charge if enabling mid-cycle
      let proratedCharge = null;
      let proratedChargeMinorUnits = 0; // Store in minor units for Stripe
      if (enable && modulePricing) {
        const { calculateProRataWithPriority } = await import("./proRataService");
        const fullPrice = instanceSub.billingCycle === "annual" ? modulePricing.priceAnnual : modulePricing.priceMonthly;
        
        // Use shared function that consistently prioritizes instanceSubscriptions dates
        const proRataData = await calculateProRataWithPriority(
          fullPrice,
          organizationId,
          instanceSub.billingCycle,
          storage
        );
        
        if (proRataData && proRataData.result.isProrated) {
          proratedChargeMinorUnits = proRataData.result.proratedPrice; // Keep in minor units (pence/cents)
          proratedCharge = proratedChargeMinorUnits / 100; // Convert to major units for response
          
          // Add prorated charge to Stripe as invoice item (will be included in next invoice)
          if (org.stripeCustomerId && proratedChargeMinorUnits > 0) {
            try {
              const stripe = await getUncachableStripeClient();
              await stripe.invoiceItems.create({
                customer: org.stripeCustomerId,
                amount: proratedChargeMinorUnits,
                currency: currency.toLowerCase(),
                description: `Prorated charge for ${module.name} (enabled mid-cycle)`,
                metadata: {
                  organizationId: organizationId,
                  moduleId: moduleId,
                  moduleName: module.name,
                  type: "prorated_module_enable",
                  billingCycle: instanceSub.billingCycle || "monthly"
                }
              });
              console.log(`[Module Toggle] Added prorated charge of ${proratedCharge.toFixed(2)} ${currency} to Stripe invoice for module ${module.name}`);
            } catch (stripeError: any) {
              console.error(`[Module Toggle] Failed to add prorated charge to Stripe:`, stripeError.message);
              // Don't fail the module enable if Stripe invoice item creation fails
              // The prorated charge is still calculated and returned in response
            }
          } else if (!org.stripeCustomerId) {
            console.warn(`[Module Toggle] Cannot add prorated charge to Stripe: organization ${organizationId} has no Stripe customer ID`);
          }
        }
      }

      // Validate: If disabling, check if module is part of an active bundle
      if (!enable) {
        const { pricingService } = await import("./pricingService");
        const isInBundle = await pricingService.isModuleInActiveBundle(instanceSub.id, moduleId);
        if (isInBundle) {
          const bundles = await storage.getModuleBundles();
          const activeBundles = await storage.getInstanceBundles(instanceSub.id);
          const bundle = bundles.find(b => {
            const instanceBundle = activeBundles.find(ib => ib.bundleId === b.id && ib.isActive);
            if (!instanceBundle) return false;
            // Check if this module is in this bundle
            return storage.getBundleModules(b.id).then(modules => 
              modules.some(bm => bm.moduleId === moduleId)
            );
          });
          
          // Note: We can't easily get bundle name here without async, so we'll use a generic message
          // The module can still be disabled, but the bundle will continue to cover its cost
          console.warn(`[Module Toggle] Attempting to disable module ${moduleId} which is part of an active bundle. Bundle will continue to cover the cost.`);
        }
      }

      // Validate: If disabling, check if module is part of an active bundle
      if (!enable) {
        const { pricingService } = await import("./pricingService");
        const isInBundle = await pricingService.isModuleInActiveBundle(instanceSub.id, moduleId);
        if (isInBundle) {
          // Module is in a bundle - warn but allow disabling
          // The bundle will continue to cover the cost, but module functionality will be disabled
          console.warn(`[Module Toggle] Disabling module ${moduleId} which is part of an active bundle. Bundle will continue to cover the cost.`);
        }
      }

      // IMPORTANT: If disabling, cancel the module's Stripe subscription
      // This prevents the module from being charged on renewal (cancels at end of billing period)
      if (!enable && org.stripeCustomerId) {
        try {
          const stripe = await getUncachableStripeClient();
          
          console.log(`[Module Toggle] ðŸ” Looking for module subscription to cancel for module: ${module.name} (${moduleId})`);
          console.log(`[Module Toggle] Customer ID: ${org.stripeCustomerId}`);
          
          // Get all active subscriptions with expanded product data
          // Note: Cannot expand more than 4 levels, so we'll fetch product data separately if needed
          const subscriptions = await stripe.subscriptions.list({
            customer: org.stripeCustomerId,
            status: "active",
            limit: 100,
            expand: ['data.items.data.price'] // Only expand to price level, fetch product separately
          });
          
          console.log(`[Module Toggle] Found ${subscriptions.data.length} active subscriptions to check`);
          
          let foundAndCanceled = false;
          
          // Find the module subscription by checking metadata AND product names
          for (const subscription of subscriptions.data) {
            const subMetadata = subscription.metadata || {};
            
            // Method 1: Check metadata
            const isModuleSubscriptionByMetadata = subMetadata.type === "module_purchase" && 
                                                  subMetadata.moduleId === moduleId;
            
            // Method 2: Check product names (fallback if metadata is missing)
            let isModuleSubscriptionByProductName = false;
            const items = subscription.items?.data || [];
            const foundProductNames: string[] = [];
            
            for (const item of items) {
              // Try multiple ways to get product name
              let productName = '';
              const product = item.price?.product;
              
              // Method 1: Get from product object (if expanded)
              if (typeof product === 'object' && product && 'name' in product) {
                productName = product.name || '';
              } else if (typeof product === 'string') {
                // Product is just an ID, need to fetch it separately
                try {
                  const productObj = await stripe.products.retrieve(product);
                  productName = productObj.name || '';
                } catch (e) {
                  // If fetch fails, continue with other methods
                  console.log(`[Module Toggle] Could not fetch product ${product}, trying other methods`);
                }
              }
              
              // Method 2: Get from price nickname
              if (!productName && item.price?.nickname) {
                productName = item.price.nickname;
              }
              
              if (productName) {
                foundProductNames.push(productName);
                const nameLower = productName.toLowerCase();
                const moduleNameLower = module.name.toLowerCase();
                
                // Match if product name exactly matches module name or contains it
                if (nameLower === moduleNameLower || nameLower.includes(moduleNameLower)) {
                  // Make sure it's NOT a tier subscription
                  const isTierSubscription = subMetadata.tierId || subMetadata.planCode || 
                                           (subMetadata.type === "tier_subscription") ||
                                           (nameLower.includes('inspect360') && nameLower.includes('plan'));
                  
                  if (!isTierSubscription) {
                    isModuleSubscriptionByProductName = true;
                    console.log(`[Module Toggle] âœ… Matched module subscription by product name: "${productName}"`);
                    break;
                  }
                }
              }
            }
            
            const isModuleSubscription = isModuleSubscriptionByMetadata || isModuleSubscriptionByProductName;
            
            // Log what we found
            console.log(`[Module Toggle] ðŸ“‹ Checking subscription ${subscription.id}:`);
            console.log(`   - Metadata: ${JSON.stringify(subMetadata)}`);
            console.log(`   - Products: [${foundProductNames.join(', ')}]`);
            console.log(`   - Matched by metadata: ${isModuleSubscriptionByMetadata}`);
            console.log(`   - Matched by product name: ${isModuleSubscriptionByProductName}`);
            console.log(`   - Is module subscription: ${isModuleSubscription}`);
            
            if (isModuleSubscription) {
              console.log(`[Module Toggle] ðŸš« CANCELLING module subscription ${subscription.id} for module ${module.name} (${moduleId})`);
              
              try {
                // Cancel at the end of the billing period (like White Labelling)
                // This allows the user to continue using the module until the period ends
                const updatedSubscription = await stripe.subscriptions.update(subscription.id, {
                  cancel_at_period_end: true
                });
                
                // Get the period end date for logging
                const periodEnd = new Date((updatedSubscription.current_period_end as number) * 1000);
                const periodEndFormatted = periodEnd.toLocaleDateString('en-US', { 
                  month: 'short', 
                  day: 'numeric',
                  year: 'numeric'
                });
                
                console.log(`[Module Toggle] âœ… Successfully scheduled cancellation of module subscription ${subscription.id}`);
                console.log(`[Module Toggle]    Module: ${module.name}`);
                console.log(`[Module Toggle]    Cancellation date: ${periodEndFormatted}`);
                console.log(`[Module Toggle]    Cancel at period end: ${updatedSubscription.cancel_at_period_end}`);
                
                foundAndCanceled = true;
                break; // Found and canceled, no need to check other subscriptions
              } catch (cancelError: any) {
                console.error(`[Module Toggle] âŒ Failed to cancel subscription ${subscription.id}:`, cancelError.message);
                console.error(`[Module Toggle]    Error type: ${cancelError.type}`);
                console.error(`[Module Toggle]    Error code: ${cancelError.code}`);
                console.error(`[Module Toggle]    Full error:`, JSON.stringify(cancelError, null, 2));
                // Continue checking other subscriptions even if this one fails
              }
            }
          }
          
          if (!foundAndCanceled) {
            console.warn(`[Module Toggle] âš ï¸  No module subscription found to cancel for module ${module.name} (${moduleId})`);
            console.warn(`[Module Toggle]    This might be normal if the module was purchased as part of a bundle or if the subscription doesn't exist.`);
          }
          
        } catch (stripeError: any) {
          console.error(`[Module Toggle] âŒ Failed to cancel module subscription:`, stripeError.message);
          console.error(`[Module Toggle]    Error type: ${stripeError.type}`);
          console.error(`[Module Toggle]    Error code: ${stripeError.code}`);
          console.error(`[Module Toggle]    Full error:`, JSON.stringify(stripeError, null, 2));
          // Don't fail the module disable if Stripe update fails - module is still disabled in database
        }
      }

      // Toggle module
      const updatedModule = await storage.toggleInstanceModule(instanceSub.id, moduleId, enable);
      
      // Update pricing info if enabling
      // Note: If module is in a bundle, pricing should remain 0 (bundle covers the cost)
      if (enable && modulePricing) {
        const { pricingService } = await import("./pricingService");
        const isInBundle = await pricingService.isModuleInActiveBundle(instanceSub.id, moduleId);
        
        const { instanceModules } = await import("@shared/schema");
        const { db } = await import("./db");
        const { eq } = await import("drizzle-orm");
        
        await db.update(instanceModules)
          .set({
            // If module is in bundle, keep price at 0 (bundle covers cost)
            // Otherwise, set to module pricing
            monthlyPrice: isInBundle ? 0 : modulePricing.priceMonthly,
            annualPrice: isInBundle ? 0 : modulePricing.priceAnnual,
            currencyCode: currency,
            billingStartDate: billingStartDate ? new Date(billingStartDate) : new Date()
          })
          .where(eq(instanceModules.id, updatedModule.id));
      }

      // Return response in format matching specification
      res.json({
        success: true,
        module_id: moduleId,
        module_name: module.name,
        enabled: enable,
        billing_start_date: billingStartDate || (enable ? new Date().toISOString() : null),
        prorated_charge: proratedCharge,
        message: enable 
          ? (proratedCharge 
              ? `${module.name} enabled. Prorated charge of ${currency} ${proratedCharge.toFixed(2)} will be added to next invoice.`
              : `${module.name} enabled.`)
          : `${module.name} disabled.`
      });
    } catch (error: any) {
      console.error("Error toggling marketplace module:", error);
      res.status(500).json({ message: "Failed to update module status", error: error.message });
    }
  });

  app.get("/api/pricing/calculate", isAuthenticated, async (req: any, res) => {
    try {
      const { inspections, currency } = req.query;
      const organizationId = req.user.organizationId;

      // Get organization to determine default currency
      let defaultCurrency = "GBP";
      if (organizationId) {
        const org = await storage.getOrganization(organizationId);
        if (org?.preferredCurrency) {
          defaultCurrency = org.preferredCurrency;
        }
      }

      // Use provided currency or organization's preferred currency
      const targetCurrency = (currency as string) || defaultCurrency;

      const pricing = await pricingService.calculatePricing(
        Number(inspections) || 0,
        targetCurrency,
        organizationId
      );

      res.json(pricing);
    } catch (error) {
      console.error("Error calculating pricing:", error);
      res.status(500).json({ message: "Failed to calculate pricing" });
    }
  });

  app.get("/api/pricing/config", isUserOrAdmin, async (req: any, res) => {
    try {
      const { subscriptionTiersTable, tierPricing } = await import("@shared/schema");
      // Get all tiers (including inactive ones for admin view, but filter for operator)
      const allTiers = await db.select().from(subscriptionTiersTable).orderBy(subscriptionTiersTable.tierOrder);
      const currencies = await storage.getCurrencyConfig();
      // Include tier pricing (with per-inspection price) for admin-managed rates
      const allTierPricing = await db.select().from(tierPricing);
      
      // Filter active tiers for operator view (if not admin)
      const isAdmin = (req.session as any)?.adminUser;
      const tiers = isAdmin ? allTiers : allTiers.filter(t => t.isActive !== false);
      
      res.json({ tiers, currencies, tierPricing: allTierPricing });
    } catch (error) {
      console.error("Error fetching pricing config:", error);
      res.status(500).json({ message: "Failed to fetch pricing configuration" });
    }
  });

  // ==================== BILLING & SUBSCRIPTION ROUTES ====================

  app.get("/api/billing/plans", isAuthenticated, async (req: any, res) => {
    try {
      const tiers = await storage.getSubscriptionTiers();
      res.json(tiers);
    } catch (error) {
      console.error("Error fetching plans:", error);
      res.status(500).json({ message: "Failed to fetch plans" });
    }
  });

  app.get("/api/billing/subscription", isAuthenticated, async (req: any, res) => {
    try {
      const organizationId = req.user.organizationId;
      const sub = await storage.getInstanceSubscription(organizationId);
      if (!sub) {
        return res.json(null);
      }

      // Add plan name for UI compatibility
      const tier = sub.currentTierId ? (await storage.getSubscriptionTiers()).find(t => t.id === sub.currentTierId) : null;

      res.json({
        ...sub,
        planSnapshotJson: {
          planName: tier?.name || "Custom Plan",
          monthlyPrice: sub.overrideMonthlyFee || (tier?.basePriceMonthly ?? 0),
          includedCredits: sub.inspectionQuotaIncluded,
          currency: sub.registrationCurrency
        },
        currentPeriodStart: sub.subscriptionStartDate,
        currentPeriodEnd: sub.subscriptionRenewalDate || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        status: sub.subscriptionStatus,
        cancelAtPeriodEnd: false
      });
    } catch (error) {
      console.error("Error fetching subscription:", error);
      res.status(500).json({ message: "Failed to fetch subscription" });
    }
  });

  app.get("/api/billing/inspection-balance", isAuthenticated, async (req: any, res) => {
    try {
      const organizationId = req.user.organizationId;
      
      // Get credit balance first (includes signup rewards, topups, plan credits, etc.)
      // This is the source of truth for all available credits
      const creditBalance = await storage.getCreditBalance(organizationId);
      
      const sub = await storage.getInstanceSubscription(organizationId);

      if (!sub) {
        // User has no subscription, but may have signup reward credits
        return res.json({
          total: creditBalance.total, // Main field used by frontend - total available credits from batches
          current: creditBalance.current,
          rolled: creditBalance.rolled,
          expiresOn: creditBalance.expiresOn,
          tierQuotaIncluded: 0,
          tierQuotaUsed: 0,
          tierQuotaRemaining: 0,
          addonCreditsPurchased: 0,
          addonCreditsUsed: 0,
          addonCreditsRemaining: 0,
          totalAvailable: creditBalance.total, // Include signup reward credits
          totalUsed: 0
        });
      }

      // Get tier quota info
      const tierQuotaIncluded = sub.inspectionQuotaIncluded || 0;
      
      // Get addon purchases (these are tracked separately in instance_addon_purchases)
      const addonPurchases = await storage.getInstanceAddonPurchases(sub.id);
      const activeAddonPurchases = addonPurchases.filter(p => p.status === "active");
      const addonCreditsPurchased = activeAddonPurchases.reduce((sum, p) => sum + (p.inspectionsRemaining || p.quantity), 0);
      const addonCreditsUsed = activeAddonPurchases.reduce((sum, p) => sum + (p.inspectionsUsed || 0), 0);
      const addonCreditsRemaining = addonCreditsPurchased - addonCreditsUsed;

      // Calculate tier quota usage (for display purposes)
      // The credit balance includes all credits (signup, plan, topup, addon)
      // We estimate tier quota usage by comparing total credits to tier quota
      let tierQuotaUsed = 0;
      let tierQuotaRemaining = 0;
      
      if (tierQuotaIncluded > 0) {
        // If we have more credits than tier quota, assume tier quota is fully available
        // If we have less, assume the difference was used
        const creditsFromBatches = creditBalance.total - addonCreditsRemaining;
        if (creditsFromBatches >= tierQuotaIncluded) {
          tierQuotaRemaining = tierQuotaIncluded;
          tierQuotaUsed = 0;
        } else {
          tierQuotaRemaining = Math.max(0, creditsFromBatches);
          tierQuotaUsed = tierQuotaIncluded - tierQuotaRemaining;
        }
      }

      // Total available = all credits from credit batches (includes signup rewards!)
      // The creditBalance.total already includes all types: signup rewards, plan credits, topups, etc.
      const totalAvailable = creditBalance.total;
      const totalUsed = tierQuotaUsed + addonCreditsUsed;

      // Check and send quota alerts
      const usagePercent = tierQuotaIncluded > 0 ? (totalUsed / tierQuotaIncluded) * 100 : 0;
      if (usagePercent >= 80) {
        const { notificationService } = await import("./notificationService");
        notificationService.checkAndSendQuotaAlerts(organizationId).catch(err => 
          console.error("Error sending quota alerts:", err)
        );
      }

      // Return credit balance in format expected by frontend
      res.json({
        total: creditBalance.total, // Main field used by frontend - total available credits from batches
        current: creditBalance.current,
        rolled: creditBalance.rolled,
        expiresOn: creditBalance.expiresOn,
        // Additional breakdown for billing page
        tierQuotaIncluded,
        tierQuotaUsed,
        tierQuotaRemaining,
        addonCreditsPurchased,
        addonCreditsUsed,
        addonCreditsRemaining,
        totalAvailable,
        totalUsed,
        usagePercent: Math.round(usagePercent),
        preferredCurrency: sub.registrationCurrency || 'GBP'
      });
    } catch (error) {
      console.error("Error fetching inspection balance:", error);
      res.status(500).json({ message: "Failed to fetch balance" });
    }
  });

  app.post("/api/billing/checkout", isAuthenticated, async (req: any, res) => {
    try {
      const { planCode, billingPeriod, currency, inspectionCount, totalPrice, tierPrice, additionalCost, moduleCost } = req.body;
      const organizationId = req.user.organizationId;
      const user = await storage.getUser(req.user.id);
      const org = await storage.getOrganization(organizationId);

      if (!org) {
        return res.status(404).json({ message: "Organization not found" });
      }

      // Use pricing service to get tier information
      const pricingResult = await pricingService.calculatePricing(
        Number(inspectionCount) || 50,
        currency || "GBP",
        organizationId
      );

      const selectedTier = pricingResult.tier;
      
      // Calculate tier price (excluding modules, as modules will be separate line items)
      let tierAmount: number;
      if (tierPrice !== undefined && tierPrice !== null) {
        // Frontend sends tier price in minor units (pence/cents), excluding modules
        tierAmount = Number(tierPrice);
        console.log(`[Billing] Using frontend tier price: ${tierAmount} ${currency} (minor units)`);
        console.log(`[Billing] Breakdown - Tier: ${tierPrice}, Additional: ${additionalCost}, Modules: ${moduleCost}`);
      } else if (totalPrice !== undefined && totalPrice !== null && moduleCost !== undefined && moduleCost !== null) {
        // If only total price is provided, subtract module cost to get tier price
        tierAmount = Number(totalPrice) - Number(moduleCost);
        console.log(`[Billing] Calculated tier price from total: ${tierAmount} ${currency} (Total: ${totalPrice} - Modules: ${moduleCost})`);
      } else {
        // Fallback to pricing service calculation (tier only, no modules)
        tierAmount = billingPeriod === "annual" ? pricingResult.calculations.baseAnnual : pricingResult.calculations.baseMonthly;
        console.log(`[Billing] Using pricing service calculated tier price: ${tierAmount} ${currency}`);
      }

      const stripe = await getUncachableStripeClient();
      const baseUrl = getBaseUrl(req);

      // Check if subscription already exists - if so, we should update it instead of creating new
      const existingInstanceSub = await storage.getInstanceSubscription(organizationId);
      let existingStripeSubscription = null;
      
      if (existingInstanceSub && org.stripeCustomerId) {
        try {
          // Check for existing active Stripe subscriptions
          const subscriptions = await stripe.subscriptions.list({
            customer: org.stripeCustomerId,
            status: "active",
            limit: 100
          });
          
          // Find subscription with matching tier (if any)
          for (const sub of subscriptions.data) {
            const subTierId = sub.metadata?.tierId;
            if (subTierId === selectedTier.id) {
              existingStripeSubscription = sub;
              console.log(`[Billing Checkout] Found existing subscription ${sub.id} for tier ${selectedTier.id} - will update instead of creating new`);
              break;
            }
          }
        } catch (listError: any) {
          console.warn(`[Billing Checkout] Error checking for existing subscriptions:`, listError.message);
          // Continue with new subscription creation if check fails
        }
      }

      console.log(`[Billing] ${existingStripeSubscription ? 'Updating' : 'Creating'} Stripe ${existingStripeSubscription ? 'subscription' : 'session'} for ${selectedTier.code} (${billingPeriod}) with ${inspectionCount} inspections at ${tierAmount} ${currency}`);

      // Calculate total inspections: tier included + additional
      const totalInspections = Number(inspectionCount) || selectedTier.included_inspections;
      const tierIncluded = selectedTier.included_inspections || 0;
      const additionalInspections = Math.max(0, totalInspections - tierIncluded);
      
      console.log(`[Billing] Checkout - Total inspections: ${totalInspections}, Tier included: ${tierIncluded}, Additional: ${additionalInspections}`);
      
      // IMPORTANT: When subscribing to a tier, DO NOT include modules in checkout
      // Modules are separate subscriptions and should be purchased/managed separately
      // Modules that are already active should remain active and not be charged again
      const instanceSub = existingInstanceSub || await storage.getInstanceSubscription(organizationId);
      let moduleLineItems: any[] = [];
      let totalProratedCredit = 0;
      const moduleNames: string[] = [];
      const moduleCredits: Array<{ moduleId: string; moduleName: string; credit: number }> = [];
      
      // DO NOT add modules to tier checkout - modules are separate subscriptions
      // Modules should be purchased separately through the marketplace
      // This prevents double-charging for modules that are already active
      console.log(`[Billing Checkout] Tier subscription checkout - modules will NOT be included (modules are separate subscriptions)`);
      
      // The code below is commented out to prevent modules from being added to tier checkout
      // Modules should be purchased/managed separately through the marketplace
      /*
      if (instanceSub) {
        const instanceModules = await storage.getInstanceModules(instanceSub.id);
        const enabledModules = instanceModules.filter(m => m.isEnabled);
        
        // Get modules covered by bundles (these should not be charged separately)
        const { pricingService } = await import("./pricingService");
        const coveredModuleIds = await pricingService.getBundledModuleIds(instanceSub.id);
        
        // Filter out modules covered by bundles
        // Filter out modules that have separate subscriptions
        const modulesToCharge = enabledModules.filter(im => 
          !coveredModuleIds.has(im.moduleId) && 
          !modulesWithSeparateSubscriptions.has(im.moduleId)
        );
        
        // Get module details and calculate prorated credits
        const modules = await storage.getMarketplaceModules();
        const { calculateProRataWithPriority } = await import("./proRataService");
        const billingCycle = billingPeriod === "annual" ? "annual" : "monthly";
        const orgCurrency = currency || "GBP";
        
        // If updating existing subscription, also handle modules that are in subscription but disabled
        // These should be removed from subscription
        if (existingStripeSubscription) {
          const subscriptionItems = existingStripeSubscription.items?.data || [];
          for (const item of subscriptionItems) {
            const product = item.price?.product;
            const productName = (typeof product === 'object' && product && 'name' in product) 
              ? (product.name || '') 
              : (item.price?.nickname || '');
            
            // Check if this line item is a module (not the tier subscription)
            if (productName && !productName.includes(selectedTier.name) && !productName.includes('Plan')) {
              const matchedModule = modules.find(m => 
                m.name === productName.trim() || productName.includes(m.name)
              );
              
              if (matchedModule) {
                const instanceModule = enabledModules.find(im => im.moduleId === matchedModule.id);
                // If module is disabled or not in enabled modules, it should be removed
                if (!instanceModule || !instanceModule.isEnabled) {
                  console.log(`[Billing Checkout] Module ${matchedModule.name} is in subscription but disabled - will be removed on update`);
                  // Note: This will be handled when we update the subscription
                }
              }
            }
          }
        }
        
        for (const instanceModule of modulesToCharge) {
          const module = modules.find(m => m.id === instanceModule.moduleId);
          if (!module) continue;
          
          const modulePrice = billingCycle === "annual" 
            ? (instanceModule.annualPrice || 0)
            : (instanceModule.monthlyPrice || 0);
          
          if (modulePrice > 0) {
            // Calculate prorated credit for already-paid portion
            // IMPORTANT: Use the billing cycle from the request, not from instanceSub, as user may be changing billing period
            let moduleCredit = 0;
            if (instanceSub.subscriptionRenewalDate) {
              // Use the billing cycle from the request (billingPeriod) for proration calculation
              const proRataData = await calculateProRataWithPriority(
                modulePrice,
                organizationId,
                billingCycle, // Use billingCycle from request, not instanceSub.billingCycle
                storage
              );
              
              if (proRataData && proRataData.result.isProrated) {
                moduleCredit = proRataData.result.proratedPrice;
                totalProratedCredit += moduleCredit;
                moduleCredits.push({
                  moduleId: instanceModule.moduleId,
                  moduleName: module.name,
                  credit: moduleCredit
                });
                console.log(`[Billing Checkout] Module ${module.name}: Prorated credit of ${(moduleCredit / 100).toFixed(2)} ${orgCurrency} applied (${proRataData.result.remainingDays} days remaining)`);
              } else {
                console.log(`[Billing Checkout] Module ${module.name}: No proration applied (not prorated or renewal date missing)`);
              }
            } else {
              console.log(`[Billing Checkout] Module ${module.name}: No proration applied (no renewal date)`);
            }
            
            // Add module as line item with NET price (full price - prorated credit)
            const moduleNetPrice = Math.max(0, modulePrice - moduleCredit);
            
            moduleLineItems.push({
              price_data: {
                currency: orgCurrency.toLowerCase(),
                product_data: {
                  name: module.name,
                  description: `${module.name} module (${billingPeriod} billing)${moduleCredit > 0 ? ` - Prorated credit: ${orgCurrency} ${(moduleCredit / 100).toFixed(2)} applied` : ''}`
                },
                recurring: {
                  interval: billingPeriod === "annual" ? "year" : "month"
                },
                unit_amount: moduleNetPrice
              },
              quantity: 1
            });
            
            moduleNames.push(module.name);
          }
        }
        
        if (totalProratedCredit > 0) {
          console.log(`[Billing Checkout] Applied prorated credits totaling ${(totalProratedCredit / 100).toFixed(2)} ${orgCurrency} to module prices`);
        }
      }
      */
      
      // Build description
      let description = `${totalInspections} inspections per month`;
      if (additionalInspections > 0) {
        description += ` (${tierIncluded} included in ${selectedTier.name} tier + ${additionalInspections} additional)`;
      } else {
        description += ` (${billingPeriod} billing)`;
      }

      // Note: Modules are NOT included in tier checkout - they are separate subscriptions
      // Modules should be purchased/managed separately through the marketplace

      // Build line items: tier + additional inspections (if any) + modules (with prorated credits already applied)
      const lineItems: any[] = [
          {
            price_data: {
              currency: (currency || "GBP").toLowerCase(),
              product_data: {
              name: `Inspect360 ${selectedTier.name} Plan`,
              },
            unit_amount: tierAmount,
              recurring: {
                interval: billingPeriod === "annual" ? "year" : "month",
              },
            },
            quantity: 1,
          },
      ];

      // Add additional inspections as a separate line item if there are any
      if (additionalInspections > 0 && additionalCost !== undefined && additionalCost !== null && Number(additionalCost) > 0) {
        const additionalCostAmount = Number(additionalCost);
        console.log(`[Billing Checkout] Adding ${additionalInspections} additional inspections as separate line item: ${additionalCostAmount} ${currency} (minor units)`);
        
        lineItems.push({
          price_data: {
            currency: (currency || "GBP").toLowerCase(),
            product_data: {
              name: `Additional Inspections (${additionalInspections} Ã— ${(additionalCostAmount / additionalInspections / 100).toFixed(2)} ${currency} per inspection)`,
              description: `${additionalInspections} additional inspections beyond ${tierIncluded} included in ${selectedTier.name} tier`,
            },
            unit_amount: additionalCostAmount,
            recurring: {
              interval: billingPeriod === "annual" ? "year" : "month",
            },
          },
          quantity: 1,
        });
      } else if (additionalInspections > 0) {
        console.warn(`[Billing Checkout] Warning: ${additionalInspections} additional inspections detected but additionalCost is missing or zero. Additional inspections will not be charged.`);
      }

      // Add modules with net prices (prorated credits already deducted)
      lineItems.push(...moduleLineItems);

      // If subscription exists, update it instead of creating new checkout
      if (existingStripeSubscription) {
        try {
          console.log(`[Billing Checkout] Updating existing subscription ${existingStripeSubscription.id}`);
          
          // Get current subscription items
          const currentItems = existingStripeSubscription.items.data;
          const tierItem = currentItems.find(item => {
            const product = item.price?.product;
            const productName = (typeof product === 'object' && product && 'name' in product) 
              ? (product.name || '') 
              : (item.price?.nickname || '');
            return productName && (productName.includes(selectedTier.name) || productName.includes('Plan'));
          });
          
          // Create new price for updated tier
          const newTierPrice = await stripe.prices.create({
            currency: (currency || "GBP").toLowerCase(),
            product_data: {
              name: `Inspect360 ${selectedTier.name} Plan`,
            },
            recurring: {
              interval: billingPeriod === "annual" ? "year" : "month",
            },
            unit_amount: tierAmount,
          });
          
          // Build items array for update
          const updateItems: any[] = [];
          
          // Update tier item if found, otherwise add new
          if (tierItem) {
            updateItems.push({
              id: tierItem.id,
              price: newTierPrice.id,
            });
          } else {
            updateItems.push({
              price: newTierPrice.id,
            });
          }
          
          // Add additional inspections line item if there are any
          if (additionalInspections > 0 && additionalCost !== undefined && additionalCost !== null && Number(additionalCost) > 0) {
            const additionalCostAmount = Number(additionalCost);
            // Check if additional inspections item already exists in subscription
            const existingAdditionalItem = currentItems.find(item => {
              const product = item.price?.product;
              const productName = (typeof product === 'object' && product && 'name' in product) 
                ? (product.name || '') 
                : (item.price?.nickname || '');
              return productName && productName.includes('Additional Inspections');
            });
            
            if (existingAdditionalItem) {
              // Update existing additional inspections item
              const additionalPrice = await stripe.prices.create({
                currency: (currency || "GBP").toLowerCase(),
                product_data: {
                  name: `Additional Inspections (${additionalInspections} Ã— ${(additionalCostAmount / additionalInspections / 100).toFixed(2)} ${currency} per inspection)`,
                },
                recurring: {
                  interval: billingPeriod === "annual" ? "year" : "month",
                },
                unit_amount: additionalCostAmount,
              });
              updateItems.push({
                id: existingAdditionalItem.id,
                price: additionalPrice.id,
              });
              console.log(`[Billing Checkout] Updating existing additional inspections item: ${additionalInspections} inspections for ${additionalCostAmount} ${currency}`);
            } else {
              // Add new additional inspections item
              const additionalPrice = await stripe.prices.create({
                currency: (currency || "GBP").toLowerCase(),
                product_data: {
                  name: `Additional Inspections (${additionalInspections} Ã— ${(additionalCostAmount / additionalInspections / 100).toFixed(2)} ${currency} per inspection)`,
                },
                recurring: {
                  interval: billingPeriod === "annual" ? "year" : "month",
                },
                unit_amount: additionalCostAmount,
              });
              updateItems.push({ price: additionalPrice.id });
              console.log(`[Billing Checkout] Adding new additional inspections item: ${additionalInspections} inspections for ${additionalCostAmount} ${currency}`);
            }
          } else if (additionalInspections > 0) {
            console.warn(`[Billing Checkout] Warning: ${additionalInspections} additional inspections detected but additionalCost is missing or zero. Additional inspections will not be charged.`);
          } else {
            // Remove additional inspections item if no longer needed
            const existingAdditionalItem = currentItems.find(item => {
              const product = item.price?.product;
              const productName = (typeof product === 'object' && product && 'name' in product) 
                ? (product.name || '') 
                : (item.price?.nickname || '');
              return productName && productName.includes('Additional Inspections');
            });
            
            if (existingAdditionalItem) {
              updateItems.push({ id: existingAdditionalItem.id, deleted: true });
              console.log(`[Billing Checkout] Removing additional inspections item as no longer needed`);
            }
          }

          // Add new module line items (create prices for each)
          for (const moduleItem of moduleLineItems) {
            // Extract product_data without description (Stripe doesn't support description in product_data)
            const { description, ...productDataWithoutDesc } = moduleItem.price_data.product_data as any;
            const modulePrice = await stripe.prices.create({
              currency: moduleItem.price_data.currency,
              product_data: productDataWithoutDesc,
              recurring: moduleItem.price_data.recurring,
              unit_amount: moduleItem.price_data.unit_amount,
            });
            updateItems.push({ price: modulePrice.id });
          }
          
          // Remove modules that are disabled but still in subscription
          const modules = await storage.getMarketplaceModules();
          for (const item of currentItems) {
            const product = item.price?.product;
            const productName = (typeof product === 'object' && product && 'name' in product) 
              ? (product.name || '') 
              : (item.price?.nickname || '');
            
            // Skip tier item
            if (productName && (productName.includes(selectedTier.name) || productName.includes('Plan'))) {
              continue;
            }
            
            // Check if this is a module that should be removed
            if (productName) {
              const matchedModule = modules.find(m => 
                m.name === productName.trim() || productName.includes(m.name)
              );
              
              if (matchedModule) {
                const instanceModules = await storage.getInstanceModules(instanceSub!.id);
                const instanceModule = instanceModules.find(im => im.moduleId === matchedModule.id);
                
                // If module is disabled or not enabled, remove it
                if (!instanceModule || !instanceModule.isEnabled) {
                  updateItems.push({ id: item.id, deleted: true });
                  console.log(`[Billing Checkout] Removing disabled module ${matchedModule.name} from subscription`);
                }
              }
            }
          }
          
          // Update subscription
          const updatedSubscription = await stripe.subscriptions.update(
            existingStripeSubscription.id,
            {
              items: updateItems,
              metadata: {
                ...existingStripeSubscription.metadata,
                tierId: selectedTier.id,
                planCode: selectedTier.code,
                billingPeriod: billingPeriod,
                currency: currency || "GBP",
                requestedInspections: totalInspections.toString(),
                additionalInspections: additionalInspections.toString(),
                tierIncluded: tierIncluded.toString(),
                additionalCost: (additionalCost !== undefined && additionalCost !== null) ? additionalCost.toString() : "0",
                moduleCount: moduleNames.length.toString(),
                moduleNames: moduleNames.join(","),
                totalProratedCredit: totalProratedCredit.toString()
              },
              proration_behavior: "create_prorations" // Apply proration for changes
            }
          );
          
          console.log(`[Billing Checkout] Successfully updated subscription ${updatedSubscription.id}`);
          
          // Return success - subscription updated, no checkout needed
          return res.json({ 
            success: true,
            message: "Subscription updated successfully",
            subscriptionId: updatedSubscription.id,
            updated: true,
            url: `${baseUrl}/billing?updated=true&subscription_id=${updatedSubscription.id}`
          });
        } catch (updateError: any) {
          console.error(`[Billing Checkout] Failed to update subscription:`, updateError.message);
          // Fall through to create new checkout if update fails
          console.log(`[Billing Checkout] Falling back to creating new checkout session`);
        }
      }

      // Create new checkout session (either no existing subscription or update failed)
      const session = await stripe.checkout.sessions.create({
        customer: org.stripeCustomerId || undefined,
        customer_email: org.stripeCustomerId ? undefined : user?.email,
        mode: "subscription",
        payment_method_types: ["card"],
        line_items: lineItems,
        success_url: `${baseUrl}/billing?success=true&session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${baseUrl}/billing?canceled=true`,
        metadata: {
          organizationId: org.id,
          tierId: selectedTier.id,
          planCode: selectedTier.code,
          billingPeriod: billingPeriod,
          currency: currency || "GBP",
          requestedInspections: totalInspections.toString(),
          additionalInspections: additionalInspections.toString(),
          tierIncluded: tierIncluded.toString(),
          additionalCost: (additionalCost !== undefined && additionalCost !== null) ? additionalCost.toString() : "0",
          type: "tier_subscription", // Mark as tier-based subscription for webhook handling
          moduleCount: moduleNames.length.toString(),
          moduleNames: moduleNames.join(","),
          totalProratedCredit: totalProratedCredit.toString()
        },
      });

      console.log(`[Billing] Final Session URL: ${session.url}`);
      res.json({ url: session.url });
    } catch (error: any) {
      console.error("Error in checkout:", error);
      res.status(500).json({ message: "Failed to initiate checkout", error: error.message });
    }
  });

  // Quotation endpoints - Customer
  app.post("/api/quotations/request", isAuthenticated, async (req: any, res) => {
    try {
      const { requestedInspections, currency, preferredBillingPeriod, customerNotes } = req.body;
      const organizationId = req.user.organizationId;

      if (!organizationId) {
        return res.status(400).json({ message: "Organization ID is required" });
      }

      if (!requestedInspections || requestedInspections < 500) {
        return res.status(400).json({ message: "Quotation requests are only available for 500+ inspections" });
      }

      // Check if there's already a pending/quoted request
      const existingRequest = await storage.getQuotationRequestByOrganization(organizationId);
      if (existingRequest) {
        return res.status(400).json({ 
          message: "You already have a pending quotation request",
          requestId: existingRequest.id 
        });
      }

      const org = await storage.getOrganization(organizationId);
      if (!org) {
        return res.status(404).json({ message: "Organization not found" });
      }

      const request = await storage.createQuotationRequest({
        organizationId,
        requestedInspections: Number(requestedInspections),
        currency: currency || org.preferredCurrency || "GBP",
        preferredBillingPeriod: preferredBillingPeriod || "monthly",
        status: "pending",
        customerNotes: customerNotes || null,
      });

      // Log activity
      await storage.createQuotationActivityLog({
        quotationRequestId: request.id,
        action: "created",
        performedBy: req.user.id,
        performedByType: "customer",
        details: { requestedInspections, currency, preferredBillingPeriod },
      });

      // Send email notification to all admins
      try {
        const { sendQuotationRequestNotification } = await import("./resend");
        const admins = await db.select().from(adminUsers);
        for (const admin of admins) {
          await sendQuotationRequestNotification(
            admin.email,
            admin.firstName,
            {
              requestId: request.id,
              organizationName: org.name,
              requestedInspections,
              currency,
              preferredBillingPeriod,
            }
          );
        }
      } catch (emailError) {
        console.error("Failed to send quotation request notification:", emailError);
        // Don't fail the request if email fails
      }

      res.json({ success: true, request });
    } catch (error: any) {
      console.error("Error creating quotation request:", error);
      res.status(500).json({ message: "Failed to create quotation request", error: error.message });
    }
  });

  app.get("/api/quotations/pending", isAuthenticated, async (req: any, res) => {
    try {
      const organizationId = req.user.organizationId;
      const request = await storage.getQuotationRequestByOrganization(organizationId);
      
      if (!request) {
        return res.json({ request: null, quotation: null });
      }

      const quotation = await storage.getQuotationByRequest(request.id);
      
      // Mark as viewed by customer if quotation exists
      if (quotation && !request.viewedByCustomerAt) {
        await storage.updateQuotationRequest(request.id, { viewedByCustomerAt: new Date() });
        await storage.createQuotationActivityLog({
          quotationRequestId: request.id,
          action: "viewed",
          performedBy: req.user.id,
          performedByType: "customer",
          details: { quotationId: quotation.id },
        });
      }

      res.json({ request, quotation });
    } catch (error: any) {
      console.error("Error fetching pending quotation:", error);
      res.status(500).json({ message: "Failed to fetch quotation", error: error.message });
    }
  });

  app.post("/api/quotations/:id/cancel", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const organizationId = req.user.organizationId;

      const request = await storage.getQuotationRequest(id);
      if (!request) {
        return res.status(404).json({ message: "Quotation request not found" });
      }

      if (request.organizationId !== organizationId) {
        return res.status(403).json({ message: "Not authorized" });
      }

      if (request.status === "accepted") {
        return res.status(400).json({ message: "Cannot cancel an accepted quotation" });
      }

      await storage.updateQuotationRequest(id, { status: "cancelled" });
      
      await storage.createQuotationActivityLog({
        quotationRequestId: id,
        action: "cancelled",
        performedBy: req.user.id,
        performedByType: "customer",
      });

      // Send email notification to admins
      try {
        const { sendQuotationCancelledEmail } = await import("./resend");
        const org = await storage.getOrganization(request.organizationId);
        const admins = await db.select().from(adminUsers);
        for (const admin of admins) {
          await sendQuotationCancelledEmail(
            admin.email,
            admin.firstName,
            {
              requestId: request.id,
              organizationName: org?.name || "Unknown Organization",
            }
          );
        }
      } catch (emailError) {
        console.error("Failed to send cancellation notification:", emailError);
      }

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error cancelling quotation request:", error);
      res.status(500).json({ message: "Failed to cancel quotation request", error: error.message });
    }
  });

  app.post("/api/quotations/:id/decline", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { reason } = req.body;
      const organizationId = req.user.organizationId;

      const request = await storage.getQuotationRequest(id);
      if (!request) {
        return res.status(404).json({ message: "Quotation request not found" });
      }

      if (request.organizationId !== organizationId) {
        return res.status(403).json({ message: "Not authorized" });
      }

      const quotation = await storage.getQuotationByRequest(id);
      if (!quotation) {
        return res.status(400).json({ message: "No quotation found for this request" });
      }

      await storage.updateQuotation(quotation.id, { status: "declined" });
      await storage.updateQuotationRequest(id, { status: "pending" }); // Reset to pending so admin can create new quote
      
      await storage.createQuotationActivityLog({
        quotationRequestId: id,
        action: "rejected",
        performedBy: req.user.id,
        performedByType: "customer",
        details: { reason, quotationId: quotation.id },
      });

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error declining quotation:", error);
      res.status(500).json({ message: "Failed to decline quotation", error: error.message });
    }
  });

  app.post("/api/billing/quotation-checkout", isAuthenticated, async (req: any, res) => {
    try {
      const { quotationId } = req.body;
      const organizationId = req.user.organizationId;

      if (!quotationId) {
        return res.status(400).json({ message: "Quotation ID is required" });
      }

      const quotation = await storage.getQuotation(quotationId);
      if (!quotation) {
        return res.status(404).json({ message: "Quotation not found" });
      }

      const request = await storage.getQuotationRequest(quotation.quotationRequestId);
      if (!request || request.organizationId !== organizationId) {
        return res.status(403).json({ message: "Not authorized" });
      }

      if (quotation.status !== "sent") {
        return res.status(400).json({ message: "Quotation is not available for checkout" });
      }

      const org = await storage.getOrganization(organizationId);
      if (!org) {
        return res.status(404).json({ message: "Organization not found" });
      }

      const stripe = await getUncachableStripeClient();
      const baseUrl = getBaseUrl(req);

      const description = `${quotation.quotedInspections} inspections per month (Custom Enterprise+ Quote)`;

      const session = await stripe.checkout.sessions.create({
        customer: org.stripeCustomerId || undefined,
        mode: "subscription",
        payment_method_types: ["card"],
        line_items: [
          {
            price_data: {
              currency: quotation.currency.toLowerCase(),
              product_data: {
                name: `Inspect360 Enterprise+ Custom Plan`,
                description: description,
              },
              unit_amount: quotation.quotedPrice,
              recurring: {
                interval: quotation.billingPeriod === "annual" ? "year" : "month",
              },
            },
            quantity: 1,
          },
        ],
        success_url: `${baseUrl}/billing?success=true&session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${baseUrl}/billing?canceled=true`,
        metadata: {
          organizationId: org.id,
          quotationId: quotation.id,
          quotationRequestId: request.id,
          quotedInspections: quotation.quotedInspections.toString(),
          billingPeriod: quotation.billingPeriod,
          currency: quotation.currency,
          type: "quotation_subscription"
        },
      });

      // Mark quotation as accepted
      await storage.updateQuotation(quotation.id, { status: "accepted" });
      await storage.updateQuotationRequest(request.id, { status: "accepted" });
      
      await storage.createQuotationActivityLog({
        quotationRequestId: request.id,
        action: "accepted",
        performedBy: req.user.id,
        performedByType: "customer",
        details: { quotationId: quotation.id, checkoutSessionId: session.id },
      });

      // Send email notification to admins
      try {
        const { sendQuotationAcceptedEmail } = await import("./resend");
        const admins = await db.select().from(adminUsers);
        for (const admin of admins) {
          await sendQuotationAcceptedEmail(
            admin.email,
            admin.firstName,
            {
              requestId: request.id,
              organizationName: org.name,
              quotedPrice: quotation.quotedPrice,
              currency: quotation.currency,
            }
          );
        }
      } catch (emailError) {
        console.error("Failed to send acceptance notification:", emailError);
      }

      res.json({ url: session.url });
    } catch (error: any) {
      console.error("Error in quotation checkout:", error);
      res.status(500).json({ message: "Failed to initiate checkout", error: error.message });
    }
  });

  // Stripe Portal endpoint moved to line 15729 (real implementation)

  // Legacy placeholder - replaced by new invoice endpoint below
  // app.get("/api/billing/invoices", ...) - See line 18380

  app.get("/api/billing/bundles", isAuthenticated, async (req: any, res) => {
    try {
      const currency = req.query.currency || "GBP";
      const packs = await storage.getAddonPacks();

      // Transform packs into bundles format expected by UI
      const bundles = await Promise.all(packs.map(async p => {
        // Find pricing for a default tier (e.g., Professional)
        const tiers = await storage.getSubscriptionTiers();
        const profTier = tiers.find(t => t.code === 'professional') || tiers[0];
        const pricing = await storage.getAddonPackPricing(p.id, profTier.id, currency);

        return {
          id: p.id,
          name: p.name,
          credits: p.inspectionQuantity,
          price: pricing?.totalPackPrice || 0,
          currency: currency,
          isPopular: p.packOrder === 1
        };
      }));

      res.json(bundles);
    } catch (error) {
      console.error("Error fetching bundles:", error);
      res.status(500).json({ message: "Failed to fetch bundles" });
    }
  });

  // Get available add-on packs with tier-specific pricing
  app.get("/api/billing/addon-packs", isAuthenticated, async (req: any, res) => {
    try {
      const organizationId = req.user.organizationId;
      const instanceSub = await storage.getInstanceSubscription(organizationId);

      if (!instanceSub || !instanceSub.currentTierId) {
        return res.status(400).json({ message: "No active subscription tier found" });
      }

      // Get currency from subscription or organization, fallback to GBP
      const org = await storage.getOrganization(organizationId);
      const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
      const packs = await storage.getAddonPacks();
      const tiers = await storage.getSubscriptionTiers();
      const currentTier = tiers.find(t => t.id === instanceSub.currentTierId);

      if (!currentTier) {
        return res.status(400).json({ message: "Current tier not found" });
      }

      // Get pricing for each pack based on current tier
      const packsWithPricing = await Promise.all(
        packs.filter(p => p.isActive).map(async (pack) => {
          const pricing = await storage.getAddonPackPricing(pack.id, currentTier.id, currency);
          
          if (!pricing) {
            return null;
          }

          return {
            id: pack.id,
            name: pack.name,
            inspectionQuantity: pack.inspectionQuantity,
            packOrder: pack.packOrder,
            pricePerInspection: pricing.pricePerInspection,
            totalPackPrice: pricing.totalPackPrice,
            currency: currency,
            tierName: currentTier.name
          };
        })
      );

      // Filter out nulls and sort by packOrder
      const validPacks = packsWithPricing.filter((p): p is NonNullable<typeof p> => p !== null).sort((a, b) => a.packOrder - b.packOrder);

      // Find best value (lowest price per inspection)
      const bestValuePack = validPacks.reduce((best, pack) => {
        if (!best) return pack;
        if (!pack) return best;
        const bestPricePerUnit = best.pricePerInspection / best.inspectionQuantity;
        const packPricePerUnit = pack.pricePerInspection / pack.inspectionQuantity;
        return packPricePerUnit < bestPricePerUnit ? pack : best;
      }, undefined as typeof validPacks[0] | undefined);

      res.json({
        packs: validPacks,
        bestValuePackId: bestValuePack?.id,
        currentTier: {
          id: currentTier.id,
          name: currentTier.name,
          code: currentTier.code
        },
        currency
      });
    } catch (error: any) {
      console.error("Error fetching add-on packs:", error);
      res.status(500).json({ message: "Failed to fetch add-on packs", error: error.message });
    }
  });

  // Purchase add-on pack
  app.post("/api/billing/addon-packs/:packId/purchase", isAuthenticated, async (req: any, res) => {
    try {
      const organizationId = req.user.organizationId;
      const packId = req.params.packId;

      const org = await storage.getOrganization(organizationId);
      if (!org) {
        return res.status(404).json({ message: "Organization not found" });
      }

      const instanceSub = await storage.getInstanceSubscription(organizationId);
      if (!instanceSub || !instanceSub.currentTierId) {
        return res.status(400).json({ message: "No active subscription tier found" });
      }

      // Get currency from subscription or organization, fallback to GBP
      const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";

      // Get pack details
      const packs = await storage.getAddonPacks();
      const pack = packs.find(p => p.id === packId && p.isActive);
      if (!pack) {
        return res.status(404).json({ message: "Add-on pack not found or inactive" });
      }

      // Validate pack has inspectionQuantity
      if (!pack.inspectionQuantity || pack.inspectionQuantity <= 0) {
        console.error(`[Addon Pack Purchase] Invalid inspectionQuantity for pack ${packId}: ${pack.inspectionQuantity}`);
        return res.status(400).json({ message: "Add-on pack has invalid inspection quantity" });
      }

      // Get tier-specific pricing
      const pricing = await storage.getAddonPackPricing(packId, instanceSub.currentTierId, currency);
      if (!pricing) {
        return res.status(400).json({ message: "Pricing not configured for this pack and tier" });
      }

      console.log(`[Addon Pack Purchase] Pack ${packId}: name=${pack.name}, inspectionQuantity=${pack.inspectionQuantity}, pricePerInspection=${pricing.pricePerInspection}, totalPrice=${pricing.totalPackPrice}`);

      // Create Stripe checkout session (one-time payment)
      const { getUncachableStripeClient } = await import("./stripeClient");
      const stripe = await getUncachableStripeClient();

      const checkoutSession = await stripe.checkout.sessions.create({
        customer: org.stripeCustomerId || undefined,
        payment_method_types: ["card"],
        line_items: [
          {
            price_data: {
              currency: currency.toLowerCase(),
              product_data: {
                name: `${pack.name} Add-On Pack`,
                description: `${pack.inspectionQuantity} additional inspections (${pricing.pricePerInspection / 100} ${currency} per inspection)`,
              },
              unit_amount: pricing.totalPackPrice,
            },
            quantity: 1,
          },
        ],
        mode: "payment", // One-time payment, not subscription
        success_url: `${req.headers.origin || "http://localhost:5000"}/billing?payment=success&session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${req.headers.origin || "http://localhost:5000"}/billing?payment=cancelled`,
        client_reference_id: organizationId,
        metadata: {
          organizationId,
          packId,
          tierIdAtPurchase: instanceSub.currentTierId,
          type: "addon_pack_purchase",
          quantity: pack.inspectionQuantity.toString(), // This is the number of inspection credits to grant
          pricePerInspection: pricing.pricePerInspection.toString(),
          totalPrice: pricing.totalPackPrice.toString(),
          currency: currency,
          packName: pack.name // Add pack name for debugging
        },
      });

      res.json({ url: checkoutSession.url });
    } catch (error: any) {
      console.error("Error creating add-on pack purchase checkout:", error);
      res.status(500).json({ message: "Failed to create checkout session", error: error.message });
    }
  });

  // ==================== ORGANIZATION TRADEMARKS ROUTES ====================

  // Get all trademarks for an organization
  app.get("/api/organizations/:id/trademarks", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const organizationId = req.params.id;

      const user = await storage.getUser(userId);
      if (!user?.organizationId || user.organizationId !== organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const trademarks = await storage.getOrganizationTrademarks(organizationId);
      res.json(trademarks);
    } catch (error) {
      console.error("Error fetching organization trademarks:", error);
      res.status(500).json({ message: "Failed to fetch trademarks" });
    }
  });

  // Create a new trademark
  app.post("/api/organizations/:id/trademarks", isAuthenticated, requireRole("owner"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const organizationId = req.params.id;

      const user = await storage.getUser(userId);
      if (!user?.organizationId || user.organizationId !== organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Check maximum limit (10 trademarks)
      const existingTrademarks = await storage.getOrganizationTrademarks(organizationId);
      if (existingTrademarks.length >= 10) {
        return res.status(400).json({ message: "Maximum of 10 trademarks allowed per organization" });
      }

      const { imageUrl, altText } = req.body;
      if (!imageUrl) {
        return res.status(400).json({ message: "Image URL is required" });
      }

      // Set display order to be at the end
      const displayOrder = existingTrademarks.length;

      const trademark = await storage.createOrganizationTrademark({
        organizationId,
        imageUrl,
        altText: altText || null,
        displayOrder,
      });

      res.status(201).json(trademark);
    } catch (error) {
      console.error("Error creating organization trademark:", error);
      res.status(500).json({ message: "Failed to create trademark" });
    }
  });

  // Update a trademark
  app.patch("/api/organizations/:id/trademarks/:trademarkId", isAuthenticated, requireRole("owner"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const organizationId = req.params.id;
      const trademarkId = req.params.trademarkId;

      const user = await storage.getUser(userId);
      if (!user?.organizationId || user.organizationId !== organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { imageUrl, altText, displayOrder } = req.body;

      const trademark = await storage.updateOrganizationTrademark(trademarkId, {
        imageUrl,
        altText,
        displayOrder,
      });

      if (!trademark) {
        return res.status(404).json({ message: "Trademark not found" });
      }

      res.json(trademark);
    } catch (error) {
      console.error("Error updating organization trademark:", error);
      res.status(500).json({ message: "Failed to update trademark" });
    }
  });

  // Delete a trademark
  app.delete("/api/organizations/:id/trademarks/:trademarkId", isAuthenticated, requireRole("owner"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const organizationId = req.params.id;
      const trademarkId = req.params.trademarkId;

      const user = await storage.getUser(userId);
      if (!user?.organizationId || user.organizationId !== organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      await storage.deleteOrganizationTrademark(trademarkId);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting organization trademark:", error);
      res.status(500).json({ message: "Failed to delete trademark" });
    }
  });

  // Reorder trademarks
  app.post("/api/organizations/:id/trademarks/reorder", isAuthenticated, requireRole("owner"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const organizationId = req.params.id;

      const user = await storage.getUser(userId);
      if (!user?.organizationId || user.organizationId !== organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { orderedIds } = req.body;
      if (!Array.isArray(orderedIds)) {
        return res.status(400).json({ message: "orderedIds must be an array" });
      }

      await storage.reorderOrganizationTrademarks(organizationId, orderedIds);
      const trademarks = await storage.getOrganizationTrademarks(organizationId);
      res.json(trademarks);
    } catch (error) {
      console.error("Error reordering organization trademarks:", error);
      res.status(500).json({ message: "Failed to reorder trademarks" });
    }
  });

  // ==================== USER DOCUMENTS ROUTES ====================

  // Get all documents for current user
  app.get("/api/user-documents", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const documents = await storage.getUserDocuments(userId);
      res.json(documents);
    } catch (error) {
      console.error("Error fetching user documents:", error);
      res.status(500).json({ message: "Failed to fetch documents" });
    }
  });

  // Get documents for a specific user (admin/owner access)
  app.get("/api/users/:userId/documents", isAuthenticated, requireRole("owner"), async (req: any, res) => {
    try {
      const requesterId = req.user.id;
      const requester = await storage.getUser(requesterId);
      const targetUserId = req.params.userId;

      if (!requester?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Verify the target user belongs to the same organization
      const targetUser = await storage.getUser(targetUserId);
      if (!targetUser || targetUser.organizationId !== requester.organizationId) {
        return res.status(403).json({ message: "User not found in your organization" });
      }

      const documents = await storage.getUserDocuments(targetUserId);
      res.json(documents);
    } catch (error) {
      console.error("Error fetching user documents:", error);
      res.status(500).json({ message: "Failed to fetch documents" });
    }
  });

  // Create a new user document
  app.post("/api/user-documents", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { documentName, documentType, fileUrl, expiryDate, notes } = req.body;

      if (!documentName || !fileUrl) {
        return res.status(400).json({ message: "Document name and file URL are required" });
      }

      const document = await storage.createUserDocument({
        userId,
        organizationId: user.organizationId,
        documentName,
        documentType: documentType || null,
        fileUrl,
        expiryDate: expiryDate ? new Date(expiryDate) : null,
        notes: notes || null,
      });

      res.status(201).json(document);
    } catch (error) {
      console.error("Error creating user document:", error);
      res.status(500).json({ message: "Failed to create document" });
    }
  });

  // Update a user document
  app.patch("/api/user-documents/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const documentId = req.params.id;

      const document = await storage.getUserDocument(documentId);
      if (!document) {
        return res.status(404).json({ message: "Document not found" });
      }

      // Only allow user to update their own documents
      if (document.userId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { documentName, documentType, expiryDate, notes } = req.body;

      const updated = await storage.updateUserDocument(documentId, {
        ...(documentName && { documentName }),
        ...(documentType !== undefined && { documentType }),
        ...(expiryDate !== undefined && { expiryDate: expiryDate ? new Date(expiryDate) : null }),
        ...(notes !== undefined && { notes }),
      });

      res.json(updated);
    } catch (error) {
      console.error("Error updating user document:", error);
      res.status(500).json({ message: "Failed to update document" });
    }
  });

  // Delete a user document
  app.delete("/api/user-documents/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const documentId = req.params.id;

      const document = await storage.getUserDocument(documentId);
      if (!document) {
        return res.status(404).json({ message: "Document not found" });
      }

      // Only allow user to delete their own documents
      if (document.userId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }

      await storage.deleteUserDocument(documentId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting user document:", error);
      res.status(500).json({ message: "Failed to delete document" });
    }
  });

  // ==================== TEAM MANAGEMENT ROUTES ====================

  app.get("/api/team", isAuthenticated, requireRole("owner"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const organizationId = user.organizationId;

      // Fetch all users but exclude tenants (they should appear in Contacts instead)
      const allUsers = await storage.getUsersByOrganization(organizationId);
      const teamMembers = allUsers.filter(u => u.role !== 'tenant');
      res.json(teamMembers);
    } catch (error) {
      console.error("Error fetching team members:", error);
      res.status(500).json({ message: "Failed to fetch team members" });
    }
  });

  app.patch("/api/team/:userId/role", isAuthenticated, requireRole("owner"), async (req: any, res) => {
    try {
      const requesterId = req.user.id;
      const requester = await storage.getUser(requesterId);

      if (!requester?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { userId } = req.params;
      const organizationId = requester.organizationId;

      // Validate request body
      const validation = updateUserRoleSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      // Verify the user belongs to the same organization
      const targetUser = await storage.getUser(userId);
      if (!targetUser || targetUser.organizationId !== organizationId) {
        return res.status(403).json({ message: "User not found in your organization" });
      }

      // Prevent changing own role
      if (userId === req.user.id) {
        return res.status(400).json({ message: "Cannot change your own role" });
      }

      const updatedUser = await storage.updateUserRole(userId, validation.data.role);
      res.json(updatedUser);
    } catch (error) {
      console.error("Error updating user role:", error);
      res.status(500).json({ message: "Failed to update user role" });
    }
  });

  // Toggle user active status
  app.patch("/api/team/:userId/status", isAuthenticated, requireRole("owner"), async (req: any, res) => {
    try {
      const requesterId = req.user.id;
      const requester = await storage.getUser(requesterId);

      if (!requester?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { userId } = req.params;

      // Validate request body
      const validation = updateUserStatusSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      // Verify the user belongs to the same organization
      const targetUser = await storage.getUser(userId);
      if (!targetUser || targetUser.organizationId !== requester.organizationId) {
        return res.status(403).json({ message: "User not found in your organization" });
      }

      // Prevent disabling own account
      if (userId === req.user.id) {
        return res.status(400).json({ message: "Cannot change your own account status" });
      }

      const updatedUser = await storage.updateUser(userId, { isActive: validation.data.isActive });
      const { password: _, ...userWithoutPassword } = updatedUser;
      res.json(userWithoutPassword);
    } catch (error) {
      console.error("Error updating user status:", error);
      res.status(500).json({ message: "Failed to update user status" });
    }
  });

  app.post("/api/team", isAuthenticated, requireRole("owner"), async (req: any, res) => {
    try {
      const requesterId = req.user.id;
      const requester = await storage.getUser(requesterId);

      if (!requester?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Validate request body
      const validation = createTeamMemberSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      const { email, firstName, lastName, username, password, role, phone, address, skills, education, profileImageUrl, certificateUrls } = validation.data;

      // Hash password before creating user
      const hashedPassword = await hashPassword(password);

      // Create team member with organization ID
      // NOTE: This creates the user in the same 'users' table where all user data is stored.
      // For tenants, the email and password set here will be used as login credentials for the tenant portal.
      // Handle address type (can be string or object)
      const addressValue = typeof address === 'string' ? address : (address ? JSON.stringify(address) : null);
      const newUser = await storage.createUser({
        email,
        firstName,
        lastName,
        username,
        password: hashedPassword, // This password will be used for tenant portal login
        role, // For tenants, this will be "tenant"
        phone,
        address: addressValue as any,
        skills,
        education,
        profileImageUrl,
        certificateUrls,
        organizationId: requester.organizationId,
      });

      // If the user is a tenant, automatically create a corresponding contact
      if (role === 'tenant') {
        try {
          await storage.createContact({
            organizationId: requester.organizationId,
            type: 'tenant',
            firstName: firstName || '',
            lastName: lastName || '',
            email: email,
            phone: phone || undefined,
            profileImageUrl: profileImageUrl || undefined,
            linkedUserId: newUser.id,
            notes: 'Automatically created from tenant user',
          });
          console.log(`âœ“ Created contact record for tenant user ${newUser.id}`);
        } catch (contactError) {
          // Log error but don't fail the user creation
          console.error(`Warning: Failed to create contact for tenant user ${newUser.id}:`, contactError);
        }
      }

      // Don't return password
      const { password: _, ...userWithoutPassword } = newUser;
      res.json(userWithoutPassword);
    } catch (error: any) {
      console.error("Error creating team member:", error);
      if (error.message?.includes("duplicate") || error.message?.includes("unique")) {
        res.status(400).json({ message: "Email or username already exists" });
      } else {
        res.status(500).json({ message: "Failed to create team member" });
      }
    }
  });

  app.patch("/api/team/:userId", isAuthenticated, requireRole("owner"), async (req: any, res) => {
    try {
      const requesterId = req.user.id;
      const requester = await storage.getUser(requesterId);

      if (!requester?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { userId } = req.params;

      // Validate request body
      const validation = updateTeamMemberSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      // Verify the user belongs to the same organization
      const targetUser = await storage.getUser(userId);
      if (!targetUser || targetUser.organizationId !== requester.organizationId) {
        return res.status(403).json({ message: "User not found in your organization" });
      }

      if (Object.keys(validation.data).length === 0) {
        return res.status(400).json({ message: "No valid fields to update" });
      }

      const updatedUser = await storage.updateUser(userId, validation.data);

      // Don't return password
      const { password, ...userWithoutPassword } = updatedUser;
      res.json(userWithoutPassword);
    } catch (error) {
      console.error("Error updating team member:", error);
      res.status(500).json({ message: "Failed to update team member" });
    }
  });

  // ==================== CONTACT ROUTES ====================

  app.get("/api/contacts", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const contacts = await storage.getContactsByOrganization(user.organizationId);

      // Fetch tags for each contact
      const contactsWithTags = await Promise.all(
        contacts.map(async (contact) => {
          const tags = await storage.getTagsForContact(contact.id);
          return { ...contact, tags };
        })
      );

      res.json(contactsWithTags);
    } catch (error) {
      console.error("Error fetching contacts:", error);
      res.status(500).json({ error: "Failed to fetch contacts" });
    }
  });

  app.get("/api/contacts/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const contact = await storage.getContact(req.params.id);

      if (!contact) {
        return res.status(404).json({ error: "Contact not found" });
      }

      if (contact.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      res.json(contact);
    } catch (error) {
      console.error("Error fetching contact:", error);
      res.status(500).json({ error: "Failed to fetch contact" });
    }
  });

  app.post("/api/contacts", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const validation = insertContactSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({ error: "Invalid request data", details: validation.error });
      }

      const contact = await storage.createContact({
        ...validation.data,
        organizationId: user.organizationId
      });

      res.status(201).json(contact);
    } catch (error) {
      console.error("Error creating contact:", error);
      res.status(500).json({ error: "Failed to create contact" });
    }
  });

  // Sync tenant users to contacts (migration endpoint for existing tenants)
  app.post("/api/contacts/sync-tenants", isAuthenticated, requireRole("owner"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Get all tenant users in the organization
      const allUsers = await storage.getUsersByOrganization(user.organizationId);
      const tenantUsers = allUsers.filter(u => u.role === 'tenant');

      // Get all existing contacts to check for linkedUserId
      const existingContacts = await storage.getContactsByOrganization(user.organizationId);
      const linkedUserIds = new Set(
        existingContacts
          .filter(c => c.linkedUserId)
          .map(c => c.linkedUserId)
      );

      // Create contacts for tenant users that don't have one yet
      const results = {
        total: tenantUsers.length,
        created: 0,
        skipped: 0,
        errors: [] as string[],
      };

      for (const tenant of tenantUsers) {
        if (linkedUserIds.has(tenant.id)) {
          results.skipped++;
          continue;
        }

        try {
          await storage.createContact({
            organizationId: user.organizationId,
            type: 'tenant',
            firstName: tenant.firstName || '',
            lastName: tenant.lastName || '',
            email: tenant.email,
            phone: tenant.phone || undefined,
            profileImageUrl: tenant.profileImageUrl || undefined,
            linkedUserId: tenant.id,
            notes: 'Migrated from tenant user',
          });
          results.created++;
          console.log(`âœ“ Created contact for tenant user ${tenant.id}`);
        } catch (contactError) {
          results.errors.push(`Failed to create contact for ${tenant.email}: ${contactError instanceof Error ? contactError.message : String(contactError)}`);
          console.error(`Error creating contact for tenant ${tenant.id}:`, contactError);
        }
      }

      res.json(results);
    } catch (error) {
      console.error("Error syncing tenants to contacts:", error);
      res.status(500).json({ error: "Failed to sync tenants" });
    }
  });

  app.patch("/api/contacts/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const contact = await storage.getContact(req.params.id);

      if (!contact) {
        return res.status(404).json({ error: "Contact not found" });
      }

      if (contact.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      // Validate request body
      const validation = updateContactSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      const updatedContact = await storage.updateContact(req.params.id, validation.data);
      res.json(updatedContact);
    } catch (error) {
      console.error("Error updating contact:", error);
      res.status(500).json({ error: "Failed to update contact" });
    }
  });

  app.delete("/api/contacts/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const contact = await storage.getContact(req.params.id);

      if (!contact) {
        return res.status(404).json({ error: "Contact not found" });
      }

      if (contact.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      await storage.deleteContact(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting contact:", error);
      res.status(500).json({ error: "Failed to delete contact" });
    }
  });

  // ==================== PROPERTY ROUTES ====================

  app.post("/api/properties", isAuthenticated, requireRole("owner", "compliance"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Validate request body
      const validation = insertPropertySchema.omit({ organizationId: true }).safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      const { name, address, blockId } = validation.data;

      const property = await storage.createProperty({
        organizationId: user.organizationId,
        name,
        address,
        blockId: blockId || null,
      });

      res.json(property);
    } catch (error) {
      console.error("Error creating property:", error);
      res.status(500).json({ message: "Failed to create property" });
    }
  });

  app.get("/api/properties", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user) {
        return res.json([]);
      }

      // For tenants, return properties from their active assignments
      if (user.role === "tenant") {
        const assignments = await db
          .select({
            propertyId: tenantAssignments.propertyId,
          })
          .from(tenantAssignments)
          .where(
            and(
              eq(tenantAssignments.tenantId, userId),
              eq(tenantAssignments.isActive, true)
            )
          );

        const propertyIds = assignments.map((a) => a.propertyId);

        if (propertyIds.length === 0) {
          return res.json([]);
        }

        // Fetch the actual property objects
        const tenantPropertiesList = await db
          .select()
          .from(properties)
          .where(inArray(properties.id, propertyIds));

        return res.json(tenantPropertiesList);
      }

      // For other roles, require organizationId
      if (!user.organizationId) {
        return res.json([]);
      }

      const orgProperties = await storage.getPropertiesByOrganization(user.organizationId);
      res.json(orgProperties);
    } catch (error) {
      console.error("Error fetching properties:", error);
      res.status(500).json({ message: "Failed to fetch properties" });
    }
  });

  app.get("/api/properties/:id", isAuthenticated, async (req, res) => {
    try {
      const { id } = req.params;
      const property = await storage.getProperty(id);

      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }

      res.json(property);
    } catch (error) {
      console.error("Error fetching property:", error);
      res.status(500).json({ message: "Failed to fetch property" });
    }
  });

  // Update property
  app.patch("/api/properties/:id", isAuthenticated, requireRole("owner", "compliance"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify organization ownership
      const existing = await storage.getProperty(req.params.id);
      if (!existing) {
        return res.status(404).json({ error: "Property not found" });
      }
      if (existing.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      // Validate request body (partial update) with Zod
      const parseResult = updatePropertySchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({
          error: "Invalid request data",
          details: parseResult.error.errors
        });
      }

      const updates = parseResult.data;
      const updateData: any = {};

      // Only include fields that are provided in the update
      if (updates.name !== undefined) {
        updateData.name = updates.name;
      }
      if (updates.address !== undefined) {
        updateData.address = updates.address;
      }
      if (updates.blockId !== undefined) {
        // Allow setting blockId to null to remove block assignment
        // Convert null string to actual null
        updateData.blockId = updates.blockId === null || updates.blockId === "null" ? null : updates.blockId;
      }
      if (updates.imageUrl !== undefined) {
        updateData.imageUrl = updates.imageUrl;
      }
      if (updates.notes !== undefined) {
        updateData.notes = updates.notes;
      }

      const property = await storage.updateProperty(req.params.id, updateData);

      res.json(property);
    } catch (error: any) {
      console.error("Error updating property:", error);
      res.status(500).json({ error: "Failed to update property" });
    }
  });

  // Get property stats
  app.get("/api/properties/:id/stats", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const property = await storage.getProperty(id);
      if (!property || property.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Property not found" });
      }

      // Get inspections for this property
      const inspections = await storage.getInspectionsByProperty(id);
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

      // Overdue: scheduled date is before today
      const overdueInspections = inspections.filter(i =>
        i.status === 'scheduled' && i.scheduledDate && new Date(i.scheduledDate) < today
      ).length;

      // Due soon: scheduled date is today or in the near future (next 7 days)
      const weekFromNow = new Date(today);
      weekFromNow.setDate(weekFromNow.getDate() + 7);
      const dueInspections = inspections.filter(i =>
        i.status === 'scheduled' && i.scheduledDate &&
        new Date(i.scheduledDate) >= today &&
        new Date(i.scheduledDate) <= weekFromNow
      ).length;

      // Get compliance docs for this property
      const allComplianceDocs = await storage.getComplianceDocuments(user.organizationId);
      const complianceDocs = allComplianceDocs.filter((d: any) => d.propertyId === id);
      const validDocs = complianceDocs.filter((d: any) => {
        if (!d.expiryDate) return true;
        return new Date(d.expiryDate) > now;
      }).length;
      const complianceRate = complianceDocs.length > 0
        ? Math.round((validDocs / complianceDocs.length) * 100)
        : 100;

      // Get maintenance requests
      const maintenanceRequests = await storage.getMaintenanceRequestsByProperty(id);
      const openRequests = maintenanceRequests.filter(m =>
        m.status !== 'completed' && m.status !== 'closed'
      ).length;

      // Get inventory count
      const inventory = await storage.getAssetInventoryByProperty(id);

      // Get tenants from tenant_assignments table (the correct source)
      const tenantAssignments = await storage.getTenantAssignmentsByProperty(id, user.organizationId);
      // Filter for active assignments only
      const activeAssignments = tenantAssignments.filter((ta: any) => ta.status === 'active');

      res.json({
        occupancyStatus: activeAssignments.length > 0 ? `${activeAssignments.length} Tenant${activeAssignments.length > 1 ? 's' : ''}` : 'Vacant',
        complianceRate,
        dueInspections,
        overdueInspections,
        maintenanceRequests: openRequests,
        inventoryCount: inventory.length,
      });
    } catch (error) {
      console.error("Error fetching property stats:", error);
      res.status(500).json({ message: "Failed to fetch property stats" });
    }
  });

  // Get property tenants
  app.get("/api/properties/:id/tenants", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const property = await storage.getProperty(id);
      if (!property || property.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Property not found" });
      }

      // Use tenant_assignments table to get property tenants with organization isolation
      const tenants = await storage.getTenantAssignmentsByProperty(id, user.organizationId);

      res.json(tenants);
    } catch (error) {
      console.error("Error fetching property tenants:", error);
      res.status(500).json({ message: "Failed to fetch tenants" });
    }
  });

  // Get property inspections
  app.get("/api/properties/:id/inspections", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const property = await storage.getProperty(id);
      if (!property || property.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Property not found" });
      }

      const inspections = await storage.getInspectionsByProperty(id);

      // Enhance with template names and inspector info
      const enhancedInspections = await Promise.all(inspections.map(async (inspection: any) => {
        let templateName = 'Unknown Template';
        if (inspection.templateId) {
          const template = await storage.getInspectionTemplate(inspection.templateId);
          if (template) templateName = template.name;
        }

        let inspectorName = undefined;
        if (inspection.inspectorId) {
          const inspector = await storage.getUser(inspection.inspectorId);
          if (inspector) inspectorName = `${inspector.firstName} ${inspector.lastName}`;
        }

        return {
          id: inspection.id,
          templateName,
          scheduledDate: inspection.scheduledDate,
          status: inspection.status,
          inspectorName,
        };
      }));

      res.json(enhancedInspections);
    } catch (error) {
      console.error("Error fetching property inspections:", error);
      res.status(500).json({ message: "Failed to fetch inspections" });
    }
  });

  // Get property inventory
  app.get("/api/properties/:id/inventory", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const property = await storage.getProperty(id);
      if (!property || property.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Property not found" });
      }

      const inventory = await storage.getAssetInventoryByProperty(id);

      // Enhance with formatted data for BTR managers
      const enhancedInventory = inventory.map((item: any) => ({
        id: item.id,
        name: item.name,
        description: item.description,
        category: item.category || 'General',
        condition: item.condition,
        quantity: 1, // Default quantity
        datePurchased: item.datePurchased,
        expectedLifespanYears: item.expectedLifespanYears,
        photoUrl: item.photos?.[0] || null, // Use first photo from photos array
      }));

      res.json(enhancedInventory);
    } catch (error) {
      console.error("Error fetching property inventory:", error);
      res.status(500).json({ message: "Failed to fetch inventory" });
    }
  });

  // Get property compliance documents
  app.get("/api/properties/:id/compliance", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const property = await storage.getProperty(id);
      if (!property || property.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Property not found" });
      }

      const allComplianceDocs = await storage.getComplianceDocuments(user.organizationId);
      const complianceDocs = allComplianceDocs.filter((d: any) => d.propertyId === id);

      // Add status based on expiry and enhance with names
      const now = new Date();
      const enhancedDocs = complianceDocs.map((doc: any) => {
        let status = 'valid';
        if (doc.expiryDate) {
          const expiryDate = new Date(doc.expiryDate);
          const daysUntilExpiry = Math.ceil((expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));

          if (daysUntilExpiry < 0) {
            status = 'expired';
          } else if (daysUntilExpiry <= 30) {
            status = 'expiring';
          } else {
            status = 'valid';
          }
        }

        return {
          id: doc.id,
          documentName: doc.documentType, // Use documentType as name
          documentType: doc.documentType,
          documentUrl: doc.documentUrl,
          expiryDate: doc.expiryDate,
          status,
          uploadedAt: doc.createdAt,
        };
      });

      res.json(enhancedDocs);
    } catch (error) {
      console.error("Error fetching property compliance:", error);
      res.status(500).json({ message: "Failed to fetch compliance documents" });
    }
  });

  // Get property annual compliance report
  app.get("/api/properties/:id/compliance-report", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const property = await storage.getProperty(id);
      if (!property || property.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Property not found" });
      }

      // Get year from query parameter, default to current year
      const yearParam = req.query.year;
      const year = yearParam ? parseInt(yearParam as string, 10) : new Date().getFullYear();

      // Get all inspections for this property
      const allInspections = await storage.getInspectionsByProperty(id);

      // Get all inspection templates
      const templates = await storage.getInspectionTemplatesByOrganization(user.organizationId);
      const activeTemplates = templates.filter(t => t.isActive && (t.scope === 'property' || t.scope === 'both'));

      // Build compliance data by template and month
      const currentYear = year;
      const months = [
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'
      ];

      const complianceData = activeTemplates.map(template => {
        const templateInspections = allInspections.filter(i => i.templateId === template.id);

        const monthData = months.map((monthName, monthIndex) => {
          // Find inspections scheduled for this month
          const monthInspections = templateInspections.filter(inspection => {
            if (!inspection.scheduledDate) return false;
            const schedDate = new Date(inspection.scheduledDate);
            return schedDate.getFullYear() === currentYear && schedDate.getMonth() === monthIndex;
          });

          if (monthInspections.length === 0) {
            return { month: monthName, status: 'not_scheduled', count: 0 };
          }

          const now = new Date();
          const completedCount = monthInspections.filter(i => i.status === 'completed').length;
          const overdueCount = monthInspections.filter(i => {
            if (i.status === 'completed' || !i.scheduledDate) return false;
            const schedDate = new Date(i.scheduledDate);
            return schedDate < now;
          }).length;

          const dueCount = monthInspections.filter(i => {
            if (i.status === 'completed' || !i.scheduledDate) return false;
            const schedDate = new Date(i.scheduledDate);
            const daysUntil = Math.ceil((schedDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
            return daysUntil >= 0 && daysUntil <= 30;
          }).length;

          let status = 'not_scheduled';
          if (overdueCount > 0) {
            status = 'overdue';
          } else if (completedCount === monthInspections.length) {
            status = 'completed';
          } else if (dueCount > 0) {
            status = 'due';
          } else {
            status = 'scheduled';
          }

          return {
            month: monthName,
            status,
            count: monthInspections.length,
            completed: completedCount,
            overdue: overdueCount,
          };
        });

        // Calculate compliance percentage for this template
        const totalScheduled = monthData.reduce((sum, m) => sum + m.count, 0);
        const totalCompleted = monthData.reduce((sum, m) => sum + (m.completed || 0), 0);
        const complianceRate = totalScheduled > 0 ? Math.round((totalCompleted / totalScheduled) * 100) : 0;

        return {
          templateId: template.id,
          templateName: template.name,
          monthData,
          complianceRate,
          totalScheduled,
          totalCompleted,
        };
      });

      // Calculate overall compliance
      const totalScheduled = complianceData.reduce((sum, t) => sum + t.totalScheduled, 0);
      const totalCompleted = complianceData.reduce((sum, t) => sum + t.totalCompleted, 0);
      const overallCompliance = totalScheduled > 0 ? Math.round((totalCompleted / totalScheduled) * 100) : 100;

      res.json({
        year: currentYear,
        months,
        templates: complianceData,
        overallCompliance,
        totalScheduled,
        totalCompleted,
      });
    } catch (error) {
      console.error("Error fetching property compliance report:", error);
      res.status(500).json({ message: "Failed to fetch compliance report" });
    }
  });

  // Get property maintenance requests
  app.get("/api/properties/:id/maintenance", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const property = await storage.getProperty(id);
      if (!property || property.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Property not found" });
      }

      const maintenance = await storage.getMaintenanceRequestsByProperty(id);

      // Enhance with user info
      const enhancedMaintenance = await Promise.all(maintenance.map(async (request: any) => {
        let reportedByName = 'Unknown';
        if (request.reportedBy) {
          const reporter = await storage.getUser(request.reportedBy);
          if (reporter) reportedByName = `${reporter.firstName} ${reporter.lastName}`;
        }

        let assignedToName = undefined;
        if (request.assignedTo) {
          const assignee = await storage.getUser(request.assignedTo);
          if (assignee) assignedToName = `${assignee.firstName} ${assignee.lastName}`;
        }

        return {
          id: request.id,
          title: request.title,
          description: request.description,
          priority: request.priority,
          status: request.status,
          category: request.source || 'general', // Use source as category for now
          createdAt: request.createdAt,
          reportedByName,
          assignedToName,
          photoUrl: request.photoUrl,
        };
      }));

      res.json(enhancedMaintenance);
    } catch (error) {
      console.error("Error fetching property maintenance:", error);
      res.status(500).json({ message: "Failed to fetch maintenance requests" });
    }
  });

  // ==================== USER ROUTES ====================

  app.get("/api/users/clerks", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.json([]);
      }

      // Get all team members who can conduct inspections (clerks, owners, compliance officers)
      // Exclude tenants and contractors as they cannot be assigned inspections
      const allUsers = await storage.getUsersByOrganization(user.organizationId);
      const inspectors = allUsers.filter(u =>
        u.isActive !== false &&
        ['clerk', 'owner', 'compliance'].includes(u.role)
      );
      res.json(inspectors);
    } catch (error) {
      console.error("Error fetching clerks:", error);
      res.status(500).json({ message: "Failed to fetch clerks" });
    }
  });

  app.get("/api/users/role/tenant", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.json([]);
      }

      const users = await storage.getUsersByOrganizationAndRole(user.organizationId, "tenant");
      // Filter to only return active tenants
      const activeTenants = users.filter(u => u.isActive !== false);
      res.json(activeTenants);
    } catch (error) {
      console.error("Error fetching tenants:", error);
      res.status(500).json({ message: "Failed to fetch tenants" });
    }
  });

  // ==================== PROPERTY BY BLOCK ROUTES ====================

  // Get properties by block
  app.get("/api/blocks/:blockId/properties", isAuthenticated, async (req, res) => {
    try {
      const { blockId } = req.params;
      const properties = await storage.getPropertiesByBlock(blockId);
      res.json(properties);
    } catch (error) {
      console.error("Error fetching properties for block:", error);
      res.status(500).json({ message: "Failed to fetch properties" });
    }
  });

  // ==================== INSPECTION ROUTES ====================

  app.post("/api/inspections", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const currentUser = await storage.getUser(userId);
      const { propertyId, blockId, type, scheduledDate, notes, clerkId, templateId } = req.body;

      // Must specify either propertyId OR blockId (not both)
      if ((!propertyId && !blockId) || (propertyId && blockId)) {
        return res.status(400).json({ message: "Must specify either propertyId OR blockId (not both)" });
      }

      if (!type) {
        return res.status(400).json({ message: "Inspection type is required" });
      }

      if (!currentUser?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Check if organization has sufficient credits to create an inspection
      // Minimum 1 credit is required (base credit for an inspection)
      try {
        const creditBalance = await storage.getCreditBalance(currentUser.organizationId);
        console.log(`[Create Inspection] Credit check for org ${currentUser.organizationId}: total=${creditBalance.total}, current=${creditBalance.current}, rolled=${creditBalance.rolled}`);
        
        if (creditBalance.total < 1) {
          console.log(`[Create Inspection] BLOCKED: Insufficient credits (${creditBalance.total} < 1)`);
          return res.status(402).json({ 
            message: "No credits available for inspection. Please subscribe to a plan to get inspection credits.",
            error: "insufficient_credits"
          });
        }
      } catch (creditCheckError: any) {
        console.error(`[Create Inspection] Error checking credits:`, creditCheckError);
        // If we can't check credits, block the creation to be safe
        return res.status(402).json({ 
          message: "No credits available for inspection. Please subscribe to a plan to get inspection credits.",
          error: "insufficient_credits"
        });
      }

      // Use provided clerkId if available, otherwise assign to current user
      let inspectorId = userId;

      if (clerkId) {
        // Validate that the clerk belongs to the same organization
        const clerk = await storage.getUser(clerkId);
        if (!clerk || clerk.organizationId !== currentUser.organizationId) {
          return res.status(400).json({ message: "Invalid clerk assignment - clerk must belong to your organization" });
        }
        inspectorId = clerkId;
      }

      // Handle template snapshot creation
      let templateSnapshotJson = null;
      let templateVersion = null;
      let finalTemplateId = templateId;

      if (!finalTemplateId) {
        const orgTemplates = await storage.getInspectionTemplatesByOrganization(currentUser.organizationId);

        if (type === 'check_in') {
          const checkInTemplate = orgTemplates.find(t =>
            t.name.toLowerCase().includes('check in') && t.isActive
          );
          if (checkInTemplate) {
            finalTemplateId = checkInTemplate.id;
            console.log(`Auto-selected Check In template: ${checkInTemplate.id}`);
          }
        } else if (type === 'check_out') {
          const checkOutTemplate = orgTemplates.find(t =>
            t.name.toLowerCase().includes('check out') && t.isActive
          );
          if (checkOutTemplate) {
            finalTemplateId = checkOutTemplate.id;
            console.log(`Auto-selected Check Out template: ${checkOutTemplate.id}`);
          }
        }
      }

      if (finalTemplateId) {
        const template = await storage.getInspectionTemplate(finalTemplateId);
        if (!template) {
          return res.status(404).json({ message: "Template not found" });
        }

        if (template.organizationId !== currentUser.organizationId) {
          return res.status(403).json({ message: "Template does not belong to your organization" });
        }

        const isPropertyInspection = !!propertyId;
        const isBlockInspection = !!blockId;

        if (isPropertyInspection && template.scope === 'block') {
          return res.status(400).json({ message: "Cannot use block-scoped template for property inspection" });
        }
        if (isBlockInspection && template.scope === 'property') {
          return res.status(400).json({ message: "Cannot use property-scoped template for block inspection" });
        }

        templateSnapshotJson = template.structureJson;
        templateVersion = template.version;
      }

      const inspection = await storage.createInspection({
        organizationId: currentUser.organizationId,
        propertyId: propertyId || null,
        blockId: blockId || null,
        inspectorId,
        type,
        scheduledDate: scheduledDate ? new Date(scheduledDate) : new Date(),
        notes,
        templateId: finalTemplateId || null,
        templateVersion,
        templateSnapshotJson: templateSnapshotJson as any,
      });

      res.json(inspection);
    } catch (error) {
      console.error("Error creating inspection:", error);
      console.error("Request body:", req.body);
      console.error("Error details:", error instanceof Error ? error.message : String(error));
      res.status(500).json({
        message: "Failed to create inspection",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Bulk schedule multiple inspections at once from calendar
  app.post("/api/inspections/bulk-schedule", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const currentUser = await storage.getUser(userId);

      if (!currentUser?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { entityType, entityId, year, selections } = req.body;

      if (!entityType || !entityId || !selections || !Array.isArray(selections)) {
        return res.status(400).json({ message: "Missing required fields: entityType, entityId, selections" });
      }

      if (selections.length === 0) {
        return res.status(400).json({ message: "No inspections to schedule" });
      }

      // Validate entity exists and belongs to organization
      if (entityType === 'property') {
        const property = await storage.getProperty(entityId);
        if (!property || property.organizationId !== currentUser.organizationId) {
          return res.status(404).json({ message: "Property not found or access denied" });
        }
      } else if (entityType === 'block') {
        const block = await storage.getBlock(entityId);
        if (!block || block.organizationId !== currentUser.organizationId) {
          return res.status(404).json({ message: "Block not found or access denied" });
        }
      } else {
        return res.status(400).json({ message: "Invalid entity type" });
      }

      const targetYear = year || new Date().getFullYear();
      const createdInspections = [];

      const inspectionType = req.body.type || 'routine';

      for (const selection of selections) {
        const { templateId, monthIndex } = selection;

        if (templateId === undefined || monthIndex === undefined) {
          continue;
        }

        // Validate template exists and belongs to organization
        const template = await storage.getInspectionTemplate(templateId);
        if (!template || template.organizationId !== currentUser.organizationId) {
          continue;
        }

        // Validate template scope matches entity type
        if (entityType === 'property' && template.scope === 'block') {
          continue;
        }
        if (entityType === 'block' && template.scope === 'property') {
          continue;
        }

        // Schedule for the 15th of the month at 9:00 AM
        const scheduledDate = new Date(targetYear, monthIndex, 15, 9, 0, 0);

        try {
          const inspection = await storage.createInspection({
            organizationId: currentUser.organizationId,
            propertyId: entityType === 'property' ? entityId : null,
            blockId: entityType === 'block' ? entityId : null,
            inspectorId: userId,
            type: inspectionType,
            scheduledDate,
            notes: `Scheduled via bulk calendar scheduling`,
            templateId,
            templateVersion: template.version,
            templateSnapshotJson: template.structureJson as any,
          });
          createdInspections.push(inspection);
        } catch (error) {
          console.error(`Failed to create inspection for template ${templateId}, month ${monthIndex}:`, error);
        }
      }

      res.json({
        success: true,
        count: createdInspections.length,
        inspections: createdInspections
      });
    } catch (error) {
      console.error("Error bulk scheduling inspections:", error);
      res.status(500).json({
        message: "Failed to schedule inspections",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  // Copy an inspection as a new type (check_in or check_out)
  app.post("/api/inspections/:id/copy", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { type, scheduledDate, copyImages, copyText } = req.body;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      // Validate required fields
      if (!type || !['check_in', 'check_out'].includes(type)) {
        return res.status(400).json({ message: "Type must be 'check_in' or 'check_out'" });
      }

      if (!scheduledDate) {
        return res.status(400).json({ message: "Scheduled date is required" });
      }

      // Get source inspection
      const sourceInspection = await storage.getInspection(id);
      if (!sourceInspection) {
        return res.status(404).json({ message: "Source inspection not found" });
      }

      // Verify access
      if (sourceInspection.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Get appropriate template for the new type
      let templateId = null;
      let templateSnapshotJson = null;
      let templateVersion = null;

      const orgTemplates = await storage.getInspectionTemplatesByOrganization(user.organizationId);

      if (type === 'check_in') {
        const checkInTemplate = orgTemplates.find(t =>
          t.name.toLowerCase().includes('check in') && t.isActive
        );
        if (checkInTemplate) {
          templateId = checkInTemplate.id;
          templateVersion = checkInTemplate.version;
          templateSnapshotJson = checkInTemplate.structureJson;
        }
      } else if (type === 'check_out') {
        const checkOutTemplate = orgTemplates.find(t =>
          t.name.toLowerCase().includes('check out') && t.isActive
        );
        if (checkOutTemplate) {
          templateId = checkOutTemplate.id;
          templateVersion = checkOutTemplate.version;
          templateSnapshotJson = checkOutTemplate.structureJson;
        }
      }

      // Fall back to source template if no matching template found
      if (!templateId && sourceInspection.templateId) {
        templateId = sourceInspection.templateId;
        templateSnapshotJson = sourceInspection.templateSnapshotJson;
        templateVersion = sourceInspection.templateVersion;
      }

      // Create new inspection
      const newInspection = await storage.createInspection({
        organizationId: user.organizationId,
        propertyId: sourceInspection.propertyId,
        blockId: sourceInspection.blockId,
        inspectorId: userId,
        type,
        scheduledDate: new Date(scheduledDate),
        notes: `Copied from inspection ${sourceInspection.id}`,
        templateId,
        templateVersion,
        templateSnapshotJson: templateSnapshotJson as any,
      });

      // Copy entries if requested
      if (copyImages || copyText) {
        const sourceEntries = await storage.getInspectionEntries(id);

        for (const entry of sourceEntries) {
          const newEntry: any = {
            inspectionId: newInspection.id,
            sectionRef: entry.sectionRef,
            fieldKey: entry.fieldKey,
            fieldType: entry.fieldType,
          };

          // Copy photos if requested
          if (copyImages && entry.photos && entry.photos.length > 0) {
            newEntry.photos = entry.photos;
          }

          // Copy text/note if requested
          if (copyText) {
            if (entry.note) newEntry.note = entry.note;
            // condition and value are stored in valueJson, not as direct properties
            if (entry.valueJson && typeof entry.valueJson === 'object') {
              const valueJson = entry.valueJson as any;
              if (valueJson.condition) {
                newEntry.valueJson = { ...(newEntry.valueJson as any || {}), condition: valueJson.condition };
              }
              if (valueJson.value) {
                newEntry.valueJson = { ...(newEntry.valueJson as any || {}), value: valueJson.value };
              }
            }
          }

          // Only create entry if there's something to copy
          const hasValueJson = newEntry.valueJson && typeof newEntry.valueJson === 'object' && Object.keys(newEntry.valueJson as any).length > 0;
          if (newEntry.photos || newEntry.note || hasValueJson) {
            await storage.createInspectionEntry(newEntry);
          }
        }
      }

      res.json({
        success: true,
        inspection: newInspection,
        message: `Inspection copied successfully as ${type === 'check_in' ? 'Check-In' : 'Check-Out'}`
      });
    } catch (error) {
      console.error("Error copying inspection:", error);
      res.status(500).json({
        message: "Failed to copy inspection",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });

  app.get("/api/inspections/my", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.json([]);
      }

      // Owners see all inspections in their organization
      // Clerks see only inspections assigned to them
      let inspections;
      if (user.role === "owner" || user.role === "compliance") {
        inspections = await storage.getInspectionsByOrganization(user.organizationId);
      } else {
        inspections = await storage.getInspectionsByInspector(userId);
      }

      // Auto-approve expired check-in inspections
      const now = new Date();
      for (const inspection of inspections) {
        if (inspection.type === "check_in" &&
          inspection.status === "completed" &&
          inspection.tenantApprovalDeadline &&
          new Date(inspection.tenantApprovalDeadline) < now &&
          (!inspection.tenantApprovalStatus || inspection.tenantApprovalStatus === "pending")) {
          try {
            await storage.updateInspection(inspection.id, {
              tenantApprovalStatus: "approved",
              tenantApprovedAt: now,
            } as any);
            // Update the inspection object in the response
            inspection.tenantApprovalStatus = "approved";
            inspection.tenantApprovedAt = now.toISOString();
          } catch (error) {
            console.error(`Failed to auto-approve inspection ${inspection.id}:`, error);
          }
        }
      }

      res.json(inspections);
    } catch (error) {
      console.error("Error fetching inspections:", error);
      res.status(500).json({ message: "Failed to fetch inspections" });
    }
  });
  // Copy data from previous check-in inspection
  app.post("/api/inspections/:id/copy-from-checkin", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { copyImages, copyNotes } = req.body;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      // Get current inspection
      const inspection = await storage.getInspection(id);
      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }

      // Verify access
      if (inspection.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      if (!inspection.propertyId) {
        return res.status(400).json({ message: "Inspection must be associated with a property" });
      }

      // Get most recent check-in
      const checkInInspection = await storage.getMostRecentCheckInInspection(inspection.propertyId);
      if (!checkInInspection) {
        return res.status(404).json({ message: "No previous check-in inspection found" });
      }

      // Get entries
      const checkInEntries = await storage.getInspectionEntries(checkInInspection.id);
      const currentEntries = await storage.getInspectionEntries(id);

      console.log(`[Copy] ===== Starting Copy Operation =====`);
      console.log(`[Copy] Check-in inspection ID: ${checkInInspection.id}`);
      console.log(`[Copy] Check-out inspection ID: ${id}`);
      console.log(`[Copy] Check-in entries count: ${checkInEntries.length}`);
      console.log(`[Copy] Current checkout entries count: ${currentEntries.length}`);
      console.log(`[Copy] Check-in entries:`, checkInEntries.map(e => ({ sectionRef: e.sectionRef, fieldKey: e.fieldKey, photos: e.photos?.length || 0, hasNote: !!e.note })));

      // Parse template structure
      let sections: any[] = [];
      if (inspection.templateSnapshotJson) {
        const templateStructure = typeof inspection.templateSnapshotJson === 'string'
          ? JSON.parse(inspection.templateSnapshotJson)
          : inspection.templateSnapshotJson;
        sections = templateStructure?.sections || [];
      } else if (inspection.templateId) {
        const template = await storage.getInspectionTemplate(inspection.templateId);
        if (template && template.structureJson) {
          const structure = typeof template.structureJson === 'string'
            ? JSON.parse(template.structureJson as string)
            : template.structureJson;
          sections = (structure as any).sections || [];
        }
      }

      console.log(`[Copy] Template sections found: ${sections.length}`);
      console.log(`[Copy] Template sections:`, sections.map(s => ({ id: s.id, title: s.title, fields: s.fields.map((f: any) => f.id || f.key) })));

      const modifiedImageKeys: string[] = [];
      const modifiedNoteKeys: string[] = [];
      let processedCount = 0;
      let matchedCount = 0;
      let copiedCount = 0;

      // Helper to find matching section/field
      const findMatch = (checkInEntry: any) => {
        console.log(`[Copy] Finding match for: sectionRef=${checkInEntry.sectionRef}, fieldKey=${checkInEntry.fieldKey}`);

        // Try exact match first (with checkin/checkout mapping)
        let matchingSection = sections.find((s: any) => {
          const matches = sectionRefsMatch(s.id, checkInEntry.sectionRef);
          if (matches) {
            console.log(`[Copy] Section matched: ${s.id} with ${checkInEntry.sectionRef}`);
          }
          return matches;
        });

        let matchingField = null;
        if (matchingSection) {
          console.log(`[Copy] Checking ${matchingSection.fields.length} fields in section ${matchingSection.id}`);
          matchingField = matchingSection.fields.find((f: any) => {
            const fieldId = f.id || f.key;
            // Note: fieldKeysMatch expects (checkInFieldKey, checkOutFieldKey)
            // checkInEntry.fieldKey is from check-in, fieldId is from checkout template
            const matches = fieldKeysMatch(checkInEntry.fieldKey, fieldId);
            if (matches) {
              console.log(`[Copy] Field matched: ${fieldId} with ${checkInEntry.fieldKey}`);
            } else {
              console.log(`[Copy] Field did not match: ${fieldId} vs ${checkInEntry.fieldKey}`);
            }
            return matches;
          });
        }

        if (matchingSection && matchingField) {
          return { matchingSection, matchingField };
        }

        // Try matching by section title/id with checkin/checkout mapping
        if (!matchingSection || !matchingField) {
          console.log(`[Copy] Trying fuzzy section match...`);
          matchingSection = sections.find((s: any) => {
            const matches = sectionRefsMatch(s.title || s.id, checkInEntry.sectionRef);
            if (matches) {
              console.log(`[Copy] Fuzzy section matched: ${s.title || s.id} with ${checkInEntry.sectionRef}`);
            }
            return matches;
          });

          if (matchingSection) {
            console.log(`[Copy] Checking ${matchingSection.fields.length} fields in fuzzy-matched section`);
            matchingField = matchingSection.fields.find((f: any) => {
              const fieldId = f.id || f.key;
              const matches = fieldKeysMatch(checkInEntry.fieldKey, fieldId) ||
                (f.label && fieldKeysMatch(checkInEntry.fieldKey, f.label));
              if (matches) {
                console.log(`[Copy] Fuzzy field matched: ${fieldId} or label "${f.label}" with ${checkInEntry.fieldKey}`);
              }
              return matches;
            });
          }
        }

        if (!matchingField && matchingSection) {
          console.log(`[Copy] No field match found. Available fields:`, matchingSection.fields.map((f: any) => f.id || f.key));
        }

        return { matchingSection, matchingField };
      };

      for (const checkInEntry of checkInEntries) {
        processedCount++;

        // Extract photos from either photos column or valueJson
        let checkInPhotos = checkInEntry.photos || [];
        if ((!checkInPhotos || checkInPhotos.length === 0) && checkInEntry.valueJson) {
          let valueJson = null;
          try {
            valueJson = typeof checkInEntry.valueJson === 'string'
              ? JSON.parse(checkInEntry.valueJson)
              : checkInEntry.valueJson;
          } catch (e) {
            // valueJson might be a plain string (not JSON), which is fine - just can't extract photos from it
          }

          if (valueJson && Array.isArray(valueJson.photos)) {
            checkInPhotos = valueJson.photos;
          } else if (valueJson && valueJson.photo) {
            checkInPhotos = [valueJson.photo];
          }
        }

        // Extract note from either note column or valueJson
        let checkInNote = checkInEntry.note;
        if (!checkInNote && checkInEntry.valueJson) {
          let valueJson = null;
          try {
            valueJson = typeof checkInEntry.valueJson === 'string'
              ? JSON.parse(checkInEntry.valueJson)
              : checkInEntry.valueJson;
          } catch (e) {
            // valueJson might be a plain string
          }

          if (valueJson && valueJson.note) {
            checkInNote = valueJson.note;
          }
        }

        // Check if we have data to copy
        const hasPhotos = checkInPhotos.length > 0;
        const hasNote = !!checkInNote && checkInNote.trim().length > 0;

        console.log(`[Copy] Entry ${processedCount}/${checkInEntries.length}: sectionRef=${checkInEntry.sectionRef}, fieldKey=${checkInEntry.fieldKey}, hasPhotos=${hasPhotos}, hasNote=${hasNote}`);

        // Skip if no data to copy and user didn't request it
        if (!hasPhotos && !hasNote) {
          console.log(`[Copy] Skipping entry ${processedCount}: no photos or notes to copy`);
          continue;
        }
        if (hasPhotos && !copyImages && !hasNote) {
          console.log(`[Copy] Skipping entry ${processedCount}: has photos but copyImages=false and no notes`);
          continue;
        }
        if (hasNote && !copyNotes && !hasPhotos) {
          console.log(`[Copy] Skipping entry ${processedCount}: has note but copyNotes=false and no photos`);
          continue;
        }

        const { matchingSection, matchingField } = findMatch(checkInEntry);

        console.log(`[Copy] Match result for entry ${processedCount}: section=${matchingSection?.id || 'none'}, field=${matchingField?.id || 'none'}`);

        if (matchingSection && matchingField) {
          matchedCount++;
          const key = `${matchingSection.id}-${matchingField.id}`;

          // Find existing entry or create new one
          let existingEntry = currentEntries.find(e =>
            e.sectionRef === matchingSection.id && e.fieldKey === matchingField.id
          );

          console.log(`[Copy] Processing match ${matchedCount}: key=${key}, existingEntry=${!!existingEntry}`);

          let photos = existingEntry?.photos || [];
          let note = existingEntry?.note;
          let changed = false;
          let imagesCopied = false;
          let notesCopied = false;

          // Copy photos - merge with existing photos, avoiding duplicates
          if (copyImages && hasPhotos) {
            const newPhotos = checkInPhotos.filter((p: string) => !photos.includes(p));
            if (newPhotos.length > 0) {
              photos = [...photos, ...newPhotos];
              changed = true;
              imagesCopied = true;
              console.log(`[Copy] âœ“ Copied ${newPhotos.length} photos to ${key} (total: ${photos.length})`);
            } else {
              console.log(`[Copy] No new photos to copy to ${key} (all ${checkInPhotos.length} already exist)`);
            }
          }

          // Copy notes - replace if empty, or append if not empty
          if (copyNotes && hasNote) {
            if (!note || note.trim().length === 0) {
              // No existing note, copy the check-in note
              note = checkInNote;
              changed = true;
              notesCopied = true;
              console.log(`[Copy] âœ“ Copied note to ${key}`);
            } else {
              // Existing note found, append check-in note
              note = `${note}\n\n--- Copied from Check-In ---\n${checkInNote}`;
              changed = true;
              notesCopied = true;
              console.log(`[Copy] âœ“ Appended note to ${key} (existing note was present)`);
            }
          }

          if (changed) {
            copiedCount++;
            if (existingEntry) {
              await storage.updateInspectionEntry(existingEntry.id, {
                photos,
                note
              });
              console.log(`[Copy] âœ“ Updated existing entry ${existingEntry.id} for ${key}`);
            } else {
              const newEntry = await storage.createInspectionEntry({
                inspectionId: id,
                sectionRef: matchingSection.id,
                fieldKey: matchingField.id,
                fieldType: matchingField.type || checkInEntry.fieldType || 'text',
                photos,
                note,
                valueJson: null
              });
              console.log(`[Copy] âœ“ Created new entry ${newEntry.id} for ${key}`);
            }

            if (imagesCopied) modifiedImageKeys.push(key);
            if (notesCopied) modifiedNoteKeys.push(key);
          } else {
            console.log(`[Copy] No changes needed for ${key}`);
          }
        } else {
          console.log(`[Copy] âœ— No match found for entry ${processedCount}: sectionRef=${checkInEntry.sectionRef}, fieldKey=${checkInEntry.fieldKey}`);
        }
      }

      console.log(`[Copy] ===== Copy Summary =====`);
      console.log(`[Copy] Total check-in entries processed: ${processedCount}`);
      console.log(`[Copy] Entries matched: ${matchedCount}`);
      console.log(`[Copy] Entries copied: ${copiedCount}`);
      console.log(`[Copy] Image keys modified: ${modifiedImageKeys.length}`);
      console.log(`[Copy] Note keys modified: ${modifiedNoteKeys.length}`);
      console.log(`[Copy] Modified image keys:`, modifiedImageKeys);
      console.log(`[Copy] Modified note keys:`, modifiedNoteKeys);
      console.log(`[Copy] ========================`);

      res.json({ success: true, modifiedImageKeys, modifiedNoteKeys });
    } catch (error) {
      console.error("Error copying data:", error);
      res.status(500).json({ message: "Failed to copy data" });
    }
  });


  app.get("/api/inspections/:id", isAuthenticated, async (req: any, res) => {
    try {
      // Set cache-control headers to prevent caching
      res.setHeader("Cache-Control", "no-cache, no-store, must-revalidate");
      res.setHeader("Pragma", "no-cache");
      res.setHeader("Expires", "0");
      const { id } = req.params;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user) {
        return res.status(403).json({ message: "User not found" });
      }

      let inspection = await storage.getInspection(id);

      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }

      // Verify access: Clerks can only view inspections assigned to them
      // Tenants can view check-in inspections for their property
      if (user.role === "tenant") {
        // For tenants, verify they have access to this property
        const tenancy = await storage.getTenancyByTenantId(userId);
        if (!tenancy || tenancy.propertyId !== inspection.propertyId) {
          return res.status(403).json({ message: "Access denied: You don't have access to this inspection" });
        }
        // Only allow tenants to view check-in inspections
        if (inspection.type !== "check_in") {
          return res.status(403).json({ message: "Access denied: Tenants can only view check-in inspections" });
        }

        // Auto-approve if deadline has passed and status is still pending
        if (inspection.tenantApprovalDeadline &&
          (inspection.tenantApprovalStatus === "pending" || !inspection.tenantApprovalStatus) &&
          new Date(inspection.tenantApprovalDeadline) < new Date()) {
          try {
            await storage.updateInspection(id, {
              tenantApprovalStatus: "approved",
              tenantApprovedAt: new Date(),
              tenantApprovedBy: userId,
            } as any);
            // Refetch the inspection to get updated status
            inspection = await storage.getInspection(id);
            if (!inspection) {
              return res.status(404).json({ message: "Inspection not found" });
            }
          } catch (error) {
            console.error(`Failed to auto-approve inspection ${id}:`, error);
          }
        }
      } else if (user.role !== "owner" && user.role !== "compliance") {
        if (inspection.inspectorId !== userId) {
          return res.status(403).json({ message: "Access denied: Inspection not assigned to you" });
        }
      }

      // Verify organization ownership (skip for tenants as they may not have organizationId)
      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }
      if (user.role !== "tenant" && inspection.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied: Inspection does not belong to your organization" });
      }

      // Fetch inspection items
      const items = await storage.getInspectionItems(id);

      // Fetch related data
      let property = null;
      let block = null;
      let clerk = null;

      if (inspection.propertyId) {
        property = await storage.getProperty(inspection.propertyId);
      }
      if (inspection.blockId) {
        block = await storage.getBlock(inspection.blockId);
      }
      if (inspection.inspectorId) {
        clerk = await storage.getUser(inspection.inspectorId);
      }

      const response = {
        ...inspection,
        items,
        property,
        block,
        clerk,
      };

      res.json(response);
    } catch (error) {
      console.error("Error fetching inspection:", error);
      res.status(500).json({ message: "Failed to fetch inspection" });
    }
  });

  // Generate PDF report for inspection
  app.get("/api/inspections/:id/pdf", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const user = await storage.getUser(req.user.id);

      if (!user?.organizationId) {
        return res.status(403).json({ message: "No organization found" });
      }

      // Get inspection
      const inspection = await storage.getInspection(id);
      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }

      // Verify organization ownership
      if (inspection.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Fetch property and inspector data
      let property = null;
      let inspector = null;

      if (inspection.propertyId) {
        property = await storage.getProperty(inspection.propertyId);
      }

      if (inspection.inspectorId) {
        inspector = await storage.getUser(inspection.inspectorId);
      }

      // Fetch organization branding for white-label PDF
      const organization = await storage.getOrganization(user.organizationId);

      // Fetch organization trademarks (new multi-trademark system)
      const organizationTrademarks = await storage.getOrganizationTrademarks(user.organizationId);
      const trademarksArray = organizationTrademarks.map(tm => ({
        imageUrl: tm.imageUrl,
        altText: tm.altText,
      }));

      const branding = organization ? {
        logoUrl: organization.logoUrl,
        trademarkUrl: organization.trademarkUrl,
        trademarks: trademarksArray,
        brandingName: organization.brandingName,
        brandingEmail: organization.brandingEmail,
        brandingPhone: organization.brandingPhone,
        brandingAddress: organization.brandingAddress,
        brandingWebsite: organization.brandingWebsite,
      } : undefined;

      // Build full inspection object with relations
      const fullInspection = {
        ...inspection,
        property: property || undefined,
        inspector: inspector || undefined,
      };

      // Get inspection entries
      const entries = await storage.getInspectionEntries(id);

      // Fetch outstanding maintenance requests for this property
      let maintenanceRequests: any[] = [];
      try {
        if (inspection.propertyId) {
          const allRequests = await storage.getMaintenanceRequestsByProperty(inspection.propertyId);
          // Filter to only show open/pending/in_progress requests
          maintenanceRequests = allRequests.filter((r: any) =>
            ['open', 'pending', 'in_progress', 'assigned'].includes(r.status)
          );
        }
      } catch (e) {
        console.log("Could not fetch maintenance requests for PDF:", e);
      }

      // Fetch template's report configuration if templateId exists
      let reportConfig: any = undefined;
      if (inspection.templateId) {
        try {
          const template = await storage.getInspectionTemplate(inspection.templateId);
          if (template?.reportConfig) {
            reportConfig = template.reportConfig;
          }
        } catch (e) {
          console.log("Could not fetch template report config:", e);
        }
      }

      // Build base URL for converting relative image paths to absolute
      const protocol = req.protocol;
      const host = req.get('host');
      const baseUrl = `${protocol}://${host}`;

      // Generate PDF with branding, maintenance requests, and report configuration
      // Convert entries to match expected type (note: null -> undefined)
      const entriesForPDF = entries.map(e => ({
        ...e,
        note: e.note ?? undefined
      }));
      const pdfBuffer = await generateInspectionPDF(fullInspection as any, entriesForPDF as any, baseUrl, branding, maintenanceRequests, reportConfig);

      // Set headers for PDF download
      const propertyName = property?.name || "inspection";
      const filename = `${propertyName.replace(/[^a-zA-Z0-9]/g, "_")}_inspection_report.pdf`;

      res.setHeader("Content-Type", "application/pdf");
      res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
      res.setHeader("Content-Length", pdfBuffer.length);

      res.send(pdfBuffer);
    } catch (error) {
      console.error("Error generating PDF:", error);
      res.status(500).json({ message: "Failed to generate PDF report" });
    }
  });

  // General PATCH endpoint for updating inspection fields
  app.patch("/api/inspections/:id", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const user = await storage.getUser(req.user.id);

      if (!user?.organizationId) {
        return res.status(403).json({ message: "No organization found" });
      }

      // Get inspection and verify ownership
      const inspection = await storage.getInspection(id);
      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }

      // Verify organization ownership via property or block
      let ownerOrgId: string | null = null;
      if (inspection.propertyId) {
        const property = await storage.getProperty(inspection.propertyId);
        if (!property) {
          return res.status(404).json({ message: "Property not found" });
        }
        ownerOrgId = property.organizationId;
      } else if (inspection.blockId) {
        const block = await storage.getBlock(inspection.blockId);
        if (!block) {
          return res.status(404).json({ message: "Block not found" });
        }
        ownerOrgId = block.organizationId;
      }

      if (ownerOrgId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Verify access: Clerks can only update inspections assigned to them
      if (user.role !== "owner" && user.role !== "compliance") {
        if (inspection.inspectorId !== user.id) {
          return res.status(403).json({ message: "Access denied: Inspection not assigned to you" });
        }
      }

      // Validate and update inspection
      const validation = updateInspectionSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      // Convert date strings to Date objects for storage
      const updates: any = { ...validation.data };
      if (updates.scheduledDate && typeof updates.scheduledDate === 'string') {
        updates.scheduledDate = new Date(updates.scheduledDate);
      }
      if (updates.startedAt && typeof updates.startedAt === 'string') {
        updates.startedAt = new Date(updates.startedAt);
      }
      if (updates.completedDate && typeof updates.completedDate === 'string') {
        updates.completedDate = new Date(updates.completedDate);
      }
      if (updates.submittedAt && typeof updates.submittedAt === 'string') {
        updates.submittedAt = new Date(updates.submittedAt);
      }

      // Handle credit consumption when inspection is completed
      // Note: "submitted" is not a valid status in the enum, only "completed" triggers credit consumption
      if (validation.data.status === "completed" &&
        inspection.status !== "completed" &&
        !inspection.creditsConsumed) {
        // Check credits BEFORE allowing completion - this must succeed or block completion
        try {
          // Check credits BEFORE allowing completion
          const creditBalance = await storage.getCreditBalance(ownerOrgId);
          console.log(`[Complete Inspection] Credit check for org ${ownerOrgId}: total=${creditBalance.total}, current=${creditBalance.current}, rolled=${creditBalance.rolled}`);
          
          // Debug: Get all batches to see what's available
          const allBatches = await storage.getCreditBatchesByOrganization(ownerOrgId);
          console.log(`[Complete Inspection] All credit batches for org ${ownerOrgId}:`, allBatches.map(b => ({
            id: b.id,
            source: b.grantSource,
            remaining: b.remainingQuantity,
            expiresAt: b.expiresAt,
            metadata: b.metadataJson
          })));
          
          // Get image count
          const imageCount = await storage.getInspectionImageCount(id);

          // Calculate credits needed (1 base + 1 per 250 images)
          const subscriptionService = (await import("./subscriptionService")).subscriptionService;
          const creditsNeeded = subscriptionService.calculateInspectionCredits(imageCount);
          console.log(`[Complete Inspection] Credits needed: ${creditsNeeded} (images: ${imageCount})`);

          // Check if organization has sufficient credits BEFORE attempting to consume
          const finalBalance = creditBalance;
          if (finalBalance.total < creditsNeeded) {
            console.log(`[Complete Inspection] BLOCKED: Insufficient credits (${finalBalance.total} < ${creditsNeeded})`);
            console.log(`[Complete Inspection] Available batches: ${allBatches.length}, Total remaining: ${allBatches.reduce((sum, b) => sum + b.remainingQuantity, 0)}`);
            return res.status(402).json({
              message: `No credits available for inspection. You need ${creditsNeeded} credits but only have ${finalBalance.total} available. Please subscribe to a plan to get inspection credits.`,
              error: "insufficient_credits"
            });
          }

          // Consume credits
          await subscriptionService.consumeInspectionCredits(ownerOrgId, creditsNeeded, id);

          // Update inspection with credit info
          updates.creditsConsumed = creditsNeeded;
          updates.imagesCount = imageCount;
        } catch (creditError: any) {
          console.error('[Complete Inspection] Failed to check/consume credits:', creditError);
          // If insufficient credits or any credit-related error, block completion
          if (creditError.message.includes("Insufficient credits") || creditError.message.includes("No subscription found")) {
            return res.status(402).json({
              message: "No credits available for inspection. Please subscribe to a plan to get inspection credits.",
              error: "insufficient_credits"
            });
          }
          // For other errors, also block to be safe
          return res.status(402).json({
            message: "No credits available for inspection. Please subscribe to a plan to get inspection credits.",
            error: "insufficient_credits"
          });
        }
      }

      const updatedInspection = await storage.updateInspection(id, updates);

      // Send email if status changed to completed
      if (validation.data.status === "completed" && inspection.status !== "completed") {
        try {
          const inspector = await storage.getUser(inspection.inspectorId);
          const inspectorName = inspector ? `${inspector.firstName || ''} ${inspector.lastName || ''}`.trim() || inspector.username : 'Unknown Inspector';

          let propertyName: string | undefined;
          let blockName: string | undefined;

          if (inspection.propertyId) {
            const property = await storage.getProperty(inspection.propertyId);
            propertyName = property?.name;
          } else if (inspection.blockId) {
            const block = await storage.getBlock(inspection.blockId);
            blockName = block?.name;
          }

          // For check-in inspections, set tenant approval status and deadline
          if (inspection.type === "check_in" && inspection.propertyId) {
            try {
              const organization = await storage.getOrganization(ownerOrgId);
              const approvalPeriodDays = organization?.checkInApprovalPeriodDays ?? 5;
              const deadline = new Date();
              deadline.setDate(deadline.getDate() + approvalPeriodDays);

              await storage.updateInspection(id, {
                tenantApprovalStatus: "pending",
                tenantApprovalDeadline: deadline,
              } as any);
            } catch (approvalError) {
              console.error('Failed to set tenant approval status:', approvalError);
            }
          }

          if (ownerOrgId) {
            const owners = await storage.getUsersByOrganization(ownerOrgId);
            const owner = owners.find(u => u.role === 'owner');

            if (owner && owner.email) {
              await sendInspectionCompleteEmail(
                owner.email,
                `${owner.firstName || ''} ${owner.lastName || ''}`.trim() || owner.email,
                {
                  type: inspection.type,
                  propertyName,
                  blockName,
                  inspectorName,
                  completedDate: updatedInspection.completedDate || new Date(),
                  inspectionId: inspection.id
                }
              );
            }
          }
        } catch (emailError) {
          console.error('Failed to send inspection complete email:', emailError);
        }
      }

      res.json(updatedInspection);
    } catch (error) {
      console.error("Error updating inspection:", error);
      res.status(500).json({ message: "Failed to update inspection" });
    }
  });

  // PUT handler for inspection completion (used by InspectionReview)
  // This mirrors the PATCH handler but accepts PUT requests
  app.put("/api/inspections/:id", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const user = await storage.getUser(req.user.id);

      if (!user?.organizationId) {
        return res.status(403).json({ message: "No organization found" });
      }

      // Get inspection and verify ownership
      const inspection = await storage.getInspection(id);
      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }

      // Verify organization ownership via property or block
      let ownerOrgId: string | null = null;
      if (inspection.propertyId) {
        const property = await storage.getProperty(inspection.propertyId);
        if (!property) {
          return res.status(404).json({ message: "Property not found" });
        }
        ownerOrgId = property.organizationId;
      } else if (inspection.blockId) {
        const block = await storage.getBlock(inspection.blockId);
        if (!block) {
          return res.status(404).json({ message: "Block not found" });
        }
        ownerOrgId = block.organizationId;
      }

      if (ownerOrgId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Verify access: Clerks can only update inspections assigned to them
      if (user.role !== "owner" && user.role !== "compliance") {
        if (inspection.inspectorId !== user.id) {
          return res.status(403).json({ message: "Access denied: Inspection not assigned to you" });
        }
      }

      // Handle credit consumption when inspection is completed
      const updates: any = {};
      if (req.body.status === "completed" &&
        inspection.status !== "completed" &&
        !inspection.creditsConsumed) {
        // Check credits BEFORE allowing completion - this must succeed or block completion
        try {
          // Check credits BEFORE allowing completion
          const creditBalance = await storage.getCreditBalance(ownerOrgId);
          console.log(`[PUT Complete] Credit check for org ${ownerOrgId}: total=${creditBalance.total}`);
          
          // Get image count
          const imageCount = await storage.getInspectionImageCount(id);

          // Calculate credits needed (1 base + 1 per 250 images)
          const subscriptionService = (await import("./subscriptionService")).subscriptionService;
          const creditsNeeded = subscriptionService.calculateInspectionCredits(imageCount);
          console.log(`[PUT Complete] Credits needed: ${creditsNeeded} (images: ${imageCount})`);

          // Check if organization has sufficient credits BEFORE attempting to consume
          if (creditBalance.total < creditsNeeded) {
            console.log(`[PUT Complete] BLOCKED: Insufficient credits (${creditBalance.total} < ${creditsNeeded})`);
            return res.status(402).json({
              message: `No credits available for inspection. You need ${creditsNeeded} credits but only have ${creditBalance.total} available. Please subscribe to a plan to get inspection credits.`,
              error: "insufficient_credits"
            });
          }

          // Consume credits
          await subscriptionService.consumeInspectionCredits(ownerOrgId, creditsNeeded, id);

          // Update inspection with credit info
          updates.creditsConsumed = creditsNeeded;
          updates.imagesCount = imageCount;
        } catch (creditError: any) {
          console.error('[PUT Complete] Failed to check/consume credits:', creditError);
          // If insufficient credits or any credit-related error, block completion
          if (creditError.message.includes("Insufficient credits") || creditError.message.includes("No subscription found")) {
            return res.status(402).json({
              message: "No credits available for inspection. Please subscribe to a plan to get inspection credits.",
              error: "insufficient_credits"
            });
          }
          // For other errors, also block to be safe
          return res.status(402).json({
            message: "No credits available for inspection. Please subscribe to a plan to get inspection credits.",
            error: "insufficient_credits"
          });
        }
      }

      // Apply updates from request body
      if (req.body.status) updates.status = req.body.status;
      if (req.body.completedDate) updates.completedDate = new Date(req.body.completedDate);
      if (req.body.submittedAt) updates.submittedAt = new Date(req.body.submittedAt);

      const updatedInspection = await storage.updateInspection(id, updates);

      // Send email if status changed to completed
      if (req.body.status === "completed" && inspection.status !== "completed") {
        try {
          const inspector = await storage.getUser(inspection.inspectorId);
          const inspectorName = inspector ? `${inspector.firstName || ''} ${inspector.lastName || ''}`.trim() || inspector.username : 'Unknown Inspector';

          let propertyName: string | undefined;
          let blockName: string | undefined;

          if (inspection.propertyId) {
            const property = await storage.getProperty(inspection.propertyId);
            propertyName = property?.name;
          } else if (inspection.blockId) {
            const block = await storage.getBlock(inspection.blockId);
            blockName = block?.name;
          }

          // For check-in inspections, set tenant approval status and deadline
          if (inspection.type === "check_in" && inspection.propertyId) {
            try {
              const organization = await storage.getOrganization(ownerOrgId);
              const approvalPeriodDays = organization?.checkInApprovalPeriodDays ?? 5;
              const deadline = new Date();
              deadline.setDate(deadline.getDate() + approvalPeriodDays);

              await storage.updateInspection(id, {
                tenantApprovalStatus: "pending",
                tenantApprovalDeadline: deadline,
              } as any);
            } catch (approvalError) {
              console.error('Failed to set tenant approval status:', approvalError);
            }
          }

          if (ownerOrgId) {
            const owners = await storage.getUsersByOrganization(ownerOrgId);
            const owner = owners.find(u => u.role === 'owner');

            if (owner && owner.email) {
              await sendInspectionCompleteEmail(
                owner.email,
                `${owner.firstName || ''} ${owner.lastName || ''}`.trim() || owner.email,
                {
                  type: inspection.type,
                  propertyName,
                  blockName,
                  inspectorName,
                  completedDate: updatedInspection.completedDate || new Date(),
                  inspectionId: inspection.id
                }
              );
            }
          }
        } catch (emailError) {
          console.error('Failed to send inspection complete email:', emailError);
        }
      }

      res.json(updatedInspection);
    } catch (error) {
      console.error("Error updating inspection:", error);
      res.status(500).json({ message: "Failed to update inspection" });
    }
  });

  app.patch("/api/inspections/:id/status", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { status } = req.body;

      // Get inspection details before updating
      const inspection = await storage.getInspection(id);
      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }

      // Handle credit consumption when inspection is completed/submitted
      let ownerOrgId: string | null = null;
      if (inspection.propertyId) {
        const property = await storage.getProperty(inspection.propertyId);
        ownerOrgId = property?.organizationId || null;
      } else if (inspection.blockId) {
        const block = await storage.getBlock(inspection.blockId);
        ownerOrgId = block?.organizationId || null;
      }

      // Note: "submitted" is not a valid status in the enum, only "completed" triggers credit consumption
      if (status === "completed" &&
        inspection.status !== "completed" &&
        !inspection.creditsConsumed && ownerOrgId) {
        // Check credits BEFORE allowing completion - this must succeed or block completion
        try {
          // Check credits BEFORE allowing completion
          const creditBalance = await storage.getCreditBalance(ownerOrgId);
          console.log(`[Update Status] Credit check for org ${ownerOrgId}: total=${creditBalance.total}`);
          
          // Get image count
          const imageCount = await storage.getInspectionImageCount(id);

          // Calculate credits needed (1 base + 1 per 250 images)
          const subscriptionService = (await import("./subscriptionService")).subscriptionService;
          const creditsNeeded = subscriptionService.calculateInspectionCredits(imageCount);
          console.log(`[Update Status] Credits needed: ${creditsNeeded} (images: ${imageCount})`);

          // Check if organization has sufficient credits BEFORE attempting to consume
          if (creditBalance.total < creditsNeeded) {
            console.log(`[Update Status] BLOCKED: Insufficient credits (${creditBalance.total} < ${creditsNeeded})`);
            return res.status(402).json({
              message: `No credits available for inspection. You need ${creditsNeeded} credits but only have ${creditBalance.total} available. Please subscribe to a plan to get inspection credits.`,
              error: "insufficient_credits"
            });
          }

          // Consume credits
          await subscriptionService.consumeInspectionCredits(ownerOrgId, creditsNeeded, id);

          // Update inspection with credit info
          await storage.updateInspection(id, {
            creditsConsumed: creditsNeeded,
            imagesCount: imageCount
          } as any);
        } catch (creditError: any) {
          console.error('[Update Status] Failed to check/consume credits:', creditError);
          // If insufficient credits or any credit-related error, block completion
          if (creditError.message.includes("Insufficient credits") || creditError.message.includes("No subscription found")) {
            return res.status(402).json({
              message: "No credits available for inspection. Please subscribe to a plan to get inspection credits.",
              error: "insufficient_credits"
            });
          }
          // For other errors, also block to be safe
          return res.status(402).json({
            message: "No credits available for inspection. Please subscribe to a plan to get inspection credits.",
            error: "insufficient_credits"
          });
        }
      }

      // Update status
      const updatedInspection = await storage.updateInspectionStatus(
        id,
        status,
        status === "completed" ? new Date() : undefined
      );

      // For check-in inspections, set tenant approval status and deadline when completed
      if (status === "completed" && inspection.type === "check_in" && inspection.propertyId) {
        try {
          // Get organization to get approval period
          let organizationId: string | undefined;
          if (inspection.propertyId) {
            const property = await storage.getProperty(inspection.propertyId);
            organizationId = property?.organizationId;
          } else if (inspection.blockId) {
            const block = await storage.getBlock(inspection.blockId);
            organizationId = block?.organizationId;
          }

          if (organizationId) {
            const organization = await storage.getOrganization(organizationId);
            const approvalPeriodDays = organization?.checkInApprovalPeriodDays ?? 5;
            const deadline = new Date();
            deadline.setDate(deadline.getDate() + approvalPeriodDays);

            await storage.updateInspection(id, {
              tenantApprovalStatus: "pending",
              tenantApprovalDeadline: deadline,
            } as any);
          }
        } catch (approvalError) {
          console.error('Failed to set tenant approval status:', approvalError);
        }
      }

      // Send email notification to owner when inspection is completed
      if (status === "completed") {
        try {
          // Get inspector details
          const inspector = await storage.getUser(inspection.inspectorId);
          const inspectorName = inspector ? `${inspector.firstName || ''} ${inspector.lastName || ''}`.trim() || inspector.username : 'Unknown Inspector';

          // Get property or block name
          let propertyName: string | undefined;
          let blockName: string | undefined;
          let organizationId: string | undefined;

          if (inspection.propertyId) {
            const property = await storage.getProperty(inspection.propertyId);
            propertyName = property?.name;
            organizationId = property?.organizationId;
          } else if (inspection.blockId) {
            const block = await storage.getBlock(inspection.blockId);
            blockName = block?.name;
            organizationId = block?.organizationId;
          }

          // For check-in inspections, set tenant approval status and deadline
          if (inspection.type === "check_in" && inspection.propertyId && organizationId) {
            try {
              const organization = await storage.getOrganization(organizationId);
              const approvalPeriodDays = organization?.checkInApprovalPeriodDays ?? 5;
              const deadline = new Date();
              deadline.setDate(deadline.getDate() + approvalPeriodDays);

              await storage.updateInspection(id, {
                tenantApprovalStatus: "pending",
                tenantApprovalDeadline: deadline,
              } as any);
            } catch (approvalError) {
              console.error('Failed to set tenant approval status:', approvalError);
            }
          }

          // Get organization owner's email
          if (organizationId) {
            const owners = await storage.getUsersByOrganization(organizationId);
            const owner = owners.find(u => u.role === 'owner');

            if (owner && owner.email) {
              await sendInspectionCompleteEmail(
                owner.email, // Email address
                `${owner.firstName || ''} ${owner.lastName || ''}`.trim() || owner.email,
                {
                  type: inspection.type,
                  propertyName,
                  blockName,
                  inspectorName,
                  completedDate: updatedInspection.completedDate || new Date(),
                  inspectionId: inspection.id
                }
              );
              console.log(`Inspection complete email sent to owner: ${owner.email}`);
            } else {
              console.warn('No owner found for organization or owner has no email:', organizationId);
            }
          }
        } catch (emailError) {
          // Log email error but don't fail the request
          console.error('Failed to send inspection complete email:', emailError);
        }
      }

      res.json(updatedInspection);
    } catch (error) {
      console.error("Error updating inspection status:", error);
      res.status(500).json({ message: "Failed to update inspection status" });
    }
  });

  // Delete inspection
  app.delete("/api/inspections/:id", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const inspection = await storage.getInspection(req.params.id);
      if (!inspection) {
        return res.status(404).json({ error: "Inspection not found" });
      }

      // Verify inspection belongs to user's organization
      if (inspection.propertyId) {
        const property = await storage.getProperty(inspection.propertyId);
        if (!property || property.organizationId !== user.organizationId) {
          return res.status(403).json({ error: "Access denied" });
        }
      } else if (inspection.blockId) {
        const block = await storage.getBlock(inspection.blockId);
        if (!block || block.organizationId !== user.organizationId) {
          return res.status(403).json({ error: "Access denied" });
        }
      }

      await storage.deleteInspection(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting inspection:", error);
      res.status(500).json({ error: "Failed to delete inspection" });
    }
  });

  // ==================== INSPECTION RESPONSE ROUTES ====================

  // Create or update inspection response
  app.post("/api/inspections/:inspectionId/responses", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify inspection exists
      const inspection = await storage.getInspection(req.params.inspectionId);
      if (!inspection) {
        return res.status(404).json({ error: "Inspection not found" });
      }

      // Verify inspection belongs to user's organization via property or block
      if (inspection.propertyId) {
        const property = await storage.getProperty(inspection.propertyId);
        if (!property || property.organizationId !== user.organizationId) {
          return res.status(403).json({ error: "Access denied" });
        }
      } else if (inspection.blockId) {
        const block = await storage.getBlock(inspection.blockId);
        if (!block || block.organizationId !== user.organizationId) {
          return res.status(403).json({ error: "Access denied" });
        }
      }

      // Prevent inspectionId override from request body
      const { inspectionId: _, ...safeBody } = req.body;
      const response = await storage.createInspectionResponse({
        ...safeBody,
        inspectionId: req.params.inspectionId,
      });

      res.json(response);
    } catch (error) {
      console.error("Error creating inspection response:", error);
      res.status(500).json({ error: "Failed to create inspection response" });
    }
  });

  // Get all responses for an inspection
  app.get("/api/inspections/:inspectionId/responses", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify inspection exists
      const inspection = await storage.getInspection(req.params.inspectionId);
      if (!inspection) {
        return res.status(404).json({ error: "Inspection not found" });
      }

      // Verify inspection belongs to user's organization via property or block
      if (inspection.propertyId) {
        const property = await storage.getProperty(inspection.propertyId);
        if (!property || property.organizationId !== user.organizationId) {
          return res.status(403).json({ error: "Access denied" });
        }
      } else if (inspection.blockId) {
        const block = await storage.getBlock(inspection.blockId);
        if (!block || block.organizationId !== user.organizationId) {
          return res.status(403).json({ error: "Access denied" });
        }
      }

      const responses = await storage.getInspectionResponses(req.params.inspectionId);
      res.json(responses);
    } catch (error) {
      console.error("Error fetching inspection responses:", error);
      res.status(500).json({ error: "Failed to fetch inspection responses" });
    }
  });

  // Update inspection response
  app.patch("/api/inspection-responses/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Get the response to find its inspection
      const existingResponse = await storage.getInspectionResponse(req.params.id);
      if (!existingResponse) {
        return res.status(404).json({ error: "Response not found" });
      }

      // Verify the inspection belongs to user's organization
      const inspection = await storage.getInspection(existingResponse.inspectionId);
      if (!inspection) {
        return res.status(404).json({ error: "Inspection not found" });
      }

      if (inspection.propertyId) {
        const property = await storage.getProperty(inspection.propertyId);
        if (!property || property.organizationId !== user.organizationId) {
          return res.status(403).json({ error: "Access denied" });
        }
      } else if (inspection.blockId) {
        const block = await storage.getBlock(inspection.blockId);
        if (!block || block.organizationId !== user.organizationId) {
          return res.status(403).json({ error: "Access denied" });
        }
      }

      // Prevent inspectionId changes in updates
      const { inspectionId: _, ...safeUpdates } = req.body;
      const updated = await storage.updateInspectionResponse(req.params.id, safeUpdates);
      res.json(updated);
    } catch (error) {
      console.error("Error updating inspection response:", error);
      res.status(500).json({ error: "Failed to update inspection response" });
    }
  });

  // Delete inspection response
  app.delete("/api/inspection-responses/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Get the response to find its inspection
      const existingResponse = await storage.getInspectionResponse(req.params.id);
      if (!existingResponse) {
        return res.status(404).json({ error: "Response not found" });
      }

      // Verify the inspection belongs to user's organization
      const inspection = await storage.getInspection(existingResponse.inspectionId);
      if (!inspection) {
        return res.status(404).json({ error: "Inspection not found" });
      }

      if (inspection.propertyId) {
        const property = await storage.getProperty(inspection.propertyId);
        if (!property || property.organizationId !== user.organizationId) {
          return res.status(403).json({ error: "Access denied" });
        }
      } else if (inspection.blockId) {
        const block = await storage.getBlock(inspection.blockId);
        if (!block || block.organizationId !== user.organizationId) {
          return res.status(403).json({ error: "Access denied" });
        }
      }

      await storage.deleteInspectionResponse(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting inspection response:", error);
      res.status(500).json({ error: "Failed to delete inspection response" });
    }
  });

  // ==================== INSPECTION ITEM ROUTES ====================

  app.post("/api/inspection-items", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const { inspectionId, category, itemName, photoUrl, conditionRating, notes } = req.body;

      if (!inspectionId || !category || !itemName) {
        return res.status(400).json({ message: "Inspection ID, category, and item name are required" });
      }

      const item = await storage.createInspectionItem({
        inspectionId,
        category,
        itemName,
        photoUrl: photoUrl || null,
        conditionRating: conditionRating || null,
        notes: notes || null,
      });

      console.log(`[POST /api/inspection-items] Created item:`, {
        id: item.id,
        inspectionId: item.inspectionId,
        category: item.category,
        itemName: item.itemName,
      });

      res.json(item);
    } catch (error) {
      console.error("Error creating inspection item:", error);
      res.status(500).json({ message: "Failed to create inspection item" });
    }
  });

  // ==================== AI ANALYSIS ROUTES ====================

  app.post("/api/ai/analyze-photo", isAuthenticated, async (req: any, res) => {
    try {
      // Validate request body
      const validation = analyzePhotoSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      const { itemId } = validation.data;

      // Get the inspection item
      const item = await storage.getInspectionItem(itemId);

      if (!item || !item.photoUrl) {
        return res.status(400).json({ message: "Inspection item not found or has no photo" });
      }

      // Get user and verify organization membership
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Verify the inspection item belongs to the user's organization
      const inspection = await storage.getInspection(item.inspectionId);
      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }

      // Check ownership via property OR block
      let ownerOrgId: string | null = null;

      if (inspection.propertyId) {
        const property = await storage.getProperty(inspection.propertyId);
        if (!property) {
          return res.status(404).json({ message: "Property not found" });
        }
        ownerOrgId = property.organizationId;
      } else if (inspection.blockId) {
        const block = await storage.getBlock(inspection.blockId);
        if (!block) {
          return res.status(404).json({ message: "Block not found" });
        }
        ownerOrgId = block.organizationId;
      } else {
        return res.status(400).json({ message: "Inspection has no property or block assigned" });
      }

      // Verify organization ownership
      if (ownerOrgId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied: Inspection item does not belong to your organization" });
      }

      // Check credits AFTER verifying ownership
      const creditBalance = await storage.getCreditBalance(user.organizationId);
      if (creditBalance.total < 1) {
        return res.status(402).json({ message: "Insufficient credits" });
      }

      // Convert photo to base64 data URL
      console.log("[Inspection Item Analysis] Converting photo to base64:", item.photoUrl);

      let photoUrl: string;
      if (item.photoUrl.startsWith("http")) {
        // External URL - use directly
        photoUrl = item.photoUrl;
      } else {
        // Internal object storage - convert to base64
        try {
          const objectStorageService = new ObjectStorageService();
          // Ensure path starts with /objects/
          const photoPath = item.photoUrl.startsWith('/objects/') ? item.photoUrl : `/objects/${item.photoUrl}`;
          const objectFile = await objectStorageService.getObjectEntityFile(photoPath);

          // Read the file contents using fs.readFile first
          const photoBuffer = await fs.readFile(objectFile.name);

          // Always detect MIME type from buffer for reliability
          let mimeType = detectImageMimeType(photoBuffer);

          // Get metadata for logging purposes
          const [metadata] = await objectFile.getMetadata();
          const metadataContentType = metadata.contentType;

          console.log(`[Inspection Item Analysis] MIME type detection:`, {
            detected: mimeType,
            fromMetadata: metadataContentType,
            bufferSize: photoBuffer.length,
          });

          // Ensure we have a valid image MIME type
          if (!mimeType || !mimeType.startsWith('image/')) {
            console.warn(`[Inspection Item Analysis] Invalid MIME type detected: ${mimeType}, defaulting to image/jpeg`);
            mimeType = 'image/jpeg';
          }

          // Convert to base64 data URL
          const base64Image = photoBuffer.toString('base64');
          photoUrl = `data:${mimeType};base64,${base64Image}`;

          console.log("[Inspection Item Analysis] Converted to base64 data URL:", photoPath, `(${mimeType})`);
        } catch (error: any) {
          // Safely log error without circular reference issues
          const errorMessage = error?.message || String(error);
          console.error("[Inspection Item Analysis] Error converting photo to base64:", {
            photoUrl: item.photoUrl,
            message: errorMessage,
            errorType: error?.constructor?.name,
          });
          if (error instanceof ObjectNotFoundError) {
            throw new Error(`Photo not found: ${item.photoUrl}. The file may have been deleted or moved.`);
          }
          throw new Error(`Failed to load photo for analysis: ${item.photoUrl}. ${errorMessage}`);
        }
      }

      // Call OpenAI Vision API using Responses API
      const response = await getOpenAI().responses.create({
        model: "gpt-5", // the newest OpenAI model is "gpt-5" which was released August 7, 2025. do not change this unless explicitly requested by the user
        input: [
          {
            role: "user",
            content: normalizeApiContent([
              {
                type: "text",
                text: `Analyze this ${item.category} - ${item.itemName} photo from a property inspection. Provide a detailed condition assessment including any damage, wear, cleanliness issues, or notable features. Be specific and objective.`
              },
              {
                type: "image_url",
                image_url: photoUrl
              }
            ])
          }
        ],
        max_output_tokens: 300,
      });

      let analysis = response.output_text || (response.output?.[0] as any)?.content?.[0]?.text || "Unable to analyze image";

      // Strip markdown asterisks from the response
      analysis = analysis.replace(/\*\*/g, '');

      // Update the item with AI analysis
      await storage.updateInspectionItemAI(itemId, analysis);

      // Consume credit using credit batch system
      const { subscriptionService } = await import("./subscriptionService");
      await subscriptionService.consumeCredits(
        user.organizationId,
        1,
        "inspection",
        item.inspectionId,
        `AI photo analysis: ${item.category} - ${item.itemName}`
      );

      res.json({ analysis });
    } catch (error: any) {
      // Safely log error without circular reference issues
      const errorMessage = error?.message || String(error);
      console.error("Error analyzing photo:", {
        message: errorMessage,
        status: error?.status,
        code: error?.code,
      });
      res.status(500).json({ message: "Failed to analyze photo" });
    }
  });

  // AI field-level inspection analysis
  app.post("/api/ai/inspect-field", isAuthenticated, async (req: any, res) => {
    try {
      // Validate request body
      const validation = inspectFieldSchema.safeParse(req.body);
      if (!validation.success) {
        console.error("[InspectAI] Validation failed:", validation.error.errors);
        console.error("[InspectAI] Request body:", req.body);
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      const { inspectionId, fieldKey, fieldLabel, fieldDescription, sectionName, photos } = validation.data;

      // Get user and verify organization membership
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Verify the inspection belongs to the user's organization
      const inspection = await storage.getInspection(inspectionId);
      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }

      // Check ownership via property OR block
      let ownerOrgId: string | null = null;

      if (inspection.propertyId) {
        const property = await storage.getProperty(inspection.propertyId);
        if (!property) {
          return res.status(404).json({ message: "Property not found" });
        }
        ownerOrgId = property.organizationId;
      } else if (inspection.blockId) {
        const block = await storage.getBlock(inspection.blockId);
        if (!block) {
          return res.status(404).json({ message: "Block not found" });
        }
        ownerOrgId = block.organizationId;
      } else {
        return res.status(400).json({ message: "Inspection has no property or block assigned" });
      }

      // Verify organization ownership
      if (ownerOrgId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied: Inspection does not belong to your organization" });
      }

      // Check credits (1 credit per field inspection)
      const creditBalance = await storage.getCreditBalance(user.organizationId);
      if (creditBalance.total < 1) {
        return res.status(402).json({ message: "Insufficient credits" });
      }

      // Construct image data URLs - download images and convert to base64
      const objectStorageService = new ObjectStorageService();
      const photoUrls = await Promise.all(photos.map(async (photo) => {
        // If already a full HTTP URL, use it directly
        if (photo.startsWith("http")) {
          return photo;
        }

        // If it's an /objects/ path, download the image and convert to base64 data URL
        try {
          // Ensure path starts with /objects/
          const photoPath = photo.startsWith('/objects/') ? photo : `/objects/${photo}`;
          const objectFile = await objectStorageService.getObjectEntityFile(photoPath);

          // Read the file contents using fs.readFile first
          const fileBuffer = await fs.readFile(objectFile.name);

          // Always detect MIME type from buffer for reliability
          let contentType = detectImageMimeType(fileBuffer);

          // Get metadata for logging purposes
          const [metadata] = await objectFile.getMetadata();
          const metadataContentType = metadata.contentType;

          console.log(`[InspectAI] MIME type detection:`, {
            detected: contentType,
            fromMetadata: metadataContentType,
            bufferSize: fileBuffer.length,
          });

          // Ensure we have a valid image MIME type
          if (!contentType || !contentType.startsWith('image/')) {
            console.warn(`[InspectAI] Invalid MIME type detected: ${contentType}, defaulting to image/jpeg`);
            contentType = 'image/jpeg';
          }

          // Convert to base64 data URL
          const base64Data = fileBuffer.toString('base64');
          const dataUrl = `data:${contentType};base64,${base64Data}`;

          console.log(`[InspectAI] Converted photo to base64 data URL: ${photoPath} (${contentType}, ${base64Data.length} bytes)`);
          return dataUrl;
        } catch (error: any) {
          // Safely log error without circular reference issues
          const errorMessage = error?.message || String(error);
          console.error("[InspectAI] Error converting photo to base64:", {
            photo,
            message: errorMessage,
            errorType: error?.constructor?.name,
          });
          if (error instanceof ObjectNotFoundError) {
            throw new Error(`Photo not found: ${photo}. The file may have been deleted or moved.`);
          }
          throw new Error(`Failed to load photo for analysis: ${photo}. ${errorMessage}`);
        }
      }));

      // Get template settings for AI configuration with proper inheritance:
      // Template settings > Organization defaults > System defaults
      let aiMaxWords: number;
      let aiInstruction: string;

      // Get organization for default settings
      const organization = await storage.getOrganization(user.organizationId);

      // Get template settings if available
      let templateAiMaxWords: number | null = null;
      let templateAiInstruction: string | null = null;

      if (inspection.templateId) {
        const template = await storage.getInspectionTemplate(inspection.templateId);
        if (template) {
          templateAiMaxWords = template.aiMaxWords;
          templateAiInstruction = template.aiInstruction || null;
        }
      }

      // Apply inheritance chain independently for each field:
      // aiMaxWords: template > organization > system default (150)
      aiMaxWords = templateAiMaxWords ?? organization?.defaultAiMaxWords ?? 150;

      // aiInstruction: template > organization > empty (use default prompt)
      aiInstruction = templateAiInstruction ?? organization?.defaultAiInstruction ?? "";

      // Build the prompt with explicit Category and Inspection Point context
      // sectionName = Category (e.g., "Kitchen", "Bathroom", "Living Room")
      // fieldLabel = Inspection Point Title (e.g., "Oven Condition", "Sink and Taps")
      let promptText: string;
      const category = sectionName || "General";
      const inspectionPointTitle = fieldLabel || "Item";

      if (aiInstruction) {
        // Use custom AI instruction from template or organization
        promptText = `${aiInstruction}

INSPECTION CONTEXT:
- Category: "${category}"
- Inspection Point: "${inspectionPointTitle}"`;
        if (fieldDescription) {
          promptText += `\n- Description: ${fieldDescription}`;
        }
        promptText += `

I have ${photoUrls.length} image(s) uploaded for this specific inspection point. Analyze ALL images in the context of "${inspectionPointTitle}" within the "${category}" category.

CRITICAL: The photo may show the entire ${category} area, but you MUST focus your analysis EXCLUSIVELY on "${inspectionPointTitle}". Do NOT describe or analyze any other elements visible in the photo.

IMPORTANT RULES:
- Keep your response under ${aiMaxWords} words
- Be concise and direct - no unnecessary explanations
- Write in plain text only - no markdown, asterisks, bullets, or emojis
- Recommendations must be brief and actionable`;
      } else {
        // Default prompt - highly focused on the specific inspection point
        promptText = `You are a property inspector analyzing photos for a specific inspection point.

INSPECTION CONTEXT:
- Category: "${category}"
- Inspection Point: "${inspectionPointTitle}"`;
        if (fieldDescription) {
          promptText += `\n- Description: ${fieldDescription}`;
        }
        promptText += `

CRITICAL: I have ${photoUrls.length} image(s) uploaded specifically for "${inspectionPointTitle}" in the "${category}". The photo may show the entire ${category} area, but you MUST focus your analysis EXCLUSIVELY on "${inspectionPointTitle}". Do NOT describe or analyze any other elements visible in the photo.

Provide a focused assessment for "${inspectionPointTitle}" covering:
1. Condition of "${inspectionPointTitle}" only
2. Any damage, defects, or wear specific to this item
3. Cleanliness issues (if applicable)
4. Brief recommendation (only if action needed for "${inspectionPointTitle}")

FORMATTING RULES:
- Maximum ${aiMaxWords} words
- Be direct and concise - avoid filler language
- Plain text only - no markdown, asterisks, bullets, numbered lists, or emojis
- Write professionally in flowing sentences
- Recommendations should be actionable and brief (e.g., "Recommend repainting" not "It would be advisable to consider having the area repainted at some point")

Remember: Only analyze "${inspectionPointTitle}" in the "${category}" - nothing else in the photo matters for this inspection point.`;
      }

      // Build content array with text and all images
      const content: any[] = [
        {
          type: "text",
          text: promptText
        }
      ];

      // Add all photos - use string format directly for normalizeApiContent
      photoUrls.forEach((url, index) => {
        content.push({
          type: "image_url",
          image_url: url // Pass as string, normalizeApiContent will handle it
        });
      });

      console.log("[InspectAI] Sending to OpenAI - Photo URLs:", photoUrls.length, "photos");
      console.log("[InspectAI] Content structure:", JSON.stringify(content.map(c => ({ type: c.type, hasUrl: !!c.image_url })), null, 2));

      // Retry logic for OpenAI API calls with exponential backoff
      const maxRetries = 3;
      const baseDelay = 1000; // 1 second base delay
      let lastError: any = null;
      let response: any = null;

      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          // Call OpenAI Vision API using Responses API
          // Set max_output_tokens to 10000 to allow for very detailed analysis
          response = await Promise.race([
            getOpenAI().responses.create({
              model: "gpt-5", // the newest OpenAI model is "gpt-5" which was released August 7, 2025. do not change this unless explicitly requested by the user
              input: [
                {
                  role: "user",
                  content: normalizeApiContent(content)
                }
              ],
              max_output_tokens: 10000, // Increased to 10000 to allow very detailed responses
            }),
            // Add timeout of 60 seconds
            new Promise((_, reject) => 
              setTimeout(() => reject(new Error("Request timeout: OpenAI API did not respond within 60 seconds")), 60000)
            )
          ]) as any;
          
          // Success - break out of retry loop
          break;
        } catch (error: any) {
          lastError = error;
          const errorMessage = error?.message || String(error);
          const isConnectionError = 
            errorMessage.includes("Connection error") ||
            errorMessage.includes("ECONNREFUSED") ||
            errorMessage.includes("ETIMEDOUT") ||
            errorMessage.includes("ENOTFOUND") ||
            errorMessage.includes("timeout") ||
            error?.code === "ECONNREFUSED" ||
            error?.code === "ETIMEDOUT";

          // Only retry on connection errors
          if (isConnectionError && attempt < maxRetries) {
            const delay = baseDelay * Math.pow(2, attempt - 1); // Exponential backoff: 1s, 2s, 4s
            console.warn(`[InspectAI] Connection error on attempt ${attempt}/${maxRetries}. Retrying in ${delay}ms...`, {
              error: errorMessage,
              attempt,
              maxRetries
            });
            await new Promise(resolve => setTimeout(resolve, delay));
            continue;
          } else {
            // Not a connection error or max retries reached - throw immediately
            throw error;
          }
        }
      }

      // If we still don't have a response after retries, throw the last error
      if (!response && lastError) {
        throw lastError;
      }

      // Check if response is incomplete due to token limit
      if (response.status === "incomplete") {
        const reason = response.incomplete_details?.reason;
        console.error("[InspectAI] Response is incomplete:", {
          reason,
          maxOutputTokens: response.max_output_tokens,
          outputTokens: response.usage?.output_tokens,
          reasoningTokens: response.usage?.output_tokens_details?.reasoning_tokens,
        });

        if (reason === "max_output_tokens") {
          // Return user-friendly message instead of throwing error
          return res.status(200).json({
            analysis: "Token limit exceeded. Please try again later.",
            tokenExceeded: true
          });
        } else {
          throw new Error(`The analysis response is incomplete: ${reason || "unknown reason"}. Please try again.`);
        }
      }

      const outputItem = response.output?.[0] as any;
      console.log("[InspectAI] OpenAI Response structure:", {
        status: response.status,
        hasOutputText: !!response.output_text,
        outputTextLength: response.output_text?.length || 0,
        hasOutput: !!response.output,
        outputLength: response.output?.length || 0,
        outputFirstItem: outputItem ? {
          type: outputItem.type,
          hasContent: !!outputItem.content,
          contentLength: outputItem.content?.length || 0,
          firstContentType: outputItem.content?.[0]?.type,
          firstContentText: outputItem.content?.[0]?.text?.substring(0, 100) || 'N/A'
        } : null,
      });

      // Try multiple ways to extract the analysis text
      let analysis = "";

      // Method 1: Direct output_text (most common)
      if (response.output_text && response.output_text.trim().length > 0) {
        analysis = response.output_text;
        console.log("[InspectAI] Using output_text");
      }
      // Method 2: output[0].content[0].text
      else if (outputItem?.content?.[0]?.text) {
        analysis = outputItem.content[0].text;
        console.log("[InspectAI] Using output[0].content[0].text");
      }
      // Method 3: Check for text type in output array
      else if (response.output) {
        // Look for any output item with text content
        for (const item of response.output) {
          const typedItem = item as any;
          if (typedItem.type === "text" && typedItem.text) {
            analysis = typedItem.text;
            console.log("[InspectAI] Using output item with type 'text'");
            break;
          }
          if (typedItem.content) {
            for (const contentItem of typedItem.content) {
              if (contentItem.type === "text" && contentItem.text) {
                analysis = contentItem.text;
                console.log("[InspectAI] Using content item with type 'text'");
                break;
              }
            }
            if (analysis) break;
          }
        }
      }
      // Method 4: Check response directly
      else if (typeof response === 'string') {
        analysis = response;
        console.log("[InspectAI] Response is a string");
      }

      // Validate we got analysis text
      if (!analysis || analysis.trim().length === 0) {
        console.error("[InspectAI] Analysis text is empty. Response:", JSON.stringify(response, null, 2));
        throw new Error("OpenAI API returned an empty analysis. The response may have been incomplete. Please try again.");
      }

      // Strip forbidden characters from the response:
      // - Remove all asterisks (*, **)
      // - Remove all hash symbols (#)
      // - Remove emojis
      analysis = analysis
        .replace(/\*+/g, '') // Remove asterisks
        .replace(/#+/g, '') // Remove hash symbols
        // Remove emojis (simplified approach for compatibility)
        .replace(/([\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2580-\u27BF]|\uD83E[\uDD10-\uDDFF])/g, '') // Remove emojis using Unicode property escapes
        .replace(/\n{3,}/g, '\n\n') // Collapse multiple newlines
        .trim();

      // Consume credit using credit batch system
      const { subscriptionService } = await import("./subscriptionService");
      await subscriptionService.consumeCredits(
        user.organizationId,
        1,
        "inspection",
        inspectionId,
        `InspectAI field analysis: ${fieldLabel}`
      );

      res.json({ analysis });
    } catch (error: any) {
      // Safely log error without circular reference issues
      const errorMessage = error?.message || String(error);
      const errorStack = error?.stack;
      console.error("Error analyzing field:", {
        message: errorMessage,
        stack: errorStack?.substring(0, 500), // Limit stack trace length
        status: error?.status,
        code: error?.code,
        type: error?.type,
        param: error?.param,
      });

      // Return more specific error message
      const isConnectionError = 
        errorMessage.includes("Connection error") ||
        errorMessage.includes("ECONNREFUSED") ||
        errorMessage.includes("ETIMEDOUT") ||
        errorMessage.includes("ENOTFOUND") ||
        errorMessage.includes("timeout") ||
        error?.code === "ECONNREFUSED" ||
        error?.code === "ETIMEDOUT";

      const userMessage = isConnectionError
        ? "Unable to connect to AI service. Please check your internet connection and try again."
        : errorMessage.includes("OpenAI")
          ? "AI service returned an error. Please try again."
          : errorMessage.includes("credits")
            ? "Insufficient credits for AI analysis"
            : errorMessage.includes("unexpected response format") || errorMessage.includes("empty analysis")
              ? "AI service returned an invalid response. Please try again."
              : "Failed to analyze field. Please try again.";

      res.status(500).json({ message: userMessage });
    }
  });

  // Full inspection AI analysis - analyzes all fields with photos in background
  app.post("/api/ai/analyze-inspection/:inspectionId", isAuthenticated, async (req: any, res) => {
    try {
      const { inspectionId } = req.params;

      // Get user and verify organization membership
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Verify the inspection exists and belongs to user's organization
      const inspection = await storage.getInspection(inspectionId);
      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }

      // Check ownership via property OR block
      let ownerOrgId: string | null = null;
      if (inspection.propertyId) {
        const property = await storage.getProperty(inspection.propertyId);
        if (!property) {
          return res.status(404).json({ message: "Property not found" });
        }
        ownerOrgId = property.organizationId;
      } else if (inspection.blockId) {
        const block = await storage.getBlock(inspection.blockId);
        if (!block) {
          return res.status(404).json({ message: "Block not found" });
        }
        ownerOrgId = block.organizationId;
      } else {
        return res.status(400).json({ message: "Inspection has no property or block assigned" });
      }

      if (ownerOrgId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Check if already processing
      if (inspection.aiAnalysisStatus === "processing") {
        return res.status(409).json({
          message: "AI analysis is already in progress for this inspection",
          status: "processing",
          progress: inspection.aiAnalysisProgress || 0,
          totalFields: inspection.aiAnalysisTotalFields || 0
        });
      }

      // Get all inspection entries with photos
      const entries = await storage.getInspectionEntries(inspectionId);
      const entriesWithPhotos = entries.filter((e: any) => e.photos && e.photos.length > 0);

      if (entriesWithPhotos.length === 0) {
        return res.status(400).json({ message: "No photos found in inspection entries to analyze" });
      }

      // Get organization for credits check
      const creditBalance = await storage.getCreditBalance(user.organizationId);
      if (creditBalance.total < entriesWithPhotos.length) {
        return res.status(402).json({
          message: `Insufficient credits. You need ${entriesWithPhotos.length} credits but have ${creditBalance.total}`
        });
      }

      // Update inspection status to processing
      await storage.updateInspection(inspectionId, {
        aiAnalysisStatus: "processing",
        aiAnalysisProgress: 0,
        aiAnalysisTotalFields: entriesWithPhotos.length,
        aiAnalysisError: null
      } as any);

      // Get organization for background processing
      const organization = await storage.getOrganization(user.organizationId);

      // Start background processing (fire and forget)
      processInspectionAIAnalysis(
        inspectionId,
        entriesWithPhotos,
        inspection,
        organization,
        user.organizationId
      ).catch((error) => {
        console.error("[FullInspectAI] Background processing failed:", error);
        // Update status to failed
        storage.updateInspection(inspectionId, {
          aiAnalysisStatus: "failed",
          aiAnalysisError: error.message || "Unknown error occurred"
        } as any).catch(console.error);
      });

      // Return immediately with job started message
      res.json({
        message: "AI analysis started in background. You can continue working and check back later.",
        status: "processing",
        totalFields: entriesWithPhotos.length
      });

    } catch (error: any) {
      console.error("[FullInspectAI] Error starting analysis:", error);
      res.status(500).json({ message: error.message || "Failed to start AI analysis" });
    }
  });

  // Get AI analysis status for an inspection
  app.get("/api/ai/analyze-inspection/:inspectionId/status", isAuthenticated, async (req: any, res) => {
    try {
      const { inspectionId } = req.params;

      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const inspection = await storage.getInspection(inspectionId);
      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }

      res.json({
        status: inspection.aiAnalysisStatus || "idle",
        progress: inspection.aiAnalysisProgress || 0,
        totalFields: inspection.aiAnalysisTotalFields || 0,
        error: inspection.aiAnalysisError || null
      });
    } catch (error: any) {
      console.error("[FullInspectAI] Error getting status:", error);
      res.status(500).json({ message: "Failed to get analysis status" });
    }
  });

  // AI-powered condition and cleanliness suggestion for Check-Out inspections
  app.post("/api/ai/suggest-condition", isAuthenticated, async (req: any, res) => {
    try {
      const { photoUrl, fieldLabel, sectionName } = req.body;

      if (!photoUrl) {
        return res.status(400).json({ message: "Photo URL is required" });
      }

      // Get user and verify organization membership
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Check credits
      const creditBalance = await storage.getCreditBalance(user.organizationId);
      if (creditBalance.total < 1) {
        return res.status(402).json({ message: "Insufficient credits" });
      }

      // Convert photo to base64 if it's from object storage
      let imageUrl: string;
      if (photoUrl.startsWith("http") || photoUrl.startsWith("data:")) {
        imageUrl = photoUrl;
      } else {
        try {
          const objectStorageService = new ObjectStorageService();
          const photoPath = photoUrl.startsWith('/objects/') ? photoUrl : `/objects/${photoUrl}`;
          const objectFile = await objectStorageService.getObjectEntityFile(photoPath);
          const photoBuffer = await fs.readFile(objectFile.name);
          let mimeType = detectImageMimeType(photoBuffer);
          if (!mimeType || !mimeType.startsWith('image/')) {
            mimeType = 'image/jpeg';
          }
          const base64Image = photoBuffer.toString('base64');
          imageUrl = `data:${mimeType};base64,${base64Image}`;
        } catch (error: any) {
          console.error("[AI Suggest Condition] Error loading photo:", error.message);
          return res.status(400).json({ message: "Failed to load photo for analysis" });
        }
      }

      // Call OpenAI Vision API for condition/cleanliness analysis
      const response = await getOpenAI().responses.create({
        model: "gpt-5",
        input: [
          {
            role: "user",
            content: normalizeApiContent([
              {
                type: "text",
                text: `You are a property inspection assistant. Analyze this photo of "${fieldLabel || 'an item'}" in the "${sectionName || 'property'}" area.

Based on the visible condition and cleanliness of the item/area in this photo, provide your assessment.

You MUST respond with ONLY a valid JSON object in this exact format, with no additional text:
{
  "condition": "Excellent" | "Good" | "Fair" | "Poor",
  "cleanliness": "Excellent" | "Good" | "Fair" | "Poor" | "Very Poor",
  "confidence": "high" | "medium" | "low",
  "notes": "Brief explanation of your assessment"
}

Condition guidelines:
- Excellent: Like new, no visible wear, damage, or defects
- Good: Minor wear consistent with age, no significant damage
- Fair: Noticeable wear, minor damage or repairs needed
- Poor: Significant damage, major repairs or replacement needed

Cleanliness guidelines:
- Excellent: Spotless, no visible dirt, dust, or stains
- Good: Very clean with minimal dust or marks
- Fair: Some dust, minor marks, or light soiling visible
- Poor: Noticeable soiling, stains, or buildup needing cleaning
- Very Poor: Heavy soiling, significant stains, or buildup requiring deep cleaning`
              },
              {
                type: "image_url",
                image_url: imageUrl
              }
            ])
          }
        ],
        max_output_tokens: 200,
      });

      let responseText = response.output_text || (response.output?.[0] as any)?.content?.[0]?.text || "";

      // Parse the JSON response
      let suggestion: { condition?: string; cleanliness?: string; confidence?: string; notes?: string } = {};
      try {
        // Extract JSON from response (handle markdown code blocks)
        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          suggestion = JSON.parse(jsonMatch[0]);
        }
      } catch (parseError) {
        console.error("[AI Suggest Condition] Failed to parse AI response:", responseText);
        suggestion = {
          condition: "Good",
          cleanliness: "Clean",
          confidence: "low",
          notes: "AI analysis inconclusive, please review manually"
        };
      }

      // Validate the response values
      const validConditions = ["Excellent", "Good", "Fair", "Poor"];
      const validCleanliness = ["Excellent", "Good", "Fair", "Poor", "Very Poor"];

      if (!validConditions.includes(suggestion.condition || "")) {
        suggestion.condition = "Good";
      }
      if (!validCleanliness.includes(suggestion.cleanliness || "")) {
        suggestion.cleanliness = "Good";
      }

      // Deduct credit (0.5 credit for quick analysis, but charge 1 minimum)
      // Consume credit using credit batch system
      const { subscriptionService } = await import("./subscriptionService");
      await subscriptionService.consumeCredits(
        user.organizationId,
        1,
        "ai_analysis",
        `condition_suggestion_${Date.now()}`,
        `AI condition suggestion: ${fieldLabel || 'Field analysis'}`
      );

      console.log("[AI Suggest Condition] Analysis complete:", {
        fieldLabel,
        condition: suggestion.condition,
        cleanliness: suggestion.cleanliness,
        confidence: suggestion.confidence,
      });

      res.json(suggestion);
    } catch (error: any) {
      console.error("[AI Suggest Condition] Error:", error.message);
      res.status(500).json({ message: "Failed to analyze photo" });
    }
  });

  // Get matching Check-In inspection for reference during Check-Out
  app.get("/api/inspections/:id/check-in-reference", isAuthenticated, async (req: any, res) => {
    try {
      const { id: checkOutInspectionId } = req.params;

      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Get the current inspection (should be check-out)
      const currentInspection = await storage.getInspection(checkOutInspectionId);
      if (!currentInspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }

      // Verify ownership
      let ownerOrgId: string | null = null;
      if (currentInspection.propertyId) {
        const property = await storage.getProperty(currentInspection.propertyId);
        if (!property) {
          return res.status(404).json({ message: "Property not found" });
        }
        ownerOrgId = property.organizationId;
      } else if (currentInspection.blockId) {
        const block = await storage.getBlock(currentInspection.blockId);
        if (!block) {
          return res.status(404).json({ message: "Block not found" });
        }
        ownerOrgId = block.organizationId;
      }

      if (ownerOrgId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Only return check-in reference if current inspection is check-out
      if (currentInspection.type !== "check_out") {
        return res.json({ checkInInspection: null, checkInEntries: [] });
      }

      // Find the most recent completed check-in for the same property
      if (!currentInspection.propertyId) {
        return res.json({ checkInInspection: null, checkInEntries: [] });
      }

      const allInspections = await storage.getInspectionsByOrganization(user.organizationId);
      const checkInInspections = allInspections
        .filter((i: any) =>
          i.propertyId === currentInspection.propertyId &&
          i.type === "check_in" &&
          i.status === "completed"
        )
        .sort((a: any, b: any) =>
          new Date(b.completedDate || b.scheduledDate).getTime() -
          new Date(a.completedDate || a.scheduledDate).getTime()
        );

      if (checkInInspections.length === 0) {
        return res.json({ checkInInspection: null, checkInEntries: [] });
      }

      const checkInInspection = checkInInspections[0];
      const checkInEntries = await storage.getInspectionEntries(checkInInspection.id);

      // Map entries to include fieldRef (for frontend compatibility) and apply field key mapping
      const mappedCheckInEntries = checkInEntries.map((entry: any) => ({
        ...entry,
        fieldRef: entry.fieldKey, // Add fieldRef as alias for fieldKey
      }));

      res.json({
        checkInInspection,
        checkInEntries: mappedCheckInEntries
      });
    } catch (error) {
      console.error("Error fetching check-in reference:", error);
      res.status(500).json({ message: "Failed to fetch check-in reference" });
    }
  });

  // Auto-create comparison report for a property (finds last check-in and check-out)
  app.post("/api/comparison-reports/auto", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const { propertyId, checkOutInspectionId, fieldKey } = req.body;

      if (!propertyId) {
        return res.status(400).json({ message: "Property ID is required" });
      }

      // Store context for potential future use (e.g., auto-scrolling to the field)
      const context = { checkOutInspectionId, fieldKey };

      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Verify property ownership
      const property = await storage.getProperty(propertyId);
      if (!property || property.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Not authorized to access this property" });
      }

      // Check if a comparison report already exists for this property
      const existingReports = await storage.getComparisonReportsByProperty(propertyId);
      if (existingReports && existingReports.length > 0) {
        // Return the most recent report
        const latestReport = existingReports.sort((a: any, b: any) =>
          new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        )[0];
        return res.json({ report: latestReport, created: false });
      }

      // Get all inspections for this property
      const allInspections = await storage.getInspectionsByOrganization(user.organizationId);
      const propertyInspections = allInspections.filter((i: any) => i.propertyId === propertyId);

      // Find the most recent completed check-in and check-out inspections
      const checkInInspections = propertyInspections
        .filter((i: any) => i.type === "check_in" && i.status === "completed")
        .sort((a: any, b: any) => new Date(b.completedDate || b.scheduledDate).getTime() - new Date(a.completedDate || a.scheduledDate).getTime());

      const checkOutInspections = propertyInspections
        .filter((i: any) => i.type === "check_out" && i.status === "completed")
        .sort((a: any, b: any) => new Date(b.completedDate || b.scheduledDate).getTime() - new Date(a.completedDate || a.scheduledDate).getTime());

      if (checkInInspections.length === 0) {
        return res.status(400).json({ message: "No completed check-in inspection found for this property" });
      }

      if (checkOutInspections.length === 0) {
        return res.status(400).json({ message: "No completed check-out inspection found for this property" });
      }

      const lastCheckIn = checkInInspections[0];
      const lastCheckOut = checkOutInspections[0];

      // Get tenant assigned to property (optional - may be null for vacant units)
      const tenantAssignments = await storage.getTenantAssignmentsByProperty(propertyId, user.organizationId);
      const activeTenant = tenantAssignments.find(ta => ta.assignment?.isActive);

      // Check credits (2 credits for comparison report generation)
      const creditBalance = await storage.getCreditBalance(user.organizationId);
      if (creditBalance.total < 2) {
        return res.status(402).json({ message: "Insufficient credits (2 required for comparison report)" });
      }

      // Get inspection entries marked for review from check-out inspection
      const checkOutEntries = await storage.getInspectionEntries(lastCheckOut.id);
      const markedEntries = checkOutEntries.filter(entry => entry.markedForReview);

      if (markedEntries.length === 0) {
        return res.status(400).json({ message: "No inspection entries marked for review. Please mark items for review during check-out inspection." });
      }

      // Get all check-in entries for matching
      const checkInEntries = await storage.getInspectionEntries(lastCheckIn.id);

      const tenantId = activeTenant?.id || null;
      console.log(`[Auto-Create Comparison] Creating report for property ${propertyId}`, {
        checkInId: lastCheckIn.id,
        checkOutId: lastCheckOut.id,
        hasTenant: !!activeTenant,
        tenantId: tenantId
      });

      // Create comparison report (tenant may be null for vacant units)
      const report = await storage.createComparisonReport({
        organizationId: user.organizationId,
        propertyId,
        checkInInspectionId: lastCheckIn.id,
        checkOutInspectionId: lastCheckOut.id,
        tenantId: tenantId,
        status: "draft",
        totalEstimatedCost: "0",
        aiAnalysisJson: { summary: "Processing...", items: [] },
        generatedBy: user.id,
      });

      // Create notification for tenant if property has an active tenant
      if (activeTenant?.id) {
        try {
          const { sendNotificationToUser } = await import("./websocket");
          const notification = await storage.createNotification({
            userId: activeTenant.id,
            organizationId: user.organizationId,
            type: "comparison_report_created",
            title: "New Comparison Report Available",
            message: `A new comparison report has been created for your property. Click to view details.`,
            data: {
              reportId: report.id,
              propertyId: propertyId,
              propertyName: property.name,
            },
          });

          // Send real-time notification via WebSocket
          sendNotificationToUser(activeTenant.id, {
            id: notification.id,
            userId: notification.userId,
            organizationId: notification.organizationId,
            type: notification.type,
            title: notification.title,
            message: notification.message,
            data: notification.data,
            isRead: notification.isRead,
            createdAt: notification.createdAt || new Date(),
          });
        } catch (notifError) {
          console.error("[Notification] Error creating notification for tenant:", notifError);
          // Don't fail the request if notification fails
        }
      } else {
        console.log(`[Notification] No active tenant found for property ${propertyId}. Tenant assignments:`, tenantAssignments.map(ta => ({ id: ta.id, isActive: ta.assignment?.isActive })));
      }

      // Store organizationId for use in async function (guaranteed to exist due to check above)
      const organizationId: string = user.organizationId!;

      // Process marked entries asynchronously (same logic as the regular endpoint)
      (async () => {
        try {
          let totalCost = 0;
          const itemAnalyses: any[] = [];

          for (const checkOutEntry of markedEntries) {
            // Use normalized matching to handle variations in sectionRef naming
            // and map field keys between check-in and check-out templates
            const checkInEntry = checkInEntries.find(
              e => sectionRefsMatch(e.sectionRef, checkOutEntry.sectionRef) &&
                fieldKeysMatch(e.fieldKey, checkOutEntry.fieldKey)
            );

            let aiComparison: any = { summary: "No images to compare" };
            let estimatedCost = 0;
            let depreciation = 0;

            // Extract condition/cleanliness from valueJson for both entries (always, regardless of photos)
            const parseConditionCleanliness = (entry: any) => {
              if (!entry?.valueJson) return { condition: null, cleanliness: null };
              try {
                const valueJson = typeof entry.valueJson === 'string'
                  ? JSON.parse(entry.valueJson)
                  : entry.valueJson;
                return {
                  condition: valueJson?.condition || null,
                  cleanliness: valueJson?.cleanliness || null,
                };
              } catch {
                return { condition: null, cleanliness: null };
              }
            };

            const checkInRatings = parseConditionCleanliness(checkInEntry);
            const checkOutRatings = parseConditionCleanliness(checkOutEntry);

            if (checkOutEntry.photos && checkOutEntry.photos.length > 0) {
              try {
                const checkInPhotos = checkInEntry?.photos || [];
                const checkOutPhotos = checkOutEntry.photos || [];

                const imageContent: any[] = [];

                if (checkInPhotos.length > 0) {
                  imageContent.push({
                    type: "text",
                    text: "CHECK-IN PHOTOS (baseline condition):"
                  });
                  checkInPhotos.slice(0, 2).forEach((url) => {
                    imageContent.push({
                      type: "image_url",
                      image_url: { url, detail: "high" }
                    });
                  });
                }

                imageContent.push({
                  type: "text",
                  text: "CHECK-OUT PHOTOS (current condition):"
                });
                checkOutPhotos.slice(0, 2).forEach((url) => {
                  imageContent.push({
                    type: "image_url",
                    image_url: { url, detail: "high" }
                  });
                });

                // Get notes from both inspections for comparison
                const checkInNote = checkInEntry?.note || "";
                const checkOutNote = checkOutEntry.note || "";

                let prompt = `You are a professional BTR property inspector. Compare check-in vs check-out photos and provide a DETAILED analysis.

CRITICAL: Your SUMMARY must be EXACTLY 100 words (count them). This is mandatory for legal documentation.

ANALYSIS REQUIREMENTS:
- Compare baseline (check-in) condition to current (check-out) condition
- Identify ALL damage: scratches, stains, dents, tears, discoloration, wear patterns
- Note specific locations: "top left corner", "center panel", "near door handle"
- Distinguish fair wear (gradual fading, minor scuffs) from tenant damage (burns, holes, excessive staining)
- Consider age and expected condition for this property type
- Consider both visual evidence from photos AND written notes from inspectors`;

                if (checkInNote || checkOutNote) {
                  prompt += `\n\nCHECK-IN NOTES (baseline condition):\n${checkInNote || "No notes provided"}\n\nCHECK-OUT NOTES (current condition):\n${checkOutNote || "No notes provided"}`;
                }

                prompt += `\n\nRESPONSE FORMAT (use EXACTLY this structure):
SUMMARY: [Write EXACTLY 100 words. Describe: 1) Overall condition change (considering both photos and notes), 2) Specific damage locations and types, 3) Whether damage exceeds fair wear, 4) Evidence supporting your assessment. Be detailed and specific.]
SEVERITY: [low/medium/high]
DAMAGE: [1-2 sentence damage summary]
COST: [number in GBP, 0 if acceptable]
ACTION: [acceptable/clean/repair/replace]
LIABILITY: [tenant/landlord/shared]`;

                // If both notes exist, also request notes comparison
                if (checkInNote && checkOutNote) {
                  prompt += `\n\nNOTES_COMPARISON: [Compare the check-in and check-out notes in detail. Identify: 1) Items that were in good condition at check-in but are now broken, damaged, or missing at check-out, 2) New damage, issues, or problems that appeared at check-out that were NOT mentioned at check-in, 3) Any items that were damaged at check-in but are now repaired or improved, 4) Changes in condition descriptions, 5) Specific discrepancies. Focus on actionable differences and tenant liability. Write 100-150 words.]`;
                }

                imageContent.unshift({
                  type: "text",
                  text: prompt
                });

                const visionResponse = await getOpenAI().responses.create({
                  model: "gpt-5", // the newest OpenAI model is "gpt-5" which was released August 7, 2025. do not change this unless explicitly requested by the user
                  input: [{ role: "user", content: normalizeApiContent(imageContent) }],
                  max_output_tokens: 800,
                });

                const analysis = visionResponse.output_text || (visionResponse.output?.[0] as any)?.content?.[0]?.text || "";

                // Parse structured response
                const costMatch = analysis.match(/COST:\s*Â£?(\d+)/i) || analysis.match(/COST:\s*(\d+)/i);
                const severityMatch = analysis.match(/SEVERITY:\s*(low|medium|high)/i);
                const actionMatch = analysis.match(/ACTION:\s*(acceptable|clean|repair|replace)/i);
                const liabilityMatch = analysis.match(/LIABILITY:\s*(tenant|landlord|shared)/i);
                const summaryMatch = analysis.match(/SUMMARY:\s*([\s\S]+?)(?=\n(?:SEVERITY|DAMAGE|COST|ACTION|LIABILITY|NOTES_COMPARISON):|$)/i);
                const damageMatch = analysis.match(/DAMAGE:\s*([\s\S]+?)(?=\n(?:COST|ACTION|LIABILITY|NOTES_COMPARISON):|$)/i);
                // Try to match NOTES_COMPARISON - it might be at the end or in the middle
                const notesComparisonMatch = analysis.match(/NOTES_COMPARISON:\s*([\s\S]+?)(?=\n(?:SUMMARY|SEVERITY|DAMAGE|COST|ACTION|LIABILITY):|$)/i) ||
                  analysis.match(/NOTES_COMPARISON:\s*([\s\S]+)$/i);

                estimatedCost = costMatch ? parseInt(costMatch[1]) : 0;

                aiComparison = {
                  summary: summaryMatch ? summaryMatch[1].trim() : analysis.replace(/\*\*/g, ''),
                  differences: summaryMatch ? summaryMatch[1].trim() : analysis.replace(/\*\*/g, ''),
                  damage: damageMatch ? damageMatch[1].trim() : null,
                  severity: severityMatch ? severityMatch[1].toLowerCase() : "medium",
                  action: actionMatch ? actionMatch[1].toLowerCase() : "review",
                  suggestedLiability: liabilityMatch ? liabilityMatch[1].toLowerCase() : "tenant",
                  checkInPhotos,
                  checkOutPhotos,
                  estimatedCost,
                  checkInNote: checkInNote,
                  checkOutNote: checkOutNote,
                };

                // Extract notes_comparison if present in response
                if (notesComparisonMatch && notesComparisonMatch[1]) {
                  aiComparison.notes_comparison = notesComparisonMatch[1].trim();
                  console.log(`[ComparisonReport] Extracted notes_comparison from auto-create response (length: ${aiComparison.notes_comparison.length})`);
                } else if (checkInNote && checkOutNote) {
                  // If notes_comparison wasn't in the response, generate it separately
                  console.log(`[ComparisonReport] notes_comparison not found in auto-create response, will generate separately if needed`);
                }

              } catch (visionError) {
                console.error("Vision API error:", visionError);
                aiComparison = { summary: "Error analyzing images", error: true };
              }
            }

            // Always add condition/cleanliness data to aiComparison (regardless of photos)
            aiComparison.checkInCondition = checkInRatings.condition;
            aiComparison.checkOutCondition = checkOutRatings.condition;
            aiComparison.checkInCleanliness = checkInRatings.cleanliness;
            aiComparison.checkOutCleanliness = checkOutRatings.cleanliness;

            const finalCost = Math.max(0, estimatedCost - depreciation);
            totalCost += finalCost;

            await storage.createComparisonReportItem({
              comparisonReportId: report.id,
              checkInEntryId: checkInEntry?.id || null,
              checkOutEntryId: checkOutEntry.id,
              sectionRef: checkOutEntry.sectionRef,
              itemRef: checkOutEntry.itemRef || null,
              fieldKey: checkOutEntry.fieldKey,
              aiComparisonJson: aiComparison,
              estimatedCost: estimatedCost.toString(),
              depreciation: depreciation.toString(),
              finalCost: finalCost.toString(),
            });

            itemAnalyses.push({
              sectionRef: checkOutEntry.sectionRef,
              fieldKey: checkOutEntry.fieldKey,
              analysis: aiComparison.summary,
              cost: finalCost
            });
          }

          await storage.updateComparisonReport(report.id, {
            totalEstimatedCost: totalCost.toString(),
            aiAnalysisJson: {
              summary: `Comparison complete. ${markedEntries.length} items analyzed. Total estimated cost: Â£${totalCost}`,
              items: itemAnalyses
            }
          });

          // Consume credits using credit batch system
          const { subscriptionService } = await import("./subscriptionService");
          // report.id is guaranteed to exist since report was just created above
          const reportId: string = report.id || `comparison_${Date.now()}`;
          await subscriptionService.consumeCredits(
            organizationId, // Use the stored organizationId from outer scope
            2,
            "comparison",
            reportId,
            `Comparison report generation for property`
          );

        } catch (asyncError) {
          console.error("Error in async comparison processing:", asyncError);
        }
      })();

      res.json({ report, created: true });
    } catch (error) {
      console.error("Error auto-creating comparison report:", error);
      res.status(500).json({ message: "Failed to auto-create comparison report" });
    }
  });

  // Generate comparison report from check-out inspection (comprehensive version with liability assessment)
  app.post("/api/comparison-reports", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      // Validate request body
      const validation = generateComparisonSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      const { propertyId, checkInInspectionId, checkOutInspectionId } = validation.data;

      // Check user authorization
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Verify property ownership
      const property = await storage.getProperty(propertyId);
      if (!property || property.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Not authorized to access this property" });
      }

      // Get tenant assigned to property (optional - may be null for vacant units)
      const tenantAssignments = await storage.getTenantAssignmentsByProperty(propertyId, user.organizationId);
      const activeTenant = tenantAssignments.find(ta => ta.assignment?.isActive);

      // Check credits (2 credits for comparison report generation)
      const creditBalance = await storage.getCreditBalance(user.organizationId);
      if (creditBalance.total < 2) {
        return res.status(402).json({ message: "Insufficient credits (2 required for comparison report)" });
      }

      // Get inspection entries marked for review from check-out inspection
      const checkOutEntries = await storage.getInspectionEntries(checkOutInspectionId);
      const markedEntries = checkOutEntries.filter(entry => entry.markedForReview);

      if (markedEntries.length === 0) {
        return res.status(400).json({ message: "No inspection entries marked for review. Please mark items for review during check-out inspection." });
      }

      // Get all check-in entries for matching
      const checkInEntries = await storage.getInspectionEntries(checkInInspectionId);

      const tenantId = activeTenant?.id || null;
      console.log(`[Manual Create Comparison] Creating report for property ${propertyId}`, {
        checkInInspectionId,
        checkOutInspectionId,
        hasTenant: !!activeTenant,
        tenantId: tenantId
      });

      // Create comparison report (tenant may be null for vacant units)
      const report = await storage.createComparisonReport({
        organizationId: user.organizationId,
        propertyId,
        checkInInspectionId,
        checkOutInspectionId,
        tenantId: tenantId,
        status: "draft",
        totalEstimatedCost: "0",
        aiAnalysisJson: { summary: "Processing...", items: [] },
        generatedBy: user.id,
      });

      // Create notification for tenant if property has an active tenant
      if (activeTenant?.id) {
        try {
          const { sendNotificationToUser } = await import("./websocket");
          const notification = await storage.createNotification({
            userId: activeTenant.id,
            organizationId: user.organizationId,
            type: "comparison_report_created",
            title: "New Comparison Report Available",
            message: `A new comparison report has been created for your property. Click to view details.`,
            data: {
              reportId: report.id,
              propertyId: propertyId,
              propertyName: property.name,
            },
          });

          // Send real-time notification via WebSocket
          sendNotificationToUser(activeTenant.id, {
            id: notification.id,
            userId: notification.userId,
            organizationId: notification.organizationId,
            type: notification.type,
            title: notification.title,
            message: notification.message,
            data: notification.data,
            isRead: notification.isRead,
            createdAt: notification.createdAt || new Date(),
          });
        } catch (notifError) {
          console.error("[Notification] Error creating notification for tenant:", notifError);
          // Don't fail the request if notification fails
        }
      } else {
        console.log(`[Notification] No active tenant found for property ${propertyId}. Tenant assignments:`, tenantAssignments.map(ta => ({ id: ta.id, isActive: ta.assignment?.isActive })));
      }

      // Process each marked entry asynchronously (don't block response)
      // In production, this would be a background job
      (async () => {
        try {
          let totalCost = 0;
          const itemAnalyses: any[] = [];

          for (const checkOutEntry of markedEntries) {
            // Find matching check-in entry using normalized matching
            // This handles variations like "Entry Hallway" vs "Entry / Hallway"
            // and maps field keys between check-in and check-out templates
            const checkInEntry = checkInEntries.find(
              e => sectionRefsMatch(e.sectionRef, checkOutEntry.sectionRef) &&
                fieldKeysMatch(e.fieldKey, checkOutEntry.fieldKey)
            );

            // Log check-in entry matching for debugging
            if (checkInEntry) {
              console.log(`[ComparisonReport] Found matching check-in entry for ${checkOutEntry.sectionRef} - ${checkOutEntry.fieldKey}, photos: ${checkInEntry.photos?.length || 0}`);
            } else {
              console.log(`[ComparisonReport] No matching check-in entry found for ${checkOutEntry.sectionRef} - ${checkOutEntry.fieldKey}`);
            }

            let aiComparison: any = { summary: "No images to compare" };
            let estimatedCost = 0;
            let depreciation = 0;

            // Always get check-in photos, even if check-out has no photos
            // Helper function to convert photo path to absolute URL
            const convertPhotoToAbsoluteUrl = (photo: string): string => {
              // If already absolute URL, return as-is
              if (photo.startsWith("http://") || photo.startsWith("https://")) {
                return photo;
              }
              // If data URL, return as-is
              if (photo.startsWith("data:")) {
                return photo;
              }
              // Convert relative path to absolute URL
              // Photos are typically stored as /objects/... or objects/...
              const photoPath = photo.startsWith('/') ? photo : `/${photo}`;
              // We'll need to get the base URL from environment or construct it
              // For now, return the path as-is and let the frontend handle it
              // The frontend should be able to handle /objects/... paths
              return photoPath;
            };

            // Get check-in photos - always include them even if empty
            // Check both photos array and valueJson for photos
            let checkInPhotosRaw: string[] = [];
            if (checkInEntry) {
              // First try photos column
              if (checkInEntry.photos && Array.isArray(checkInEntry.photos) && checkInEntry.photos.length > 0) {
                checkInPhotosRaw = checkInEntry.photos;
              }
              // Also check valueJson for photos (for backward compatibility)
              else if (checkInEntry.valueJson && typeof checkInEntry.valueJson === 'object') {
                const valueJson = checkInEntry.valueJson as any;
                if (Array.isArray(valueJson.photos)) {
                  checkInPhotosRaw = valueJson.photos;
                } else if (typeof valueJson.photo === 'string' && valueJson.photo) {
                  checkInPhotosRaw = [valueJson.photo];
                }
              }
            }

            const checkInPhotos = checkInPhotosRaw.map(convertPhotoToAbsoluteUrl);
            console.log(`[ComparisonReport] Check-in photos for ${checkOutEntry.fieldKey}: ${checkInPhotos.length} photos`);

            // AI image comparison using OpenAI Vision API
            if (checkOutEntry.photos && checkOutEntry.photos.length > 0) {
              try {
                const checkOutPhotos = checkOutEntry.photos || [];

                // Helper function to convert photo URL to base64 data URL if needed
                const convertPhotoToDataUrl = async (photo: string): Promise<string | null> => {
                  try {
                    // If already a full HTTP URL, validate and use it directly
                    if (photo.startsWith("http://") || photo.startsWith("https://")) {
                      // Validate URL format
                      try {
                        new URL(photo);
                        return photo;
                      } catch {
                        console.warn(`[ComparisonReport] Invalid HTTP URL format: ${photo.substring(0, 50)}...`);
                        return null;
                      }
                    }

                    // If already a data URL, validate format
                    if (photo.startsWith("data:")) {
                      // Basic validation: should have format data:image/...;base64,...
                      if (photo.match(/^data:image\/[^;]+;base64,/)) {
                        // Check if data URL is not too large (OpenAI has limits)
                        if (photo.length > 20 * 1024 * 1024) { // 20MB limit
                          console.warn(`[ComparisonReport] Data URL too large (${Math.round(photo.length / 1024)}KB), skipping`);
                          return null;
                        }
                        return photo;
                      } else {
                        console.warn(`[ComparisonReport] Invalid data URL format: ${photo.substring(0, 50)}...`);
                        return null;
                      }
                    }

                    // Convert relative path to base64 data URL
                    const objectStorageService = new ObjectStorageService();
                    const photoPath = photo.startsWith('/objects/') ? photo : `/objects/${photo}`;
                    const objectFile = await objectStorageService.getObjectEntityFile(photoPath);
                    const fileBuffer = await fs.readFile(objectFile.name);

                    // Check file size (OpenAI has limits on data URLs)
                    const maxSize = 20 * 1024 * 1024; // 20MB
                    if (fileBuffer.length > maxSize) {
                      console.warn(`[ComparisonReport] Photo too large (${Math.round(fileBuffer.length / 1024)}KB), skipping: ${photoPath}`);
                      return null;
                    }

                    // Detect MIME type from buffer
                    let contentType = detectImageMimeType(fileBuffer);
                    if (!contentType || !contentType.startsWith('image/')) {
                      contentType = 'image/jpeg';
                    }

                    // Convert to base64 data URL
                    const base64Data = fileBuffer.toString('base64');
                    const dataUrl = `data:${contentType};base64,${base64Data}`;

                    // Validate the resulting data URL
                    if (!dataUrl.match(/^data:image\/[^;]+;base64,/)) {
                      console.error(`[ComparisonReport] Failed to create valid data URL for: ${photoPath}`);
                      return null;
                    }

                    return dataUrl;
                  } catch (error: any) {
                    console.error(`[ComparisonReport] Error converting photo ${photo} to data URL:`, error.message);
                    return null;
                  }
                };

                // Prepare image content for Vision API
                const imageContent: any[] = [];

                // Add check-in photos (if available)
                if (checkInPhotos.length > 0) {
                  imageContent.push({
                    type: "text",
                    text: "CHECK-IN PHOTOS (baseline condition):"
                  });
                  const checkInPhotoUrls = await Promise.all(
                    checkInPhotos.slice(0, 2).map(convertPhotoToDataUrl)
                  );
                  for (const photoUrl of checkInPhotoUrls) {
                    if (photoUrl && typeof photoUrl === 'string' && photoUrl.length > 0) {
                      // Validate URL format before adding
                      if (photoUrl.startsWith('http://') || photoUrl.startsWith('https://') ||
                        photoUrl.match(/^data:image\/[^;]+;base64,/)) {
                        // Pass URL as string directly (matching pattern used elsewhere in codebase)
                        imageContent.push({
                          type: "image_url",
                          image_url: photoUrl
                        });
                      } else {
                        console.warn(`[ComparisonReport] Skipping invalid check-in photo URL format: ${photoUrl.substring(0, 50)}...`);
                      }
                    }
                  }
                }

                // Add check-out photos
                imageContent.push({
                  type: "text",
                  text: "CHECK-OUT PHOTOS (current condition):"
                });
                const checkOutPhotoUrls = await Promise.all(
                  checkOutPhotos.slice(0, 2).map(convertPhotoToDataUrl)
                );
                for (const photoUrl of checkOutPhotoUrls) {
                  if (photoUrl && typeof photoUrl === 'string' && photoUrl.length > 0) {
                    // Validate URL format before adding
                    if (photoUrl.startsWith('http://') || photoUrl.startsWith('https://') ||
                      photoUrl.match(/^data:image\/[^;]+;base64,/)) {
                      // Pass URL as string directly (matching pattern used elsewhere in codebase)
                      imageContent.push({
                        type: "image_url",
                        image_url: photoUrl
                      });
                    } else {
                      console.warn(`[ComparisonReport] Skipping invalid check-out photo URL format: ${photoUrl.substring(0, 50)}...`);
                    }
                  }
                }

                // Get notes from both inspections for comparison
                const checkInNote = checkInEntry?.note || "";
                const checkOutNote = checkOutEntry.note || "";

                // Check if we have any valid images before making API call
                const hasValidImages = imageContent.some(item => item.type === "image_url");
                if (!hasValidImages && !checkInNote && !checkOutNote) {
                  console.warn(`[ComparisonReport] No valid images or notes found for entry ${checkOutEntry.fieldKey}, skipping AI analysis`);
                  aiComparison = { summary: "No valid images or notes available for comparison" };
                } else {
                  // Define prompt before using it
                  let prompt = `You are a professional BTR property inspector. Location: ${checkOutEntry.sectionRef} - ${checkOutEntry.fieldKey}

CRITICAL: The "differences" field must contain EXACTLY 100 words. Count them. This is mandatory for legal documentation.

ANALYSIS REQUIREMENTS:
- Compare baseline (check-in) to current (check-out) condition`;

                  if (hasValidImages) {
                    prompt += `
- Analyze the provided photos to identify ALL damage: scratches, stains, dents, tears, discoloration, wear
- Note specific locations: "top left corner", "center panel", "near handle"`;
                  }

                  prompt += `
- Distinguish fair wear (gradual fading, minor scuffs) from tenant damage (burns, holes, excessive staining)
- Consider both visual evidence from photos AND written notes from inspectors`;

                  if (checkInNote || checkOutNote) {
                    prompt += `\n\nCHECK-IN NOTES (baseline condition):\n${checkInNote || "No notes provided"}\n\nCHECK-OUT NOTES (current condition):\n${checkOutNote || "No notes provided"}`;
                  }

                  prompt += `

Respond with ONLY valid JSON (no markdown, no code blocks):
{
  "differences": "EXACTLY 100 WORDS describing: 1) Overall condition change between check-in and check-out (considering both photos and notes), 2) Specific damage locations and types observed, 3) Whether damage exceeds normal fair wear and tear, 4) Evidence supporting your liability assessment. Be detailed, specific, and professional.",
  "damage": "1-2 sentence summary of main damage",
  "severity": "low or medium or high",
  "repair_description": "Specific repairs needed",
  "suggested_liability": "tenant or landlord or shared",
  "estimated_cost_range": {"min": 0, "max": 0}`;

                  // Add notes comparison if both notes exist
                  if (checkInNote && checkOutNote) {
                    prompt += `,
  "notes_comparison": "Analyze and compare the check-in and check-out notes. Identify: 1) Items that were in good condition at check-in but are now broken, damaged, or missing at check-out, 2) New damage, issues, or problems that appeared at check-out that were NOT mentioned at check-in, 3) Any items that were damaged at check-in but are now repaired or improved, 4) Changes in condition descriptions (e.g., 'good' to 'poor', 'clean' to 'dirty'), 5) Specific discrepancies and what changed between the two inspections. Focus on actionable differences and tenant liability. Be detailed and specific. Write 100-150 words."`;
                  }

                  prompt += `
}`;

                  // Log image content for debugging (without full data URLs)
                  const imageCount = imageContent.filter(item => item.type === "image_url").length;
                  console.log(`[ComparisonReport] Sending ${imageCount} images for AI analysis on entry ${checkOutEntry.fieldKey}`);

                  // Build content array with text and images
                  const content = [
                    { type: "text", text: prompt },
                    ...imageContent
                  ];

                  // Log content structure for debugging (without full URLs)
                  console.log(`[ComparisonReport] Content structure:`, content.map((c, idx) => ({
                    index: idx,
                    type: c.type,
                    hasImageUrl: !!c.image_url,
                    urlType: typeof c.image_url,
                    urlPreview: c.image_url ? (typeof c.image_url === 'string' ? c.image_url.substring(0, 50) + '...' : 'object') : 'none'
                  })));

                  // Validate all image URLs before sending
                  const normalizedContent = normalizeApiContent(content);

                  // Double-check all image URLs are valid strings after normalization
                  for (let i = 0; i < normalizedContent.length; i++) {
                    const item = normalizedContent[i];
                    if (item.type === "input_image") {
                      const url = item.image_url;
                      if (typeof url !== 'string') {
                        console.error(`[ComparisonReport] Invalid image_url type at index ${i}: ${typeof url}, expected string. Item:`, JSON.stringify(item).substring(0, 200));
                        throw new Error(`[ComparisonReport] Invalid image_url type at index ${i}: ${typeof url}, expected string`);
                      }
                      if (!url || url.length === 0) {
                        console.error(`[ComparisonReport] Empty image_url at index ${i}`);
                        throw new Error(`[ComparisonReport] Empty image_url at index ${i}`);
                      }
                      // Validate URL format
                      const isValidHttp = url.startsWith('http://') || url.startsWith('https://');
                      const isValidDataUrl = url.match(/^data:image\/[^;]+;base64,/);
                      if (!isValidHttp && !isValidDataUrl) {
                        console.error(`[ComparisonReport] Invalid image_url format at index ${i}: ${url.substring(0, 100)}...`);
                        throw new Error(`[ComparisonReport] Invalid image_url format at index ${i}: expected http/https URL or data URL`);
                      }
                      // Log valid URL (truncated)
                      console.log(`[ComparisonReport] Valid image URL at index ${i}: ${url.substring(0, 50)}... (${url.length} chars)`);
                    }
                  }

                  // Call OpenAI Vision API
                  const response = await getOpenAI().responses.create({
                    model: "gpt-5", // the newest OpenAI model is "gpt-5" which was released August 7, 2025. do not change this unless explicitly requested by the user
                    input: [
                      {
                        role: "user",
                        content: normalizedContent
                      }
                    ],
                    max_output_tokens: 800,
                  });

                  let aiResponse = response.output_text || (response.output?.[0] as any)?.content?.[0]?.text || "{}";

                  // Strip markdown code blocks and asterisks from the response
                  aiResponse = aiResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '').replace(/\*\*/g, '').trim();

                  try {
                    aiComparison = JSON.parse(aiResponse);
                    // Use mid-point of cost range as estimate
                    estimatedCost = ((aiComparison.estimated_cost_range?.min || 0) +
                      (aiComparison.estimated_cost_range?.max || 0)) / 2;
                    // Add photos and notes to the comparison object
                    aiComparison.checkInPhotos = checkInPhotos;
                    aiComparison.checkOutPhotos = checkOutPhotos.map(convertPhotoToAbsoluteUrl);
                    aiComparison.checkInNote = checkInNote;
                    aiComparison.checkOutNote = checkOutNote;
                    // notes_comparison should already be in the parsed JSON if AI returned it
                    // If not present but both notes exist, generate it separately
                    if (!aiComparison.notes_comparison && checkInNote && checkOutNote) {
                      console.log(`[ComparisonReport] Notes comparison not found in AI response, generating separately...`);
                      try {
                        const notesComparisonPrompt = `You are a professional BTR property inspector. Compare the following check-in and check-out notes in detail.

CHECK-IN NOTES (baseline condition):
${checkInNote}

CHECK-OUT NOTES (current condition):
${checkOutNote}

Analyze and compare these notes. Identify:
1) Items that were in good condition at check-in but are now broken, damaged, or missing at check-out
2) New damage, issues, or problems that appeared at check-out that were NOT mentioned at check-in
3) Any items that were damaged at check-in but are now repaired or improved
4) Changes in condition descriptions (e.g., 'good' to 'poor', 'clean' to 'dirty')
5) Specific discrepancies and what changed between the two inspections

Focus on actionable differences and tenant liability. Be detailed and specific. Write 100-150 words.

Respond with ONLY valid JSON (no markdown, no code blocks):
{
  "notes_comparison": "Your detailed comparison here (100-150 words)"
}`;

                        const notesResponse = await getOpenAI().responses.create({
                          model: "gpt-5",
                          input: [{ role: "user", content: normalizeApiContent([{ type: "text", text: notesComparisonPrompt }]) }],
                          max_output_tokens: 400,
                        });

                        let notesAiResponse = notesResponse.output_text || (notesResponse.output?.[0] as any)?.content?.[0]?.text || "{}";
                        notesAiResponse = notesAiResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '').replace(/\*\*/g, '').trim();

                        try {
                          const notesComparison = JSON.parse(notesAiResponse);
                          if (notesComparison.notes_comparison) {
                            aiComparison.notes_comparison = notesComparison.notes_comparison;
                            console.log(`[ComparisonReport] Generated notes comparison separately`);
                          }
                        } catch (parseError) {
                          console.error(`[ComparisonReport] Error parsing notes comparison response:`, parseError);
                        }
                      } catch (notesError) {
                        console.error(`[ComparisonReport] Error generating notes comparison separately:`, notesError);
                      }
                    }
                  } catch {
                    aiComparison = {
                      summary: aiResponse,
                      checkInPhotos: checkInPhotos,
                      checkOutPhotos: checkOutPhotos.map(convertPhotoToAbsoluteUrl),
                      checkInNote: checkInNote,
                      checkOutNote: checkOutNote
                    };
                  }
                }
              } catch (error) {
                console.error("Error in AI comparison:", error);
                const checkOutPhotos = checkOutEntry.photos || [];
                const checkInNote = checkInEntry?.note || "";
                const checkOutNote = checkOutEntry.note || "";
                aiComparison = {
                  error: "Failed to analyze images",
                  checkInPhotos: checkInPhotos,
                  checkOutPhotos: checkOutPhotos.map(convertPhotoToAbsoluteUrl),
                  checkInNote: checkInNote,
                  checkOutNote: checkOutNote
                };
              }
            } else {
              // Even if check-out has no photos, still try to compare using notes if available
              const checkInNote = checkInEntry?.note || "";
              const checkOutNote = checkOutEntry.note || "";

              if (checkInPhotos.length > 0 || checkInNote || checkOutNote) {
                // If we have notes, try to do a text-based comparison
                if (checkInNote || checkOutNote) {
                  try {
                    let prompt = `You are a professional BTR property inspector. Location: ${checkOutEntry.sectionRef} - ${checkOutEntry.fieldKey}

Compare the check-in and check-out notes to identify any changes, damage, or issues.

CHECK-IN NOTES (baseline condition):
${checkInNote || "No notes provided"}

CHECK-OUT NOTES (current condition):
${checkOutNote || "No notes provided"}

CRITICAL: The "differences" field must contain EXACTLY 100 words. Count them. This is mandatory for legal documentation.

Respond with ONLY valid JSON (no markdown, no code blocks):
{
  "differences": "EXACTLY 100 WORDS describing: 1) Overall condition change based on notes, 2) Specific issues or damage mentioned, 3) Whether changes exceed normal fair wear and tear, 4) Evidence supporting your liability assessment. Be detailed, specific, and professional.",
  "damage": "1-2 sentence summary of main issues or damage",
  "severity": "low or medium or high",
  "repair_description": "Specific repairs needed if any",
  "suggested_liability": "tenant or landlord or shared",
  "estimated_cost_range": {"min": 0, "max": 0}`;

                    // Add notes comparison if both notes exist
                    if (checkInNote && checkOutNote) {
                      prompt += `,
  "notes_comparison": "Analyze and compare the check-in and check-out notes. Identify: 1) Items that were in good condition at check-in but are now broken, damaged, or missing at check-out, 2) New damage, issues, or problems that appeared at check-out that were NOT mentioned at check-in, 3) Any items that were damaged at check-in but are now repaired or improved, 4) Changes in condition descriptions (e.g., 'good' to 'poor', 'clean' to 'dirty'), 5) Specific discrepancies and what changed between the two inspections. Focus on actionable differences and tenant liability. Be detailed and specific. Write 100-150 words."`;
                    }

                    prompt += `
}`;

                    const response = await getOpenAI().responses.create({
                      model: "gpt-4o",
                      input: [{ role: "user", content: normalizeApiContent([{ type: "text", text: prompt }]) }],
                      max_output_tokens: 800,
                    });

                    console.log(`[ComparisonReport] Raw AI response status:`, response);

                    let aiResponse = response.output_text || (response.output?.[0] as any)?.content?.[0]?.text || "{}";
                    aiResponse = aiResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '').replace(/\*\*/g, '').trim();

                    try {
                      aiComparison = JSON.parse(aiResponse);
                      estimatedCost = ((aiComparison.estimated_cost_range?.min || 0) +
                        (aiComparison.estimated_cost_range?.max || 0)) / 2;
                      aiComparison.checkInPhotos = checkInPhotos;
                      aiComparison.checkOutPhotos = [];
                    } catch {
                      aiComparison = {
                        summary: aiResponse,
                        checkInPhotos: checkInPhotos,
                        checkOutPhotos: []
                      };
                    }
                  } catch (error) {
                    console.error("Error in text-based comparison:", error);
                    aiComparison = {
                      summary: "Check-in photos/notes available but no check-out photos for comparison",
                      checkInPhotos: checkInPhotos,
                      checkOutPhotos: []
                    };
                  }
                } else {
                  aiComparison = {
                    summary: "Check-in photos available but no check-out photos for comparison",
                    checkInPhotos: checkInPhotos,
                    checkOutPhotos: []
                  };
                }
              } else {
                aiComparison = {
                  summary: "No images or notes to compare",
                  checkInPhotos: [],
                  checkOutPhotos: []
                };
              }
            }

            // Calculate depreciation using actual asset data
            if (checkOutEntry.assetInventoryId) {
              try {
                const asset = await storage.getAssetById(checkOutEntry.assetInventoryId);
                if (asset && asset.purchasePrice && asset.datePurchased) {
                  const purchasePrice = parseFloat(asset.purchasePrice);
                  const purchaseDate = new Date(asset.datePurchased);
                  const currentDate = new Date();

                  // Calculate years since purchase
                  const yearsSincePurchase = (currentDate.getTime() - purchaseDate.getTime()) / (1000 * 60 * 60 * 24 * 365.25);

                  // Use asset's depreciation rate or calculate from expected lifespan
                  let annualDepreciationAmount = 0;
                  if (asset.depreciationPerYear) {
                    annualDepreciationAmount = parseFloat(asset.depreciationPerYear);
                  } else if (asset.expectedLifespanYears && asset.expectedLifespanYears > 0) {
                    annualDepreciationAmount = purchasePrice / asset.expectedLifespanYears;
                  }

                  // If no depreciation data available, fall back to 10%
                  if (annualDepreciationAmount > 0) {
                    // Calculate total accumulated depreciation
                    const accumulatedDepreciation = annualDepreciationAmount * yearsSincePurchase;

                    // Apply depreciation as percentage of repair cost
                    // If asset has depreciated 50% and repair costs $100, tenant pays $50
                    const depreciationPercentage = Math.min(1.0, accumulatedDepreciation / purchasePrice);
                    depreciation = estimatedCost * depreciationPercentage;
                  } else {
                    // Asset exists but has no depreciation metadata: use 10% fallback
                    depreciation = estimatedCost * 0.10;
                  }
                } else {
                  // Fallback: 10% depreciation if asset data is incomplete
                  depreciation = estimatedCost * 0.10;
                }
              } catch (error) {
                console.error("Error calculating asset depreciation:", error);
                depreciation = estimatedCost * 0.10;
              }
            } else {
              // No linked asset: use conservative 10% depreciation
              depreciation = estimatedCost * 0.10;
            }

            const finalCost = Math.max(0, estimatedCost - depreciation);
            totalCost += finalCost;

            // Extract condition/cleanliness from valueJson for both entries
            const parseConditionCleanliness = (entry: any) => {
              if (!entry?.valueJson) return { condition: null, cleanliness: null };
              try {
                const valueJson = typeof entry.valueJson === 'string'
                  ? JSON.parse(entry.valueJson)
                  : entry.valueJson;
                return {
                  condition: valueJson?.condition || null,
                  cleanliness: valueJson?.cleanliness || null,
                };
              } catch {
                return { condition: null, cleanliness: null };
              }
            };

            const checkInRatings = parseConditionCleanliness(checkInEntry);
            const checkOutRatings = parseConditionCleanliness(checkOutEntry);

            // Add condition/cleanliness to aiComparison
            aiComparison.checkInCondition = checkInRatings.condition;
            aiComparison.checkOutCondition = checkOutRatings.condition;
            aiComparison.checkInCleanliness = checkInRatings.cleanliness;
            aiComparison.checkOutCleanliness = checkOutRatings.cleanliness;

            itemAnalyses.push({
              sectionRef: checkOutEntry.sectionRef,
              fieldKey: checkOutEntry.fieldKey,
              checkInPhotos: checkInPhotos,
              checkOutPhotos: (checkOutEntry.photos || []).map(convertPhotoToAbsoluteUrl),
              aiComparison,
              estimatedCost,
              depreciation,
              finalCost,
            });

            // Create comparison report item
            await storage.createComparisonReportItem({
              comparisonReportId: report.id,
              checkInEntryId: checkInEntry?.id || null,
              checkOutEntryId: checkOutEntry.id,
              sectionRef: checkOutEntry.sectionRef,
              itemRef: checkOutEntry.itemRef,
              fieldKey: checkOutEntry.fieldKey,
              aiComparisonJson: aiComparison,
              estimatedCost: estimatedCost.toFixed(2),
              depreciation: depreciation.toFixed(2),
              finalCost: finalCost.toFixed(2),
            });
          }

          // Update report with total cost and analysis
          await storage.updateComparisonReport(report.id, {
            totalEstimatedCost: totalCost.toFixed(2),
            aiAnalysisJson: {
              summary: `Analyzed ${markedEntries.length} items. Total estimated cost: $${totalCost.toFixed(2)}`,
              items: itemAnalyses
            },
            status: "under_review",
          });

        } catch (error) {
          console.error("Error processing comparison items:", error);
        }
      })();

      // Consume credits using credit batch system
      const { subscriptionService } = await import("./subscriptionService");
      const reportId: string = report.id || `comparison_${Date.now()}`;
      await subscriptionService.consumeCredits(
        user.organizationId,
        2,
        "comparison",
        reportId,
        `Comparison report generation for property`
      );

      res.json(report);
    } catch (error) {
      console.error("Error generating comparison report:", error);
      res.status(500).json({ message: "Failed to generate comparison report" });
    }
  });

  app.get("/api/comparisons/:propertyId", isAuthenticated, async (req, res) => {
    try {
      const { propertyId } = req.params;
      const reports = await storage.getComparisonReportsByProperty(propertyId);
      res.json(reports);
    } catch (error) {
      console.error("Error fetching comparisons:", error);
      res.status(500).json({ message: "Failed to fetch comparisons" });
    }
  });

  // List all comparison reports for organization (operators only)
  app.get("/api/comparison-reports", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const reports = await storage.getComparisonReportsByOrganization(user.organizationId);
      res.json(reports);
    } catch (error) {
      console.error("Error fetching comparison reports:", error);
      res.status(500).json({ message: "Failed to fetch comparison reports" });
    }
  });

  // Get single comparison report with items
  app.get("/api/comparison-reports/:id", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const report = await storage.getComparisonReport(id);
      if (!report) {
        return res.status(404).json({ message: "Comparison report not found" });
      }

      // Verify organization ownership
      if (report.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Get report items
      const items = await storage.getComparisonReportItems(id);

      // Get check-in inspection ID from report to fetch entries for fallback matching
      const checkInInspectionId = report.checkInInspectionId;
      let checkInEntries: any[] = [];
      if (checkInInspectionId) {
        try {
          checkInEntries = await storage.getInspectionEntries(checkInInspectionId);
          console.log(`[ComparisonReport] Loaded ${checkInEntries.length} check-in entries for fallback matching`);
        } catch (error) {
          console.error(`[ComparisonReport] Error loading check-in entries:`, error);
        }
      }

      // Extract photos from aiComparisonJson and also fetch from entries if needed
      const itemsWithPhotos = await Promise.all(items.map(async (item) => {
        const aiComparison = item.aiComparisonJson || {};
        let checkInPhotos = aiComparison.checkInPhotos || [];
        let checkOutPhotos = aiComparison.checkOutPhotos || [];

        // If check-in photos are missing, try to fetch from check-in entry
        if (!checkInPhotos || checkInPhotos.length === 0) {
          let checkInEntry = null;

          // First, try using the stored checkInEntryId
          if (item.checkInEntryId) {
            try {
              checkInEntry = await storage.getInspectionEntry(item.checkInEntryId);
              console.log(`[ComparisonReport] Found check-in entry by ID: ${item.checkInEntryId}`);
            } catch (error) {
              console.error(`[ComparisonReport] Error fetching check-in entry ${item.checkInEntryId}:`, error);
            }
          }

          // If no entry found by ID, try to find matching entry using field key mapping
          if (!checkInEntry && checkInEntries.length > 0) {
            // Get the check-out entry to find its fieldKey
            try {
              const checkOutEntry = await storage.getInspectionEntry(item.checkOutEntryId);
              if (checkOutEntry) {
                // Use the new matching logic to find corresponding check-in entry
                checkInEntry = checkInEntries.find(
                  (e: any) => sectionRefsMatch(e.sectionRef, checkOutEntry.sectionRef || item.sectionRef) &&
                    fieldKeysMatch(e.fieldKey, checkOutEntry.fieldKey || item.fieldKey)
                );

                if (checkInEntry) {
                  console.log(`[ComparisonReport] Found matching check-in entry using field key mapping: ${checkInEntry.id} for check-out field ${checkOutEntry.fieldKey}`);
                  // Update the comparison report item with the found checkInEntryId for future use
                  try {
                    await storage.updateComparisonReportItem(item.id, { checkInEntryId: checkInEntry.id });
                    console.log(`[ComparisonReport] Updated comparison report item ${item.id} with checkInEntryId ${checkInEntry.id}`);
                  } catch (updateError) {
                    console.error(`[ComparisonReport] Error updating checkInEntryId:`, updateError);
                  }
                } else {
                  console.log(`[ComparisonReport] No matching check-in entry found for sectionRef: ${item.sectionRef}, fieldKey: ${item.fieldKey}`);
                }
              }
            } catch (error) {
              console.error(`[ComparisonReport] Error fetching check-out entry for matching:`, error);
            }
          }

          // If we found a check-in entry, extract photos and notes from it
          if (checkInEntry) {
            // Get photos from photos column or valueJson
            if (checkInEntry.photos && Array.isArray(checkInEntry.photos) && checkInEntry.photos.length > 0) {
              checkInPhotos = checkInEntry.photos;
            } else if (checkInEntry.valueJson && typeof checkInEntry.valueJson === 'object') {
              const valueJson = checkInEntry.valueJson as any;
              if (Array.isArray(valueJson.photos)) {
                checkInPhotos = valueJson.photos;
              } else if (typeof valueJson.photo === 'string' && valueJson.photo) {
                checkInPhotos = [valueJson.photo];
              }
            }

            // Update aiComparisonJson with notes if missing
            if (checkInEntry.note && !aiComparison.checkInNote) {
              aiComparison.checkInNote = checkInEntry.note;
              console.log(`[ComparisonReport] Fetched check-in note for item ${item.id}: ${checkInEntry.note.substring(0, 50)}...`);
            } else if (checkInEntry.note) {
              console.log(`[ComparisonReport] Check-in note already exists for item ${item.id}`);
            } else {
              console.log(`[ComparisonReport] No check-in note found in entry ${checkInEntry.id} for item ${item.id}`);
            }

            console.log(`[ComparisonReport] Fetched ${checkInPhotos.length} check-in photos for item ${item.id}`);
          } else {
            console.log(`[ComparisonReport] No check-in entry found for item ${item.id} (sectionRef: ${item.sectionRef}, fieldKey: ${item.fieldKey})`);
          }
        }

        // Also fetch check-out entry notes if missing
        if (!aiComparison.checkOutNote) {
          try {
            const checkOutEntry = await storage.getInspectionEntry(item.checkOutEntryId);
            if (checkOutEntry?.note) {
              aiComparison.checkOutNote = checkOutEntry.note;
              console.log(`[ComparisonReport] Fetched check-out note for item ${item.id}: ${checkOutEntry.note.substring(0, 50)}...`);
            } else {
              console.log(`[ComparisonReport] No check-out note found for item ${item.id}`);
            }
          } catch (error) {
            console.error(`[ComparisonReport] Error fetching check-out entry notes:`, error);
          }
        }

        // Debug: Log current state BEFORE generation
        console.log(`[ComparisonReport] Item ${item.id} - BEFORE generation check:`);
        console.log(`  - checkInNote exists: ${!!aiComparison.checkInNote}, length: ${aiComparison.checkInNote?.length || 0}`);
        console.log(`  - checkOutNote exists: ${!!aiComparison.checkOutNote}, length: ${aiComparison.checkOutNote?.length || 0}`);
        console.log(`  - notes_comparison exists: ${!!aiComparison.notes_comparison}`);
        if (aiComparison.checkInNote) {
          console.log(`  - checkInNote preview: "${aiComparison.checkInNote.substring(0, 50)}..."`);
        }
        if (aiComparison.checkOutNote) {
          console.log(`  - checkOutNote preview: "${aiComparison.checkOutNote.substring(0, 50)}..."`);
        }

        // Generate notes_comparison based on check-in and check-out notes if missing
        // Check that notes are not just empty strings or whitespace
        const hasValidCheckInNote = aiComparison.checkInNote && aiComparison.checkInNote.trim().length > 0;
        const hasValidCheckOutNote = aiComparison.checkOutNote && aiComparison.checkOutNote.trim().length > 0;

        console.log(`[ComparisonReport] Item ${item.id} - Notes check: hasValidCheckInNote=${hasValidCheckInNote}, hasValidCheckOutNote=${hasValidCheckOutNote}, hasNotesComparison=${!!aiComparison.notes_comparison}`);

        if (!aiComparison.notes_comparison && hasValidCheckInNote && hasValidCheckOutNote) {
          console.log(`[ComparisonReport] ðŸš€ STARTING notes comparison generation for item ${item.id}`);
          console.log(`[ComparisonReport] Check-in note (first 100 chars): ${aiComparison.checkInNote.substring(0, 100)}...`);
          console.log(`[ComparisonReport] Check-out note (first 100 chars): ${aiComparison.checkOutNote.substring(0, 100)}...`);

          let comparisonGenerated = false;
          try {
            const notesComparisonPrompt = `You are a professional BTR property inspector. Your task is to compare check-in and check-out inspection notes and identify ALL changes, damage, and condition differences.

CHECK-IN NOTES (baseline condition at move-in):
${aiComparison.checkInNote}

CHECK-OUT NOTES (current condition at move-out):
${aiComparison.checkOutNote}

REQUIRED ANALYSIS - You must identify and describe:
1. What was in GOOD condition at check-in but is now DAMAGED, BROKEN, or MISSING at check-out
2. What NEW damage, issues, or problems appeared at check-out that were NOT present at check-in
3. What was DAMAGED at check-in but is now REPAIRED or IMPROVED at check-out
4. CONDITION CHANGES: Compare specific condition descriptions (e.g., "good" became "poor", "clean" became "dirty", "intact" became "cracked")
5. SPECIFIC DISCREPANCIES: List exact differences between the two inspections

Write a detailed comparison analysis using BULLET POINTS for readability. Clearly explain how the condition changed from check-in to check-out. Focus on actionable differences that determine tenant liability.

CRITICAL: You MUST respond with ONLY valid JSON. Do NOT include markdown, code blocks, or any text outside the JSON. Your response must be in this exact format:
{"notes_comparison": "â€¢ Bullet point 1\nâ€¢ Bullet point 2\nâ€¢ Bullet point 3\n..."}

Example of what you should write:
{"notes_comparison": "The check-in notes indicate the floor was structurally sound with no visible damage. The check-out notes reveal the same floor now shows signs of wear and damage. Specifically, the check-in noted 'no obvious cracks' while check-out mentions visible damage. This indicates deterioration occurred during tenancy. The condition changed from 'structurally sound' to showing 'visible damage', suggesting tenant liability for the deterioration."}

Now provide your comparison analysis:`;

            console.log(`[ComparisonReport] Making AI call for notes comparison with model gpt-4o...`);
            const notesResponse = await getOpenAI().responses.create({
              model: "gpt-4o",
              input: [{ role: "user", content: normalizeApiContent([{ type: "text", text: notesComparisonPrompt }]) }],
              max_output_tokens: 400,
            });

            console.log(`[ComparisonReport] Raw AI response object:`, JSON.stringify(notesResponse, null, 2));

            let notesAiResponse = notesResponse.output_text || (notesResponse.output?.[0] as any)?.content?.[0]?.text || "";
            console.log(`[ComparisonReport] Raw AI response for notes comparison (first 500 chars): ${notesAiResponse.substring(0, 500)}`);
            console.log(`[ComparisonReport] Full response length: ${notesAiResponse.length}`);

            // Clean up the response - remove markdown code blocks, trim whitespace
            notesAiResponse = notesAiResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '').replace(/\*\*/g, '').trim();

            // If response is empty or just "{}", trigger retry directly instead of throwing
            if (!notesAiResponse || notesAiResponse === "{}" || notesAiResponse.trim() === "") {
              console.warn(`[ComparisonReport] âš ï¸ AI returned empty or invalid response. Full response: "${notesAiResponse}"`);
              console.log(`[ComparisonReport] Triggering retry with simpler prompt...`);

              // Retry with a simpler, more direct prompt
              try {
                const retryPrompt = `Compare these inspection notes and describe the changes:

CHECK-IN NOTES:
${aiComparison.checkInNote.substring(0, 800)}

CHECK-OUT NOTES:
${aiComparison.checkOutNote.substring(0, 800)}

Write a detailed comparison using BULLET POINTS explaining:
- What was good at check-in but damaged at check-out
- What new damage appeared
- How conditions changed (e.g., "good" to "poor")
- Specific differences between the two inspections

Respond with ONLY this JSON (no other text):
{"notes_comparison": "â€¢ Point 1\nâ€¢ Point 2\n..."}`;

                const retryResponse = await getOpenAI().responses.create({
                  model: "gpt-4o",
                  input: [{ role: "user", content: normalizeApiContent([{ type: "text", text: retryPrompt }]) }],
                  max_output_tokens: 500,
                });

                let retryAiResponse = retryResponse.output_text || (retryResponse.output?.[0] as any)?.content?.[0]?.text || "";
                retryAiResponse = retryAiResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '').replace(/\*\*/g, '').trim();

                console.log(`[ComparisonReport] Retry response (first 300 chars): ${retryAiResponse.substring(0, 300)}`);
                console.log(`[ComparisonReport] Retry response length: ${retryAiResponse.length}`);

                if (retryAiResponse && retryAiResponse !== "{}" && retryAiResponse.trim() !== "") {
                  const retryComparison = JSON.parse(retryAiResponse);
                  if (retryComparison.notes_comparison && retryComparison.notes_comparison.trim().length > 0) {
                    aiComparison.notes_comparison = retryComparison.notes_comparison.trim();
                    console.log(`[ComparisonReport] âœ… Retry successful - generated notes_comparison (${aiComparison.notes_comparison.length} chars)`);
                    await storage.updateComparisonReportItem(item.id, {
                      aiComparisonJson: aiComparison
                    });
                    // Success - mark as generated
                    comparisonGenerated = true;
                  } else {
                    console.warn(`[ComparisonReport] Retry response missing notes_comparison field`);
                  }
                } else {
                  console.warn(`[ComparisonReport] Retry returned empty response`);
                }

                // If retry also failed and we haven't generated, continue to final fallback
                if (!comparisonGenerated) {
                  throw new Error("Both initial and retry attempts returned empty or invalid responses");
                }
              } catch (retryError) {
                console.error(`[ComparisonReport] Retry also failed:`, retryError);
                // Fall through to outer catch block
                throw retryError;
              }
            }

            try {
              const notesComparison = JSON.parse(notesAiResponse);
              console.log(`[ComparisonReport] Parsed JSON successfully. Keys: ${Object.keys(notesComparison)}`);
              if (notesComparison.notes_comparison && notesComparison.notes_comparison.trim().length > 0) {
                aiComparison.notes_comparison = notesComparison.notes_comparison.trim();
                console.log(`[ComparisonReport] âœ…âœ…âœ… Successfully generated notes_comparison for item ${item.id}`);
                console.log(`[ComparisonReport] Comparison length: ${notesComparison.notes_comparison.length} chars`);
                console.log(`[ComparisonReport] Preview: ${notesComparison.notes_comparison.substring(0, 100)}...`);
                // Update the database
                try {
                  await storage.updateComparisonReportItem(item.id, {
                    aiComparisonJson: aiComparison
                  });
                  console.log(`[ComparisonReport] âœ… Database updated with notes_comparison for item ${item.id}`);
                } catch (updateError) {
                  console.error(`[ComparisonReport] âŒ Error updating notes_comparison in database:`, updateError);
                }
              } else {
                console.warn(`[ComparisonReport] âš ï¸ AI response missing or empty notes_comparison field. Full response:`, JSON.stringify(notesComparison, null, 2));
                // Retry with a simpler, more direct prompt
                console.log(`[ComparisonReport] Retrying with simpler, more direct prompt...`);
                try {
                  const retryPrompt = `Compare these inspection notes and describe the changes:

CHECK-IN NOTES:
${aiComparison.checkInNote.substring(0, 800)}

CHECK-OUT NOTES:
${aiComparison.checkOutNote.substring(0, 800)}

Write a detailed comparison using BULLET POINTS explaining:
- What was good at check-in but damaged at check-out
- What new damage appeared
- How conditions changed (e.g., "good" to "poor")
- Specific differences between the two inspections

Respond with ONLY this JSON (no other text):
{"notes_comparison": "â€¢ Point 1\nâ€¢ Point 2\n..."}`;

                  const retryResponse = await getOpenAI().responses.create({
                    model: "gpt-4o",
                    input: [{ role: "user", content: normalizeApiContent([{ type: "text", text: retryPrompt }]) }],
                    max_output_tokens: 500,
                  });

                  let retryAiResponse = retryResponse.output_text || (retryResponse.output?.[0] as any)?.content?.[0]?.text || "";
                  retryAiResponse = retryAiResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '').replace(/\*\*/g, '').trim();

                  console.log(`[ComparisonReport] Retry response (first 300 chars): ${retryAiResponse.substring(0, 300)}`);

                  if (retryAiResponse && retryAiResponse !== "{}" && retryAiResponse.trim() !== "") {
                    const retryComparison = JSON.parse(retryAiResponse);
                    if (retryComparison.notes_comparison && retryComparison.notes_comparison.trim().length > 0) {
                      aiComparison.notes_comparison = retryComparison.notes_comparison.trim();
                      console.log(`[ComparisonReport] âœ… Retry successful - generated notes_comparison (${aiComparison.notes_comparison.length} chars)`);
                      await storage.updateComparisonReportItem(item.id, {
                        aiComparisonJson: aiComparison
                      });
                    } else {
                      throw new Error("Retry response missing notes_comparison");
                    }
                  } else {
                    throw new Error("Retry returned empty response");
                  }
                } catch (retryError) {
                  console.error(`[ComparisonReport] Retry also failed:`, retryError);
                  // Don't use fallback - let the user know it needs manual review
                  aiComparison.notes_comparison = `[AI Comparison Unavailable] Please manually compare the check-in and check-out notes to identify changes, damage, or discrepancies between the two inspections.`;
                  console.log(`[ComparisonReport] Using placeholder text - AI comparison unavailable`);
                  try {
                    await storage.updateComparisonReportItem(item.id, {
                      aiComparisonJson: aiComparison
                    });
                  } catch (updateError) {
                    console.error(`[ComparisonReport] Error updating with placeholder:`, updateError);
                  }
                }
              }
            } catch (parseError) {
              console.error(`[ComparisonReport] âŒ Error parsing notes comparison response:`, parseError);
              console.error(`[ComparisonReport] Full response that failed to parse: ${notesAiResponse}`);

              // Try to extract JSON from the response if it's wrapped in text
              try {
                const jsonMatch = notesAiResponse.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                  const extractedJson = JSON.parse(jsonMatch[0]);
                  if (extractedJson.notes_comparison && extractedJson.notes_comparison.trim().length > 0) {
                    aiComparison.notes_comparison = extractedJson.notes_comparison.trim();
                    console.log(`[ComparisonReport] âœ… Extracted notes_comparison from wrapped response`);
                    await storage.updateComparisonReportItem(item.id, {
                      aiComparisonJson: aiComparison
                    });
                  } else {
                    throw new Error("Extracted JSON missing notes_comparison");
                  }
                } else {
                  throw new Error("No JSON found in response");
                }
              } catch (extractError) {
                console.error(`[ComparisonReport] Failed to extract JSON:`, extractError);
                // Generate a detailed fallback comparison
                const checkInSummary = aiComparison.checkInNote.length > 300 ? aiComparison.checkInNote.substring(0, 300) + "..." : aiComparison.checkInNote;
                const checkOutSummary = aiComparison.checkOutNote.length > 300 ? aiComparison.checkOutNote.substring(0, 300) + "..." : aiComparison.checkOutNote;
                const fallbackComparison = `COMPARISON ANALYSIS:\n\nThe check-in inspection noted: ${checkInSummary}\n\nThe check-out inspection noted: ${checkOutSummary}\n\nANALYSIS: Please compare the specific condition descriptions, damage reports, and observations between these two inspections to identify changes, new damage, or deterioration that occurred during the tenancy period.`;
                aiComparison.notes_comparison = fallbackComparison;
                console.log(`[ComparisonReport] Using detailed fallback comparison text after parse error`);
                try {
                  await storage.updateComparisonReportItem(item.id, {
                    aiComparisonJson: aiComparison
                  });
                } catch (updateError) {
                  console.error(`[ComparisonReport] Error updating with fallback:`, updateError);
                }
              }
            }
          } catch (notesError) {
            console.error(`[ComparisonReport] Error generating notes comparison:`, notesError);
            console.error(`[ComparisonReport] Error details:`, notesError instanceof Error ? notesError.message : String(notesError));

            // Final fallback - try one more time with an even simpler prompt
            if (!aiComparison.notes_comparison) {
              console.log(`[ComparisonReport] Attempting final fallback with minimal prompt...`);
              try {
                const finalPrompt = `Compare these two notes and write a comparison:

CHECK-IN: ${aiComparison.checkInNote.substring(0, 600)}
CHECK-OUT: ${aiComparison.checkOutNote.substring(0, 600)}

Write how the condition changed. JSON only: {"notes_comparison": "comparison text here"}`;

                const finalResponse = await getOpenAI().responses.create({
                  model: "gpt-4o",
                  input: [{ role: "user", content: normalizeApiContent([{ type: "text", text: finalPrompt }]) }],
                  max_output_tokens: 400,
                });

                let finalAiResponse = finalResponse.output_text || (finalResponse.output?.[0] as any)?.content?.[0]?.text || "";
                finalAiResponse = finalAiResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '').replace(/\*\*/g, '').trim();

                if (finalAiResponse && finalAiResponse !== "{}" && finalAiResponse.trim() !== "") {
                  try {
                    const finalComparison = JSON.parse(finalAiResponse);
                    if (finalComparison.notes_comparison && finalComparison.notes_comparison.trim().length > 0) {
                      aiComparison.notes_comparison = finalComparison.notes_comparison.trim();
                      console.log(`[ComparisonReport] âœ… Final fallback successful - generated notes_comparison`);
                      await storage.updateComparisonReportItem(item.id, {
                        aiComparisonJson: aiComparison
                      });
                    }
                  } catch (parseErr) {
                    console.error(`[ComparisonReport] Failed to parse final fallback response:`, parseErr);
                  }
                }
              } catch (finalError) {
                console.error(`[ComparisonReport] Final fallback also failed:`, finalError);
              }
            }
          }
        }

        // If check-out photos are missing from aiComparisonJson, fetch from check-out entry
        if ((!checkOutPhotos || checkOutPhotos.length === 0) && item.checkOutEntryId) {
          try {
            const checkOutEntry = await storage.getInspectionEntry(item.checkOutEntryId);
            if (checkOutEntry) {
              // Get photos from photos column or valueJson
              if (checkOutEntry.photos && Array.isArray(checkOutEntry.photos) && checkOutEntry.photos.length > 0) {
                checkOutPhotos = checkOutEntry.photos;
              } else if (checkOutEntry.valueJson && typeof checkOutEntry.valueJson === 'object') {
                const valueJson = checkOutEntry.valueJson as any;
                if (Array.isArray(valueJson.photos)) {
                  checkOutPhotos = valueJson.photos;
                } else if (typeof valueJson.photo === 'string' && valueJson.photo) {
                  checkOutPhotos = [valueJson.photo];
                }
              }
            }
          } catch (error) {
            console.error(`[ComparisonReport] Error fetching check-out entry ${item.checkOutEntryId}:`, error);
          }
        }

        // Log what we're returning for debugging AFTER generation attempt
        if (aiComparison.notes_comparison) {
          console.log(`[ComparisonReport] âœ… Item ${item.id} HAS notes_comparison (${aiComparison.notes_comparison.length} chars): ${aiComparison.notes_comparison.substring(0, 50)}...`);
        } else if (aiComparison.checkInNote && aiComparison.checkOutNote) {
          console.log(`[ComparisonReport] âš ï¸ Item ${item.id} has both notes but NO notes_comparison after generation attempt`);
          console.log(`[ComparisonReport]   - checkInNote exists: ${!!aiComparison.checkInNote}, length: ${aiComparison.checkInNote?.length || 0}`);
          console.log(`[ComparisonReport]   - checkOutNote exists: ${!!aiComparison.checkOutNote}, length: ${aiComparison.checkOutNote?.length || 0}`);
          console.log(`[ComparisonReport]   - This means generation either failed or didn't complete`);
        } else {
          console.log(`[ComparisonReport] Item ${item.id} - checkInNote: ${!!aiComparison.checkInNote}, checkOutNote: ${!!aiComparison.checkOutNote}`);
        }

        // Ensure aiComparisonJson is a proper object
        const finalAiComparison = {
          ...aiComparison,
          checkInPhotos: aiComparison.checkInPhotos || [],
          checkOutPhotos: aiComparison.checkOutPhotos || [],
        };

        return {
          ...item,
          checkInPhotos: checkInPhotos,
          checkOutPhotos: checkOutPhotos,
          aiComparisonJson: finalAiComparison, // Include updated notes in aiComparisonJson
        };
      }));

      res.json({ ...report, items: itemsWithPhotos });
    } catch (error) {
      console.error("Error fetching comparison report:", error);
      res.status(500).json({ message: "Failed to fetch comparison report" });
    }
  });

  // Update comparison report status
  app.patch("/api/comparison-reports/:id", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const report = await storage.getComparisonReport(id);
      if (!report) {
        return res.status(404).json({ message: "Comparison report not found" });
      }

      // Verify organization ownership
      if (report.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Validate status updates
      const { status } = req.body;
      const validStatuses = ["draft", "under_review", "awaiting_signatures", "signed", "filed"];
      if (status && !validStatuses.includes(status)) {
        return res.status(400).json({ message: "Invalid status value" });
      }

      const updatedReport = await storage.updateComparisonReport(id, req.body);
      res.json(updatedReport);
    } catch (error) {
      console.error("Error updating comparison report:", error);
      res.status(500).json({ message: "Failed to update comparison report" });
    }
  });

  // Delete comparison report
  app.delete("/api/comparison-reports/:id", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const { id } = req.params;
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const report = await storage.getComparisonReport(id);
      if (!report) {
        return res.status(404).json({ message: "Comparison report not found" });
      }

      // Verify organization ownership
      if (report.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Delete the report and all related data
      await storage.deleteComparisonReport(id);
      res.json({ message: "Comparison report deleted successfully" });
    } catch (error: any) {
      console.error("Error deleting comparison report:", error);
      res.status(500).json({ message: "Failed to delete comparison report" });
    }
  });

  // Get comparison report comments
  app.get("/api/comparison-reports/:id/comments", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const report = await storage.getComparisonReport(id);
      if (!report) {
        return res.status(404).json({ message: "Comparison report not found" });
      }

      // Verify organization ownership
      if (report.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const comments = await storage.getComparisonComments(id);
      res.json(comments);
    } catch (error) {
      console.error("Error fetching comments:", error);
      res.status(500).json({ message: "Failed to fetch comments" });
    }
  });

  // Update comparison report item (operator only)
  app.patch("/api/comparison-report-items/:id", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const { id } = req.params;
      const user = await storage.getUser(req.user.id);

      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Get item and verify access through report
      const items = await storage.getComparisonReportItems(req.body.comparisonReportId);
      const item = items.find((i: any) => i.id === id);

      if (!item) {
        return res.status(404).json({ message: "Comparison report item not found" });
      }

      const report = await storage.getComparisonReport(item.comparisonReportId);
      if (!report || report.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Validate allowed fields
      const allowedFields = ["status", "liabilityDecision", "estimatedCost", "depreciation", "finalCost", "operatorNotes", "aiComparisonJson"];
      const updates: any = {};

      for (const field of allowedFields) {
        if (req.body[field] !== undefined) {
          updates[field] = req.body[field];
        }
      }

      // If aiComparisonJson is provided, merge it with existing data
      if (updates.aiComparisonJson) {
        const existingAiComparison = item.aiComparisonJson || {};
        updates.aiComparisonJson = {
          ...existingAiComparison,
          ...updates.aiComparisonJson,
        };
      }

      // Validate status if provided (must match comparisonItemStatusEnum)
      if (updates.status) {
        const validStatuses = ["pending", "reviewed", "disputed", "resolved", "waived"];
        if (!validStatuses.includes(updates.status)) {
          return res.status(400).json({ message: "Invalid status value" });
        }
      }

      // Validate liability decision if provided
      if (updates.liabilityDecision) {
        const validLiability = ["tenant", "landlord", "shared", "waived"];
        if (!validLiability.includes(updates.liabilityDecision)) {
          return res.status(400).json({ message: "Invalid liability decision value" });
        }
      }

      const updatedItem = await storage.updateComparisonReportItem(id, updates);

      // Recalculate total cost for the report if costs changed
      if (updates.finalCost !== undefined) {
        const allItems = await storage.getComparisonReportItems(report.id);
        const totalCost = allItems.reduce((sum: number, i: any) => {
          return sum + parseFloat(i.finalCost || "0");
        }, 0);
        await storage.updateComparisonReport(report.id, { totalEstimatedCost: totalCost.toFixed(2) });
      }

      res.json(updatedItem);
    } catch (error) {
      console.error("Error updating comparison report item:", error);
      res.status(500).json({ message: "Failed to update comparison report item" });
    }
  });

  // Add comparison report comment (with internal flag support for operators)
  app.post("/api/comparison-reports/:id/comments", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { content, isInternal } = req.body;
      const user = await storage.getUser(req.user.id);

      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      if (!content || content.trim().length === 0) {
        return res.status(400).json({ message: "Comment content is required" });
      }

      const report = await storage.getComparisonReport(id);
      if (!report) {
        return res.status(404).json({ message: "Comparison report not found" });
      }

      // Verify organization ownership
      if (report.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const isOperator = user.role === "owner" || user.role === "clerk";
      const authorName = [user.firstName, user.lastName].filter(Boolean).join(" ") || user.email;

      const comment = await storage.createComparisonComment({
        comparisonReportId: id,
        userId: user.id,
        authorName,
        authorRole: isOperator ? "operator" : "tenant",
        content: content.trim(),
        // Operators can choose internal or public; tenants are always public
        isInternal: isOperator ? (isInternal === true) : false,
      });

      res.json(comment);
    } catch (error) {
      console.error("Error creating comment:", error);
      res.status(500).json({ message: "Failed to create comment" });
    }
  });

  // Electronic signature for comparison reports
  app.post("/api/comparison-reports/:id/sign", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { signature } = req.body; // Signature data URL (base64 image) or typed name
      const user = await storage.getUser(req.user.id);

      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      if (!signature || signature.trim().length === 0) {
        return res.status(400).json({ message: "Signature is required" });
      }

      // If signature is a data URL (image), extract the user's name from user object
      // Otherwise, use the signature as the typed name (backward compatibility)
      let signatureName: string;
      if (signature.startsWith('data:image/')) {
        // It's a signature image - use user's full name
        signatureName = user.firstName && user.lastName
          ? `${user.firstName} ${user.lastName}`.trim()
          : user.email || user.username || 'Operator';
      } else {
        // It's a typed name (backward compatibility)
        signatureName = signature.trim();
      }

      const report = await storage.getComparisonReport(id);
      if (!report) {
        return res.status(404).json({ message: "Comparison report not found" });
      }

      // Verify organization ownership
      if (report.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Get IP address from request
      const ipAddress = req.ip || req.connection?.remoteAddress || "unknown";

      // Determine who is signing
      const isOperator = user.role === "owner" || user.role === "clerk";
      const isTenant = user.role === "tenant";

      if (!isOperator && !isTenant) {
        return res.status(403).json({ message: "Only operators and tenants can sign comparison reports" });
      }

      // Check if already signed by this party
      if (isOperator && report.operatorSignature) {
        return res.status(400).json({ message: "Operator has already signed this report" });
      }
      if (isTenant && report.tenantSignature) {
        return res.status(400).json({ message: "Tenant has already signed this report" });
      }

      // Update signature fields
      const updates: any = {};
      const now = new Date();

      if (isOperator) {
        // Store signature data URL if it's an image, otherwise store typed name
        const signatureToStore = signature.startsWith('data:image/') ? signature : signatureName;
        updates.operatorSignature = signatureToStore;
        updates.operatorSignedAt = now;
        updates.operatorSignedIp = ipAddress;
      } else if (isTenant) {
        // Store signature data URL if it's an image, otherwise store typed name
        const signatureToStore = signature.startsWith('data:image/') ? signature : signatureName;
        updates.tenantSignature = signatureToStore;
        updates.tenantSignedAt = now;
        updates.tenantSignedIp = ipAddress;
      }

      // Check if both parties have now signed
      const bothSigned = (
        (isOperator || report.operatorSignature) &&
        (isTenant || report.tenantSignature)
      );

      if (bothSigned) {
        updates.status = "signed";
      }

      const updatedReport = await storage.updateComparisonReport(id, updates);
      res.json(updatedReport);
    } catch (error) {
      console.error("Error signing comparison report:", error);
      res.status(500).json({ message: "Failed to sign comparison report" });
    }
  });

  // Generate Comparison Report PDF with branding
  app.get("/api/comparison-reports/:id/pdf", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const user = await storage.getUser(req.user.id);

      if (!user) {
        return res.status(401).json({ message: "User not found" });
      }

      // For tenants, organizationId might be null, so don't require it
      if (user.role !== "tenant" && !user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const report = await storage.getComparisonReport(id);
      if (!report) {
        return res.status(404).json({ message: "Comparison report not found" });
      }

      // Verify access - for tenants, check property assignment; for others, check organization
      if (user.role === "tenant") {
        // For tenants, check if they have assignment to the property
        const assignments = await db
          .select({ propertyId: tenantAssignments.propertyId })
          .from(tenantAssignments)
          .where(eq(tenantAssignments.tenantId, user.id));

        const tenantPropertyIds = assignments.map(a => a.propertyId);
        if (!tenantPropertyIds.includes(report.propertyId)) {
          return res.status(403).json({ message: "Access denied" });
        }
      } else {
        // For non-tenants, verify organization ownership
        if (report.organizationId !== user.organizationId) {
          return res.status(403).json({ message: "Access denied" });
        }
      }

      // Get report items
      const items = await storage.getComparisonReportItems(id);

      // Get property and tenant info
      const property = await storage.getProperty(report.propertyId);
      const block = property?.blockId ? await storage.getBlock(property.blockId) : null;

      // Get check-in and check-out inspections
      const checkInInspection = await storage.getInspection(report.checkInInspectionId);
      const checkOutInspection = await storage.getInspection(report.checkOutInspectionId);

      // Get comments for the report
      const comments = await storage.getComparisonComments(id);

      // Get organization branding (use report's organizationId, not user's, in case tenant doesn't have org)
      const organization = await storage.getOrganization(report.organizationId);
      const branding: ReportBrandingInfo = organization ? {
        logoUrl: organization.logoUrl,
        brandingName: organization.brandingName,
        brandingEmail: organization.brandingEmail,
        brandingPhone: organization.brandingPhone,
        brandingWebsite: organization.brandingWebsite,
      } : {};

      // Build base URL for converting relative image paths to absolute (same as inspection report)
      const protocol = req.protocol;
      const host = req.get('host');
      const baseUrl = `${protocol}://${host}`;

      console.log('[PDF Generation] Using baseUrl:', baseUrl, 'for', items.length, 'items');

      // Generate HTML for the comparison report (photos will be converted to absolute URLs in HTML generation)
      const html = generateComparisonReportHTML(
        report,
        items,
        property,
        block,
        checkInInspection,
        checkOutInspection,
        comments.filter((c: any) => !c.isInternal), // Only public comments in PDF
        branding,
        baseUrl
      );

      let browser;
      try {
        browser = await launchPuppeteerBrowser();

        const page = await browser.newPage();
        await page.setContent(html, {
          waitUntil: "networkidle0",
        });

        const pdf = await page.pdf({
          format: "A4",
          landscape: true,
          printBackground: true,
          margin: {
            top: "15mm",
            right: "12mm",
            bottom: "15mm",
            left: "12mm",
          },
        });

        res.contentType("application/pdf");
        res.setHeader("Content-Disposition", `attachment; filename="comparison-report-${id}.pdf"`);
        res.send(Buffer.from(pdf));
      } finally {
        if (browser) {
          await browser.close();
        }
      }
    } catch (error) {
      console.error("Error generating comparison report PDF:", error);
      res.status(500).json({ message: "Failed to generate comparison report PDF" });
    }
  });

  // Helper function to generate inspection schedule calendar HTML
  function generateInspectionCalendarHTML(
    propertyInspections: any[],
    templates: any[],
    year: number,
    escapeHtml: (str: string) => string
  ): string {
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

    const complianceData = templates.map(template => {
      const templateInspections = propertyInspections.filter(i => i.templateId === template.id);

      const monthData = monthNames.map((monthName, monthIndex) => {
        const monthInspections = templateInspections.filter(inspection => {
          if (!inspection.scheduledDate) return false;
          const schedDate = new Date(inspection.scheduledDate);
          return schedDate.getFullYear() === year && schedDate.getMonth() === monthIndex;
        });

        if (monthInspections.length === 0) {
          return { month: months[monthIndex], status: 'not_scheduled', count: 0 };
        }

        const completedCount = monthInspections.filter(i => i.status === 'completed').length;
        const overdueCount = monthInspections.filter(i => {
          if (i.status === 'completed' || !i.scheduledDate) return false;
          const schedDate = new Date(i.scheduledDate);
          return schedDate < today;
        }).length;

        const dueCount = monthInspections.filter(i => {
          if (i.status === 'completed' || !i.scheduledDate) return false;
          const schedDate = new Date(i.scheduledDate);
          const daysUntil = Math.ceil((schedDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
          return daysUntil >= 0 && daysUntil <= 30;
        }).length;

        let status = 'not_scheduled';
        if (overdueCount > 0) {
          status = 'overdue';
        } else if (completedCount === monthInspections.length) {
          status = 'completed';
        } else if (dueCount > 0) {
          status = 'due';
        } else {
          status = 'scheduled';
        }

        return {
          month: months[monthIndex],
          status,
          count: monthInspections.length,
          completed: completedCount,
          overdue: overdueCount,
        };
      });

      const totalScheduled = monthData.reduce((sum, m) => sum + m.count, 0);
      const totalCompleted = monthData.reduce((sum, m) => sum + (m.completed || 0), 0);
      const complianceRate = totalScheduled > 0 ? Math.round((totalCompleted / totalScheduled) * 100) : 0;

      return {
        templateId: template.id,
        templateName: template.name,
        monthData,
        complianceRate,
        totalScheduled,
        totalCompleted,
      };
    });

    const getStatusIcon = (status: string) => {
      switch (status) {
        case 'completed': return 'âœ“';
        case 'overdue': return 'âš ';
        case 'due': return 'â°';
        case 'scheduled': return 'â—‹';
        default: return 'Â·';
      }
    };

    const getStatusColor = (status: string) => {
      switch (status) {
        case 'completed': return 'background: #dcfce7; border: 1px solid #86efac; color: #166534;';
        case 'overdue': return 'background: #fee2e2; border: 1px solid #fca5a5; color: #991b1b;';
        case 'due': return 'background: #fef3c7; border: 1px solid #fde047; color: #92400e;';
        case 'scheduled': return 'background: #dbeafe; border: 1px solid #93c5fd; color: #1e40af;';
        default: return 'background: #f3f4f6; border: 1px solid #d1d5db; color: #6b7280;';
      }
    };

    if (complianceData.length === 0) {
      return '<p style="color: #6b7280; font-size: 14px;">No inspection templates configured.</p>';
    }

    return `
      <div style="overflow-x: auto; margin: 20px 0;">
        <table style="width: 100%; border-collapse: collapse; font-size: 11px;">
          <thead>
            <tr>
              <th style="background: #00D5CC; color: white; padding: 8px; text-align: left; font-weight: 600; border: 1px solid #00D5CC;">Template</th>
              ${months.map(m => `<th style="background: #00D5CC; color: white; padding: 8px; text-align: center; font-weight: 600; border: 1px solid #00D5CC; min-width: 40px;">${m}</th>`).join('')}
              <th style="background: #00D5CC; color: white; padding: 8px; text-align: center; font-weight: 600; border: 1px solid #00D5CC;">Rate</th>
            </tr>
          </thead>
          <tbody>
            ${complianceData.map(template => `
              <tr>
                <td style="padding: 8px; border: 1px solid #e5e7eb; font-weight: 500;">${escapeHtml(template.templateName)}</td>
                ${template.monthData.map((m: any) => `
                  <td style="padding: 6px; border: 1px solid #e5e7eb; text-align: center; ${getStatusColor(m.status)}">
                    ${getStatusIcon(m.status)}
                  </td>
                `).join('')}
                <td style="padding: 8px; border: 1px solid #e5e7eb; text-align: center; font-weight: 600;">${template.complianceRate}%</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    `;
  }

  // Helper function to generate compliance document calendar HTML
  function generateComplianceDocumentCalendarHTML(
    propertyCompliance: any[],
    year: number,
    escapeHtml: (str: string) => string
  ): string {
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

    // Group by document type
    const docTypes = Array.from(new Set(propertyCompliance.map(d => d.documentType)));

    const documentTypeData = docTypes.map(docType => {
      const docs = propertyCompliance.filter(d => d.documentType === docType);
      const latestDoc = docs.sort((a, b) => {
        const dateA = a.expiryDate ? new Date(a.expiryDate).getTime() : 0;
        const dateB = b.expiryDate ? new Date(b.expiryDate).getTime() : 0;
        return dateB - dateA;
      })[0];

      const monthData = monthNames.map((monthName, monthIndex) => {
        const monthDocs = docs.filter(doc => {
          if (!doc.expiryDate) return false;
          const expiryDate = new Date(doc.expiryDate);
          return expiryDate.getFullYear() === year && expiryDate.getMonth() === monthIndex;
        });

        const hasDocument = monthDocs.length > 0;
        if (!hasDocument) {
          return { month: months[monthIndex], status: 'missing', hasDocument: false };
        }

        const doc = monthDocs[0];
        const expiryDate = new Date(doc.expiryDate);
        const daysUntilExpiry = Math.floor((expiryDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));

        let status = 'valid';
        if (daysUntilExpiry < 0) {
          status = 'expired';
        } else if (daysUntilExpiry <= 30) {
          status = 'expiring_soon';
        }

        return {
          month: months[monthIndex],
          status,
          hasDocument: true,
        };
      });

      let overallStatus = 'valid';
      if (latestDoc?.expiryDate) {
        const expiryDate = new Date(latestDoc.expiryDate);
        const daysUntilExpiry = Math.floor((expiryDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
        if (daysUntilExpiry < 0) {
          overallStatus = 'expired';
        } else if (daysUntilExpiry <= 30) {
          overallStatus = 'expiring_soon';
        }
      } else if (latestDoc) {
        overallStatus = 'no_expiry';
      } else {
        overallStatus = 'missing';
      }

      return {
        documentType: docType,
        monthData,
        status: overallStatus,
      };
    });

    const getStatusIcon = (data: any) => {
      if (!data.hasDocument) return 'Â·';
      switch (data.status) {
        case 'valid': return 'âœ“';
        case 'expired': return 'âš ';
        case 'expiring_soon': return 'â°';
        case 'no_expiry': return 'âœ“';
        default: return 'Â·';
      }
    };

    const getStatusColor = (data: any) => {
      if (!data.hasDocument) return 'background: #f3f4f6; border: 1px solid #d1d5db; color: #6b7280;';
      switch (data.status) {
        case 'valid': return 'background: #dcfce7; border: 1px solid #86efac; color: #166534;';
        case 'expired': return 'background: #fee2e2; border: 1px solid #fca5a5; color: #991b1b;';
        case 'expiring_soon': return 'background: #fef3c7; border: 1px solid #fde047; color: #92400e;';
        case 'no_expiry': return 'background: #dbeafe; border: 1px solid #93c5fd; color: #1e40af;';
        default: return 'background: #f3f4f6; border: 1px solid #d1d5db; color: #6b7280;';
      }
    };

    const getStatusBadge = (status: string) => {
      switch (status) {
        case 'valid': return '<span style="padding: 3px 8px; border-radius: 4px; background: #dcfce7; color: #166534; font-size: 10px; font-weight: 600;">Valid</span>';
        case 'expired': return '<span style="padding: 3px 8px; border-radius: 4px; background: #fee2e2; color: #991b1b; font-size: 10px; font-weight: 600;">Expired</span>';
        case 'expiring_soon': return '<span style="padding: 3px 8px; border-radius: 4px; background: #fef3c7; color: #92400e; font-size: 10px; font-weight: 600;">Expiring Soon</span>';
        case 'no_expiry': return '<span style="padding: 3px 8px; border-radius: 4px; background: #dbeafe; color: #1e40af; font-size: 10px; font-weight: 600;">Valid</span>';
        default: return '<span style="padding: 3px 8px; border-radius: 4px; background: #f3f4f6; color: #6b7280; font-size: 10px; font-weight: 600;">Missing</span>';
      }
    };

    if (documentTypeData.length === 0) {
      return '<p style="color: #6b7280; font-size: 14px;">No compliance documents found.</p>';
    }

    return `
      <div style="overflow-x: auto; margin: 20px 0;">
        <table style="width: 100%; border-collapse: collapse; font-size: 11px;">
          <thead>
            <tr>
              <th style="background: #00D5CC; color: white; padding: 8px; text-align: left; font-weight: 600; border: 1px solid #00D5CC;">Document Type</th>
              ${months.map(m => `<th style="background: #00D5CC; color: white; padding: 8px; text-align: center; font-weight: 600; border: 1px solid #00D5CC; min-width: 40px;">${m}</th>`).join('')}
              <th style="background: #00D5CC; color: white; padding: 8px; text-align: center; font-weight: 600; border: 1px solid #00D5CC;">Status</th>
            </tr>
          </thead>
          <tbody>
            ${documentTypeData.map(docType => `
              <tr>
                <td style="padding: 8px; border: 1px solid #e5e7eb; font-weight: 500;">${escapeHtml(docType.documentType)}</td>
                ${docType.monthData.map((m: any) => `
                  <td style="padding: 6px; border: 1px solid #e5e7eb; text-align: center; ${getStatusColor(m)}">
                    ${getStatusIcon(m)}
                  </td>
                `).join('')}
                <td style="padding: 8px; border: 1px solid #e5e7eb; text-align: center;">${getStatusBadge(docType.status)}</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    `;
  }

  // Generate Dashboard Report HTML
  function generateDashboardReportHTML(
    properties: any[],
    blocks: any[],
    inspections: any[],
    compliance: any[],
    maintenance: any[],
    tenantAssignments: any[],
    filterBlockId?: string,
    filterPropertyId?: string,
    branding?: ReportBrandingInfo,
    baseUrl?: string
  ): string {
    const escapeHtml = (str: string) => {
      if (!str) return '';
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    };

    const sanitizeReportUrl = (url: string): string => {
      if (!url || typeof url !== 'string') return '';
      const trimmed = url.trim();
      const lower = trimmed.toLowerCase();
      if (trimmed.startsWith('/') && baseUrl) {
        const absoluteUrl = `${baseUrl}${trimmed}`;
        return escapeHtml(absoluteUrl);
      }
      const safeProtocols = ['https://', 'http://'];
      const isSafeProtocol = safeProtocols.some(protocol => lower.startsWith(protocol));
      if (!isSafeProtocol) {
        const safeDataImages = [
          'data:image/png',
          'data:image/jpeg',
          'data:image/jpg',
          'data:image/gif',
          'data:image/webp',
        ];
        const isSafeDataUrl = safeDataImages.some(prefix => lower.startsWith(prefix));
        if (isSafeDataUrl) {
          return trimmed;
        }
        return '';
      }
      return escapeHtml(trimmed);
    };

    // Calculate stats
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const days7Future = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);
    const days30Future = new Date(today.getTime() + 30 * 24 * 60 * 60 * 1000);
    const days90Ago = new Date(today.getTime() - 90 * 24 * 60 * 60 * 1000);

    const overdueInspections = inspections.filter((i: any) => {
      if (i.status === 'completed' || i.status === 'cancelled') return false;
      if (!i.scheduledDate) return false;
      return new Date(i.scheduledDate) < today;
    });

    const overdueCompliance = compliance.filter((c: any) => {
      if (!c.expiryDate) return false;
      return new Date(c.expiryDate) < today;
    });

    const urgentMaintenance = maintenance.filter((m: any) => {
      if (m.status === 'completed' || m.status === 'closed') return false;
      if (m.priority === 'urgent' || m.priority === 'high') return true;
      if (m.dueDate) {
        const dueDate = new Date(m.dueDate);
        const dueDateOnly = new Date(dueDate.getFullYear(), dueDate.getMonth(), dueDate.getDate());
        return dueDateOnly < today;
      }
      return false;
    });

    const activeAssignments = tenantAssignments.filter((t: any) => {
      const isActive = t.isActive !== undefined ? t.isActive : (t as any).is_active;
      return isActive === true || t.status === 'active' || t.status === 'current';
    });
    const occupiedProperties = new Set(activeAssignments.map((t: any) => t.propertyId || (t as any).property_id));
    const occupancyRate = properties.length > 0
      ? Math.round((occupiedProperties.size / properties.length) * 100)
      : 0;

    const validCompliance = compliance.filter((c: any) => {
      if (!c.expiryDate) return true;
      return new Date(c.expiryDate) >= today;
    });
    const complianceRate = compliance.length > 0
      ? Math.round((validCompliance.length / compliance.length) * 100)
      : 100;

    const recentInspections = inspections.filter((i: any) => {
      if (!i.createdAt) return false;
      return new Date(i.createdAt) >= days90Ago;
    });
    const completedRecentInspections = recentInspections.filter((i: any) => i.status === 'completed');
    const inspectionCompletionRate = recentInspections.length > 0
      ? Math.round((completedRecentInspections.length / recentInspections.length) * 100)
      : 0;

    const completedMaintenance = maintenance.filter((m: any) => {
      if (m.status !== 'completed') return false;
      if (!m.completedAt) return false;
      return new Date(m.completedAt) >= days90Ago;
    });

    let avgResolutionDays = 0;
    if (completedMaintenance.length > 0) {
      const totalDays = completedMaintenance.reduce((sum: number, m: any) => {
        if (!m.createdAt || !m.completedAt) return sum;
        const created = new Date(m.createdAt);
        const completed = new Date(m.completedAt);
        return sum + Math.ceil((completed.getTime() - created.getTime()) / (1000 * 60 * 60 * 24));
      }, 0);
      avgResolutionDays = Math.round(totalDays / completedMaintenance.length * 10) / 10;
    }

    const openMaintenance = maintenance.filter((m: any) => m.status === 'open' || m.status === 'in_progress');
    const inProgressMaintenance = maintenance.filter((m: any) => m.status === 'in_progress');

    const inspectionsDueNext7Days = inspections.filter((i: any) => {
      if (i.status === 'completed' || i.status === 'cancelled') return false;
      if (!i.scheduledDate) return false;
      const scheduled = new Date(i.scheduledDate);
      return scheduled >= today && scheduled <= days7Future;
    });

    const inspectionsDueNext30Days = inspections.filter((i: any) => {
      if (i.status === 'completed' || i.status === 'cancelled') return false;
      if (!i.scheduledDate) return false;
      const scheduled = new Date(i.scheduledDate);
      return scheduled >= today && scheduled <= days30Future;
    });

    const complianceExpiringNext30Days = compliance.filter((c: any) => {
      if (!c.expiryDate) return false;
      const expiry = new Date(c.expiryDate);
      return expiry >= today && expiry <= days30Future;
    });

    const complianceExpiringNext90Days = compliance.filter((c: any) => {
      if (!c.expiryDate) return false;
      const expiry = new Date(c.expiryDate);
      return expiry >= today && expiry <= new Date(today.getTime() + 90 * 24 * 60 * 60 * 1000);
    });

    const totalAlerts = overdueInspections.length + overdueCompliance.length + urgentMaintenance.length;

    // Helper function to get badge class based on priority
    const getPriorityBadgeClass = (priority: string): string => {
      const priorityLower = (priority || '').toLowerCase();
      if (priorityLower === 'low') return 'badge-success';
      if (priorityLower === 'medium') return 'badge-warning';
      if (priorityLower === 'high' || priorityLower === 'urgent') return 'badge-danger';
      return 'badge-warning'; // default to warning for unknown priorities
    };

    // Branding
    const companyName = branding?.brandingName || "Inspect360";
    const hasLogo = !!branding?.logoUrl;
    const logoHtml = hasLogo
      ? `<img src="${sanitizeReportUrl(branding.logoUrl!)}" alt="${escapeHtml(companyName)}" class="cover-logo-img" />`
      : `<div class="cover-logo-text">${escapeHtml(companyName)}</div>`;
    const companyNameHtml = hasLogo
      ? `<div class="cover-company-name">${escapeHtml(companyName)}</div>`
      : '';
    const contactParts: string[] = [];
    if (branding?.brandingEmail) contactParts.push(escapeHtml(branding.brandingEmail));
    if (branding?.brandingPhone) contactParts.push(escapeHtml(branding.brandingPhone));
    if (branding?.brandingWebsite) contactParts.push(escapeHtml(branding.brandingWebsite));
    const contactInfoHtml = contactParts.length > 0
      ? `<div class="cover-contact">${contactParts.join(' &nbsp;|&nbsp; ')}</div>`
      : '';

    // Filter text
    const filterText = filterPropertyId
      ? `Property: ${properties.find(p => p.id === filterPropertyId)?.name || 'Selected'}`
      : filterBlockId
        ? `Block: ${blocks.find(b => b.id === filterBlockId)?.name || 'Selected'}`
        : 'All Portfolio';

    return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.5;
      color: #333;
      background: white;
    }
    .cover-page {
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      background: linear-gradient(135deg, #00D5CC 0%, #3B7A8C 100%);
      color: white;
      page-break-after: always;
      position: relative;
      overflow: hidden;
    }
    .cover-page::before {
      content: '';
      position: absolute;
      top: -50%;
      right: -20%;
      width: 60%;
      height: 200%;
      background: rgba(255, 255, 255, 0.03);
      transform: rotate(15deg);
    }
    .cover-content {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .cover-logo-container { margin-bottom: 32px; }
    .cover-logo-img {
      max-height: 100px;
      max-width: 280px;
      width: auto;
      height: auto;
      object-fit: contain;
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.15));
    }
    .cover-page::after {
      content: '';
      position: absolute;
      bottom: -30%;
      left: -10%;
      width: 40%;
      height: 150%;
      background: rgba(255, 255, 255, 0.02);
      transform: rotate(-10deg);
    }
    .cover-logo-text {
      font-size: 56px;
      font-weight: 800;
      letter-spacing: -2px;
      text-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    .cover-company-name {
      font-size: 28px;
      font-weight: 600;
      margin-top: 12px;
      opacity: 0.95;
      letter-spacing: 1px;
    }
    .cover-divider {
      width: 120px;
      height: 3px;
      background: rgba(255, 255, 255, 0.5);
      margin: 32px 0;
      border-radius: 2px;
    }
    .cover-title {
      font-size: 42px;
      font-weight: 700;
      margin-bottom: 12px;
      letter-spacing: 0.5px;
    }
    .cover-subtitle {
      font-size: 22px;
      font-weight: 400;
      margin-bottom: 20px;
      opacity: 0.9;
    }
    .cover-contact {
      position: absolute;
      bottom: 40px;
      font-size: 14px;
      opacity: 0.8;
      z-index: 1;
    }
    .cover-date {
      font-size: 16px;
      opacity: 0.9;
      margin-top: 16px;
    }
    .page {
      padding: 40px;
      page-break-after: always;
    }
    .page:last-child {
      page-break-after: auto;
    }
    .section-title {
      font-size: 26px;
      font-weight: 800;
      margin-bottom: 28px;
      color: #00D5CC;
      border-bottom: 4px solid #00D5CC;
      padding-bottom: 12px;
      padding-left: 4px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      position: relative;
    }
    .section-title::before {
      content: '';
      position: absolute;
      left: 0;
      bottom: -4px;
      width: 60px;
      height: 4px;
      background: #3B7A8C;
      border-radius: 2px;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 24px;
      margin-bottom: 32px;
    }
    .stat-card {
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border: 2px solid #e5e7eb;
      border-radius: 12px;
      padding: 24px;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .stat-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    .stat-value {
      font-size: 32px;
      font-weight: 700;
      color: #00D5CC;
      margin-bottom: 8px;
    }
    .stat-label {
      font-size: 14px;
      color: #666;
    }
    .alert-banner {
      background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
      border-left: 5px solid #dc2626;
      border-right: 2px solid #fca5a5;
      border-top: 2px solid #fca5a5;
      border-bottom: 2px solid #fca5a5;
      padding: 20px;
      margin-bottom: 24px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(220, 38, 38, 0.15);
    }
    .alert-title {
      font-weight: 700;
      color: #991b1b;
      margin-bottom: 4px;
    }
    .alert-text {
      color: #7f1d1d;
      font-size: 14px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 24px;
      border: 2px solid #00D5CC;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      background: white;
    }
    th {
      background: #00D5CC;
      color: white;
      padding: 14px 16px;
      text-align: left;
      font-weight: 700;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-right: 1px solid rgba(255, 255, 255, 0.2);
    }
    th:last-child {
      border-right: none;
    }
    td {
      padding: 12px 16px;
      border-bottom: 1px solid #e5e7eb;
      border-right: 1px solid #e5e7eb;
      font-size: 14px;
      vertical-align: middle;
    }
    td:last-child {
      border-right: none;
    }
    tbody tr {
      border-bottom: 1px solid #e5e7eb;
      transition: background-color 0.2s;
    }
    tbody tr:last-child {
      border-bottom: none;
    }
    tbody tr:hover {
      background: #f0fdfa;
    }
    tbody tr:nth-child(even) {
      background: #f9fafb;
    }
    tbody tr:nth-child(even):hover {
      background: #f0fdfa;
    }
    .badge {
      display: inline-block;
      padding: 6px 14px;
      border-radius: 16px;
      font-size: 12px;
      font-weight: 700;
      border: 1px solid transparent;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    .badge-danger {
      background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
      color: #991b1b;
      border-color: #fca5a5;
    }
    .badge-warning {
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      color: #92400e;
      border-color: #fcd34d;
    }
    .badge-success {
      background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
      color: #166534;
      border-color: #86efac;
    }
    .property-header {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
      margin-bottom: 24px;
    }
    .info-box {
      background: linear-gradient(135deg, #f9fafb 0%, #ffffff 100%);
      padding: 18px;
      border-radius: 8px;
      border-left: 5px solid #00D5CC;
      border-top: 1px solid #e5e7eb;
      border-right: 1px solid #e5e7eb;
      border-bottom: 1px solid #e5e7eb;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.05);
    }
    .info-label {
      font-size: 12px;
      color: #666;
      margin-bottom: 4px;
      text-transform: uppercase;
      font-weight: 600;
    }
    .info-value {
      font-size: 16px;
      font-weight: 600;
      color: #1a1a1a;
    }
    .subsection-title {
      font-size: 18px;
      font-weight: 700;
      color: #00D5CC;
      margin: 24px 0 16px;
      padding: 12px 16px;
      padding-bottom: 10px;
      border-bottom: 3px solid #00D5CC;
      background: linear-gradient(135deg, #f0fdfa 0%, #ffffff 100%);
      border-radius: 6px 6px 0 0;
      border-left: 4px solid #00D5CC;
      border-top: 1px solid #e5e7eb;
      border-right: 1px solid #e5e7eb;
    }
    .calendar-container {
      overflow-x: auto;
      margin: 20px 0;
      border: 2px solid #00D5CC;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }
    .calendar-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
      background: white;
    }
    .calendar-header {
      background: #00D5CC;
      color: white;
      padding: 10px 8px;
      text-align: center;
      font-weight: 700;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-right: 1px solid rgba(255, 255, 255, 0.2);
      min-width: 40px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-size: 10px;
    }
    .calendar-header:last-child {
      border-right: 1px solid rgba(255, 255, 255, 0.2);
    }
    .calendar-cell {
      padding: 8px 6px;
      border: 1px solid #e5e7eb;
      text-align: center;
      background: white;
    }
    .calendar-cell:hover {
      background: #f0fdfa;
    }
    .status-completed {
      background: #dcfce7;
      border: 1px solid #86efac;
      color: #166534;
    }
    .status-overdue {
      background: #fee2e2;
      border: 1px solid #fca5a5;
      color: #991b1b;
    }
    .status-due {
      background: #fef3c7;
      border: 1px solid #fde047;
      color: #92400e;
    }
    .status-scheduled {
      background: #dbeafe;
      border: 1px solid #93c5fd;
      color: #1e40af;
    }
    .status-missing {
      background: #f3f4f6;
      border: 1px solid #d1d5db;
      color: #6b7280;
    }
  </style>
</head>
<body>
  <!-- Cover Page -->
  <div class="cover-page">
    <div class="cover-content">
      <div class="cover-logo-container">
        ${logoHtml}
      </div>
      ${companyNameHtml}
      <div class="cover-divider"></div>
      <h1 class="cover-title">Portfolio Operations Report</h1>
      <p class="cover-subtitle">${escapeHtml(filterText)}</p>
      <div class="cover-date">Generated on ${format(new Date(), "MMMM d, yyyy 'at' h:mm a")}</div>
    </div>
    ${contactInfoHtml}
    </div>
  </div>

  <!-- Summary Statistics -->
  <div class="page">
    <h2 class="section-title">Summary Statistics</h2>
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-value">${properties.length}</div>
        <div class="stat-label">Total Properties</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${blocks.length}</div>
        <div class="stat-label">Total Blocks</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${occupancyRate}%</div>
        <div class="stat-label">Occupancy Rate</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${complianceRate}%</div>
        <div class="stat-label">Compliance Rate</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${inspectionCompletionRate}%</div>
        <div class="stat-label">Inspection Rate (90d)</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${avgResolutionDays}d</div>
        <div class="stat-label">Avg Resolution Time</div>
      </div>
    </div>

    ${totalAlerts > 0 ? `
    <div class="alert-banner">
      <div class="alert-title">${totalAlerts} Critical Alert${totalAlerts !== 1 ? 's' : ''} Require Attention</div>
      <div class="alert-text">
        ${overdueInspections.length} overdue inspections, ${overdueCompliance.length} expired compliance, ${urgentMaintenance.length} urgent maintenance
      </div>
    </div>
    ` : ''}
  </div>

  <!-- Action Required -->
  ${totalAlerts > 0 ? `
  <div class="page">
    <h2 class="section-title">Action Required</h2>
    ${overdueInspections.length > 0 ? `
    <h3 class="subsection-title">Overdue Inspections (${overdueInspections.length})</h3>
    <table>
      <thead>
        <tr>
          <th>Property</th>
          <th>Type</th>
          <th>Scheduled Date</th>
          <th>Days Overdue</th>
        </tr>
      </thead>
      <tbody>
        ${overdueInspections.slice(0, 20).map((i: any) => {
      const property = properties.find(p => p.id === i.propertyId);
      const daysOverdue = Math.floor((today.getTime() - new Date(i.scheduledDate).getTime()) / (1000 * 60 * 60 * 24));
      return `
          <tr>
            <td>${escapeHtml(property?.name || 'Unknown')}</td>
            <td>${escapeHtml(i.type || 'N/A')}</td>
            <td>${format(new Date(i.scheduledDate), 'MMM d, yyyy')}</td>
            <td><span class="badge badge-danger">${daysOverdue}d overdue</span></td>
          </tr>
          `;
    }).join('')}
      </tbody>
    </table>
    ` : ''}
    ${overdueCompliance.length > 0 ? `
    <h3 class="subsection-title">Expired Compliance (${overdueCompliance.length})</h3>
    <table>
      <thead>
        <tr>
          <th>Property</th>
          <th>Document Type</th>
          <th>Expiry Date</th>
          <th>Days Overdue</th>
        </tr>
      </thead>
      <tbody>
        ${overdueCompliance.slice(0, 20).map((c: any) => {
      const property = properties.find(p => p.id === c.propertyId);
      const daysOverdue = Math.floor((today.getTime() - new Date(c.expiryDate).getTime()) / (1000 * 60 * 60 * 24));
      return `
          <tr>
            <td>${escapeHtml(property?.name || 'Unknown')}</td>
            <td>${escapeHtml(c.documentType || 'N/A')}</td>
            <td>${format(new Date(c.expiryDate), 'MMM d, yyyy')}</td>
            <td><span class="badge badge-danger">${daysOverdue}d expired</span></td>
          </tr>
          `;
    }).join('')}
      </tbody>
    </table>
    ` : ''}
    ${urgentMaintenance.length > 0 ? `
    <h3 class="subsection-title">Urgent Maintenance (${urgentMaintenance.length})</h3>
    <table>
      <thead>
        <tr>
          <th>Property</th>
          <th>Title</th>
          <th>Priority</th>
          <th>Due Date</th>
        </tr>
      </thead>
      <tbody>
        ${urgentMaintenance.slice(0, 20).map((m: any) => {
      const property = properties.find(p => p.id === m.propertyId);
      return `
          <tr>
            <td>${escapeHtml(property?.name || 'Unknown')}</td>
            <td>${escapeHtml(m.title || 'N/A')}</td>
            <td><span class="badge ${getPriorityBadgeClass(m.priority)}">${escapeHtml(m.priority || 'N/A')}</span></td>
            <td>${m.dueDate ? format(new Date(m.dueDate), 'MMM d, yyyy') : 'N/A'}</td>
          </tr>
          `;
    }).join('')}
      </tbody>
    </table>
    ` : ''}
  </div>
  ` : ''}

  <!-- Upcoming Due -->
  <div class="page">
    <h2 class="section-title">Upcoming Due Items</h2>
    <table>
      <thead>
        <tr>
          <th>Category</th>
          <th>Timeframe</th>
          <th>Count</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Inspections</td>
          <td>Next 7 days</td>
          <td>${inspectionsDueNext7Days.length}</td>
        </tr>
        <tr>
          <td>Inspections</td>
          <td>Next 30 days</td>
          <td>${inspectionsDueNext30Days.length}</td>
        </tr>
        <tr>
          <td>Compliance</td>
          <td>Expiring in 30 days</td>
          <td>${complianceExpiringNext30Days.length}</td>
        </tr>
        <tr>
          <td>Compliance</td>
          <td>Expiring in 90 days</td>
          <td>${complianceExpiringNext90Days.length}</td>
        </tr>
      </tbody>
    </table>
  </div>

  ${(() => {
        const currentYear = new Date().getFullYear();
        const propertyPages: string[] = [];

        // Generate pages for each property
        properties.forEach((property: any) => {
          const propertyBlock = blocks.find((b: any) => b.id === property.blockId);
          const propertyInspections = inspections.filter((i: any) => i.propertyId === property.id);
          const propertyMaintenance = maintenance.filter((m: any) => m.propertyId === property.id);
          const propertyCompliance = compliance.filter((c: any) => c.propertyId === property.id);
          const propertyTenants = tenantAssignments.filter((t: any) => t.propertyId === property.id);

          // Get unique template IDs from inspections
          const templateIds = Array.from(new Set(propertyInspections.map((i: any) => i.templateId).filter(Boolean)));
          const templates = templateIds.map(id => {
            const inspection = propertyInspections.find((i: any) => i.templateId === id);
            return {
              id: id,
              name: inspection?.type || 'Unknown Template',
            };
          });

          // Calculate property stats
          const propertyOverdueInspections = propertyInspections.filter((i: any) => {
            if (i.status === 'completed' || i.status === 'cancelled') return false;
            if (!i.scheduledDate) return false;
            return new Date(i.scheduledDate) < today;
          });

          const propertyOverdueCompliance = propertyCompliance.filter((c: any) => {
            if (!c.expiryDate) return false;
            return new Date(c.expiryDate) < today;
          });

          const propertyUrgentMaintenance = propertyMaintenance.filter((m: any) => {
            if (m.status === 'completed' || m.status === 'closed') return false;
            return m.priority === 'urgent' || m.priority === 'high';
          });

          const activeTenants = propertyTenants.filter((t: any) => {
            const isActive = t.isActive !== undefined ? t.isActive : (t as any).is_active;
            return isActive === true || t.status === 'active' || t.status === 'current';
          });

          propertyPages.push(`
  <!-- Property: ${escapeHtml(property.name)} -->
  <div class="page">
    <h2 class="section-title">${escapeHtml(property.name)}</h2>
    
    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; margin-bottom: 24px;">
      <div style="background: #f9fafb; padding: 16px; border-radius: 8px; border-left: 4px solid #00D5CC;">
        <div style="font-size: 12px; color: #666; margin-bottom: 4px; text-transform: uppercase; font-weight: 600;">Block</div>
        <div style="font-size: 16px; font-weight: 600; color: #1a1a1a;">${propertyBlock ? escapeHtml(propertyBlock.name) : 'N/A'}</div>
      </div>
      <div style="background: #f9fafb; padding: 16px; border-radius: 8px; border-left: 4px solid #00D5CC;">
        <div style="font-size: 12px; color: #666; margin-bottom: 4px; text-transform: uppercase; font-weight: 600;">Tenants</div>
        <div style="font-size: 16px; font-weight: 600; color: #1a1a1a;">${activeTenants.length} Active</div>
      </div>
    </div>

    ${propertyOverdueInspections.length > 0 || propertyOverdueCompliance.length > 0 || propertyUrgentMaintenance.length > 0 ? `
    <div style="background: #fee2e2; border-left: 4px solid #dc2626; padding: 12px; margin-bottom: 24px; border-radius: 4px;">
      <div style="font-weight: 700; color: #991b1b; margin-bottom: 4px;">Alerts</div>
      <div style="color: #7f1d1d; font-size: 14px;">
        ${propertyOverdueInspections.length} overdue inspections, ${propertyOverdueCompliance.length} expired compliance, ${propertyUrgentMaintenance.length} urgent maintenance
      </div>
    </div>
    ` : ''}

    <h3 style="font-size: 18px; font-weight: 700; color: #00D5CC; margin: 24px 0 12px; padding-bottom: 8px; border-bottom: 2px solid #00D5CC;">Inspections (${propertyInspections.length})</h3>
    ${propertyInspections.length > 0 ? `
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Status</th>
          <th>Scheduled Date</th>
          <th>Completed Date</th>
        </tr>
      </thead>
      <tbody>
        ${propertyInspections.slice(0, 10).map((i: any) => {
            const statusBadge = i.status === 'completed'
              ? '<span class="badge badge-success">Completed</span>'
              : i.status === 'cancelled'
                ? '<span class="badge" style="background: #f3f4f6; color: #6b7280;">Cancelled</span>'
                : new Date(i.scheduledDate || 0) < today
                  ? '<span class="badge badge-danger">Overdue</span>'
                  : '<span class="badge badge-warning">Pending</span>';
            return `
          <tr>
            <td>${escapeHtml(i.type || 'N/A')}</td>
            <td>${statusBadge}</td>
            <td>${i.scheduledDate ? format(new Date(i.scheduledDate), 'MMM d, yyyy') : 'N/A'}</td>
            <td>${i.completedAt ? format(new Date(i.completedAt), 'MMM d, yyyy') : '-'}</td>
          </tr>
          `;
          }).join('')}
        ${propertyInspections.length > 10 ? `<tr><td colspan="4" style="text-align: center; color: #6b7280; padding: 12px;">... and ${propertyInspections.length - 10} more inspections</td></tr>` : ''}
      </tbody>
    </table>
    ` : '<p style="color: #6b7280; font-size: 14px;">No inspections found.</p>'}

    <h3 style="font-size: 18px; font-weight: 700; color: #00D5CC; margin: 24px 0 12px; padding-bottom: 8px; border-bottom: 2px solid #00D5CC;">Maintenance Requests (${propertyMaintenance.length})</h3>
    ${propertyMaintenance.length > 0 ? `
    <table>
      <thead>
        <tr>
          <th>Title</th>
          <th>Priority</th>
          <th>Status</th>
          <th>Due Date</th>
        </tr>
      </thead>
      <tbody>
        ${propertyMaintenance.slice(0, 10).map((m: any) => {
            const priorityBadge = '<span class="badge ' + getPriorityBadgeClass(m.priority) + '">' + escapeHtml(m.priority || 'N/A') + '</span>';
            const statusBadge = m.status === 'completed'
              ? '<span class="badge badge-success">Completed</span>'
              : m.status === 'in_progress'
                ? '<span class="badge" style="background: #dbeafe; color: #1e40af;">In Progress</span>'
                : '<span class="badge badge-warning">Open</span>';
            return `
          <tr>
            <td>${escapeHtml(m.title || 'N/A')}</td>
            <td>${priorityBadge}</td>
            <td>${statusBadge}</td>
            <td>${m.dueDate ? format(new Date(m.dueDate), 'MMM d, yyyy') : 'N/A'}</td>
          </tr>
          `;
          }).join('')}
        ${propertyMaintenance.length > 10 ? `<tr><td colspan="4" style="text-align: center; color: #6b7280; padding: 12px;">... and ${propertyMaintenance.length - 10} more requests</td></tr>` : ''}
      </tbody>
    </table>
    ` : '<p style="color: #6b7280; font-size: 14px;">No maintenance requests found.</p>'}

    <h3 style="font-size: 18px; font-weight: 700; color: #00D5CC; margin: 24px 0 12px; padding-bottom: 8px; border-bottom: 2px solid #00D5CC;">Compliance Documents (${propertyCompliance.length})</h3>
    ${propertyCompliance.length > 0 ? `
    <table>
      <thead>
        <tr>
          <th>Document Type</th>
          <th>Expiry Date</th>
          <th>Status</th>
        </tr>
      </thead>
      <tbody>
        ${propertyCompliance.map((c: any) => {
            const expiryDate = c.expiryDate ? new Date(c.expiryDate) : null;
            const daysUntilExpiry = expiryDate ? Math.floor((expiryDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24)) : null;
            let statusBadge = '';
            if (!expiryDate) {
              statusBadge = '<span class="badge badge-success">No Expiry</span>';
            } else if (daysUntilExpiry! < 0) {
              statusBadge = '<span class="badge badge-danger">Expired</span>';
            } else if (daysUntilExpiry! <= 30) {
              statusBadge = '<span class="badge badge-warning">Expiring Soon</span>';
            } else {
              statusBadge = '<span class="badge badge-success">Valid</span>';
            }
            return `
          <tr>
            <td>${escapeHtml(c.documentType || 'N/A')}</td>
            <td>${expiryDate ? format(expiryDate, 'MMM d, yyyy') : 'No expiry'}</td>
            <td>${statusBadge}</td>
          </tr>
          `;
          }).join('')}
      </tbody>
    </table>
    ` : '<p style="color: #6b7280; font-size: 14px;">No compliance documents found.</p>'}
  </div>
      `);
        });

        return propertyPages.join('');
      })()}
</body>
</html>
    `;
  }

  // Generate Dashboard PDF Report
  app.get("/api/reports/dashboard/pdf", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const orgId = user.organizationId;
      const filterBlockId = req.query.blockId as string | undefined;
      const filterPropertyId = req.query.propertyId as string | undefined;

      // Get organization branding
      const organization = await storage.getOrganization(orgId);
      const branding: ReportBrandingInfo = organization ? {
        logoUrl: organization.logoUrl,
        brandingName: organization.brandingName,
        brandingEmail: organization.brandingEmail,
        brandingPhone: organization.brandingPhone,
        brandingWebsite: organization.brandingWebsite,
      } : {};

      // Build base URL for images
      const protocol = req.protocol;
      const host = req.get('host');
      const baseUrl = `${protocol}://${host}`;

      // Fetch all data (similar to dashboard stats endpoint)
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

      const [allProperties, allBlocks, allInspections, allCompliance, allMaintenance, allTenantAssignments] = await Promise.all([
        storage.getPropertiesByOrganization(orgId),
        storage.getBlocksByOrganization(orgId),
        storage.getInspectionsByOrganization(orgId),
        storage.getComplianceDocuments(orgId),
        storage.getMaintenanceByOrganization(orgId),
        storage.getTenantAssignmentsByOrganization(orgId),
      ]);

      // Apply filters
      let properties = allProperties;
      let blocks = allBlocks;
      let inspections = allInspections;
      let compliance = allCompliance;
      let maintenance = allMaintenance;
      let tenantAssignments = allTenantAssignments;

      if (filterPropertyId) {
        properties = properties.filter((p: any) => p.id === filterPropertyId);
        inspections = inspections.filter((i: any) => i.propertyId === filterPropertyId);
        compliance = compliance.filter((c: any) => c.propertyId === filterPropertyId);
        maintenance = maintenance.filter((m: any) => m.propertyId === filterPropertyId);
        tenantAssignments = tenantAssignments.filter((t: any) => t.propertyId === filterPropertyId);
        const propertyBlock = allProperties.find((p: any) => p.id === filterPropertyId);
        if (propertyBlock?.blockId) {
          blocks = blocks.filter((b: any) => b.id === propertyBlock.blockId);
        }
      } else if (filterBlockId) {
        const blockPropertyIds = new Set(allProperties.filter((p: any) => p.blockId === filterBlockId).map((p: any) => p.id));
        blocks = blocks.filter((b: any) => b.id === filterBlockId);
        properties = properties.filter((p: any) => p.blockId === filterBlockId);
        inspections = inspections.filter((i: any) => i.blockId === filterBlockId || (i.propertyId && blockPropertyIds.has(i.propertyId)));
        compliance = compliance.filter((c: any) => c.blockId === filterBlockId || (c.propertyId && blockPropertyIds.has(c.propertyId)));
        maintenance = maintenance.filter((m: any) => blockPropertyIds.has(m.propertyId));
        tenantAssignments = tenantAssignments.filter((t: any) => blockPropertyIds.has(t.propertyId));
      }

      // Generate HTML for the dashboard report
      const html = generateDashboardReportHTML(
        properties,
        blocks,
        inspections,
        compliance,
        maintenance,
        tenantAssignments,
        filterBlockId,
        filterPropertyId,
        branding,
        baseUrl
      );

      let browser;
      try {
        browser = await launchPuppeteerBrowser();
        const page = await browser.newPage();
        await page.setContent(html, {
          waitUntil: "networkidle0",
        });

        const pdf = await page.pdf({
          format: "A4",
          landscape: false,
          printBackground: true,
          margin: {
            top: "15mm",
            right: "12mm",
            bottom: "15mm",
            left: "12mm",
          },
        });

        res.contentType("application/pdf");
        const filterText = filterPropertyId
          ? `property-${filterPropertyId}`
          : filterBlockId
            ? `block-${filterBlockId}`
            : 'all-portfolio';
        res.setHeader("Content-Disposition", `attachment; filename="dashboard-report-${filterText}-${new Date().toISOString().split('T')[0]}.pdf"`);
        res.send(Buffer.from(pdf));
      } finally {
        if (browser) {
          await browser.close();
        }
      }
    } catch (error) {
      console.error("Error generating dashboard PDF:", error);
      res.status(500).json({ message: "Failed to generate dashboard PDF" });
    }
  });

  // Send Comparison Report to Finance Department
  app.post("/api/comparison-reports/:id/send-to-finance", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const { id } = req.params;
      const { includePdf } = req.body;

      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const organization = await storage.getOrganization(user.organizationId);
      if (!organization) {
        return res.status(404).json({ message: "Organization not found" });
      }

      if (!organization.financeEmail) {
        return res.status(400).json({ message: "Finance email not configured. Please set the finance department email in Settings." });
      }

      const report = await storage.getComparisonReport(id);
      if (!report) {
        return res.status(404).json({ message: "Comparison report not found" });
      }

      if (report.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const items = await storage.getComparisonReportItems(id);
      const property = await storage.getProperty(report.propertyId);
      const block = property?.blockId ? await storage.getBlock(property.blockId) : null;
      const checkInInspection = await storage.getInspection(report.checkInInspectionId);
      const checkOutInspection = await storage.getInspection(report.checkOutInspectionId);

      // Get tenant info if available
      let tenantName = 'N/A';
      if (report.tenantId) {
        const tenant = await storage.getUser(report.tenantId);
        if (tenant) {
          tenantName = `${tenant.firstName || ''} ${tenant.lastName || ''}`.trim() || tenant.email;
        }
      }

      // Calculate totals
      let totalEstimatedCost = 0;
      let totalDepreciation = 0;
      let totalFinalCost = 0;
      let tenantLiableAmount = 0;
      let landlordLiableAmount = 0;
      let sharedLiableAmount = 0;
      let waivedAmount = 0;
      let tenantLiableCount = 0;
      let landlordLiableCount = 0;
      let sharedCount = 0;
      let waivedCount = 0;

      items.forEach((item: any) => {
        const estimatedCost = parseFloat(item.estimatedCost || '0');
        const depreciationAmount = parseFloat(item.depreciationAmount || '0');
        const finalCost = parseFloat(item.finalCost || '0');

        totalEstimatedCost += estimatedCost;
        totalDepreciation += depreciationAmount;
        totalFinalCost += finalCost;

        switch (item.liability) {
          case 'tenant':
            tenantLiableAmount += finalCost;
            tenantLiableCount++;
            break;
          case 'landlord':
            landlordLiableAmount += finalCost;
            landlordLiableCount++;
            break;
          case 'shared':
            sharedLiableAmount += finalCost;
            sharedCount++;
            break;
          case 'waived':
            waivedAmount += finalCost;
            waivedCount++;
            break;
        }
      });

      const senderName = `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.email;
      const companyName = organization.brandingName || organization.name;

      // Prepare PDF attachment if requested
      let pdfAttachment;
      if (includePdf) {
        try {
          const branding: ReportBrandingInfo = {
            logoUrl: organization.logoUrl,
            brandingName: organization.brandingName,
            brandingEmail: organization.brandingEmail,
            brandingPhone: organization.brandingPhone,
            brandingWebsite: organization.brandingWebsite,
          };

          const comments = await storage.getComparisonComments(id);
          const html = generateComparisonReportHTML(
            report,
            items,
            property,
            block,
            checkInInspection,
            checkOutInspection,
            comments.filter((c: any) => !c.isInternal),
            branding
          );

          const browser = await launchPuppeteerBrowser();
          try {
            const page = await browser.newPage();
            await page.setContent(html, { waitUntil: "networkidle0" });
            const pdf = await page.pdf({
              format: "A4",
              landscape: true,
              printBackground: true,
              margin: { top: "15mm", right: "12mm", bottom: "15mm", left: "12mm" },
            });
            pdfAttachment = {
              filename: `comparison-report-${id}.pdf`,
              content: Buffer.from(pdf)
            };
          } finally {
            await browser.close();
          }
        } catch (pdfError) {
          console.error("Error generating PDF for finance email:", pdfError);
        }
      }

      await sendComparisonReportToFinance(organization.financeEmail, {
        reportId: id,
        propertyName: property?.name || 'Unknown Property',
        propertyAddress: property?.address || '',
        blockName: block?.name || '',
        tenantName,
        checkInDate: checkInInspection?.completedDate
          ? format(new Date(checkInInspection.completedDate), 'dd MMM yyyy')
          : 'N/A',
        checkOutDate: checkOutInspection?.completedDate
          ? format(new Date(checkOutInspection.completedDate), 'dd MMM yyyy')
          : 'N/A',
        totalEstimatedCost,
        totalDepreciation,
        totalFinalCost,
        tenantLiableAmount,
        landlordLiableAmount,
        sharedLiableAmount,
        waivedAmount,
        itemsCount: items.length,
        tenantLiableCount,
        landlordLiableCount,
        sharedCount,
        waivedCount,
        status: report.status,
        signedByOperator: !!report.operatorSignature,
        signedByTenant: !!report.tenantSignature,
        operatorSignature: report.operatorSignature || undefined,
        tenantSignature: report.tenantSignature || undefined,
        operatorSignedAt: report.operatorSignedAt
          ? format(new Date(report.operatorSignedAt), 'dd MMM yyyy HH:mm')
          : undefined,
        tenantSignedAt: report.tenantSignedAt
          ? format(new Date(report.tenantSignedAt), 'dd MMM yyyy HH:mm')
          : undefined,
        generatedAt: format(new Date(), 'dd MMM yyyy HH:mm'),
        senderName,
        companyName,
        pdfAttachment,
      });

      res.json({
        success: true,
        message: `Report sent to finance department (${organization.financeEmail})`
      });
    } catch (error) {
      console.error("Error sending comparison report to finance:", error);
      res.status(500).json({ message: "Failed to send report to finance department" });
    }
  });

  // HTML generation function for Comparison Report
  function generateComparisonReportHTML(
    report: any,
    items: any[],
    property: any,
    block: any,
    checkInInspection: any,
    checkOutInspection: any,
    comments: any[],
    branding?: ReportBrandingInfo,
    baseUrl?: string
  ) {
    const escapeHtml = (str: string) => {
      if (!str) return '';
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    };

    // Sanitize and convert URLs for PDF generation
    // Sanitize and convert URLs for PDF generation (same logic as inspection report)
    const sanitizeReportUrl = (url: string): string => {
      if (!url || typeof url !== 'string') return '';

      const trimmed = url.trim();
      const lower = trimmed.toLowerCase();

      // Handle relative URLs (convert to absolute using baseUrl) - same as inspection report
      if (trimmed.startsWith('/') && baseUrl) {
        const absoluteUrl = `${baseUrl}${trimmed}`;
        return escapeHtml(absoluteUrl);
      }

      // Allow only safe protocols via whitelist
      const safeProtocols = ['https://', 'http://'];
      const isSafeProtocol = safeProtocols.some(protocol => lower.startsWith(protocol));

      if (!isSafeProtocol) {
        // For data URLs, only allow safe image types (NO SVG - can contain XSS)
        const safeDataImages = [
          'data:image/png',
          'data:image/jpeg',
          'data:image/jpg',
          'data:image/gif',
          'data:image/webp',
        ];

        const isSafeDataUrl = safeDataImages.some(prefix => lower.startsWith(prefix));

        if (!isSafeDataUrl) {
          // Reject all other protocols/schemes (javascript:, data:image/svg+xml, vbscript:, etc.)
          console.warn(`Blocked potentially unsafe URL: ${url.substring(0, 50)}...`);
          return '';
        }
      }

      // Return escaped URL (escape special chars for HTML attribute safety)
      return escapeHtml(trimmed);
    };

    // Branding for cover page
    const companyName = branding?.brandingName || "Inspect360";
    const hasLogo = !!branding?.logoUrl;
    const logoHtml = hasLogo
      ? `<img src="${sanitizeReportUrl(branding.logoUrl!)}" alt="${escapeHtml(companyName)}" class="cover-logo-img" />`
      : '';
    // Always show company name, below logo if logo exists
    const companyNameHtml = `<div class="cover-company-name">${escapeHtml(companyName)}</div>`;
    const contactParts: string[] = [];
    if (branding?.brandingEmail) contactParts.push(escapeHtml(branding.brandingEmail));
    if (branding?.brandingPhone) contactParts.push(escapeHtml(branding.brandingPhone));
    if (branding?.brandingWebsite) contactParts.push(escapeHtml(branding.brandingWebsite));
    const contactInfoHtml = contactParts.length > 0
      ? `<div class="cover-contact">${contactParts.join(' &nbsp;|&nbsp; ')}</div>`
      : '';

    // Status badge color
    const statusColors: Record<string, { bg: string; color: string }> = {
      draft: { bg: '#e5e7eb', color: '#374151' },
      under_review: { bg: '#00D5CC', color: 'white' },
      awaiting_signatures: { bg: '#f59e0b', color: 'white' },
      signed: { bg: '#10b981', color: 'white' },
      filed: { bg: '#6b7280', color: 'white' },
    };
    const statusStyle = statusColors[report.status] || statusColors.draft;
    const statusLabel = report.status.replace(/_/g, ' ').replace(/\b\w/g, (l: string) => l.toUpperCase());

    // Calculate totals
    const totalEstimated = items.reduce((sum, item) => sum + parseFloat(item.estimatedCost || '0'), 0);
    const totalDepreciation = items.reduce((sum, item) => sum + parseFloat(item.depreciation || '0'), 0);
    const totalFinal = items.reduce((sum, item) => sum + parseFloat(item.finalCost || '0'), 0);
    const tenantLiableCount = items.filter(i => i.liabilityDecision === 'tenant').length;
    const landlordLiableCount = items.filter(i => i.liabilityDecision === 'landlord').length;
    const sharedCount = items.filter(i => i.liabilityDecision === 'shared').length;
    const waivedCount = items.filter(i => i.liabilityDecision === 'waived').length;

    // Liability badge colors
    const liabilityColors: Record<string, { bg: string; color: string }> = {
      tenant: { bg: '#ef4444', color: 'white' },
      landlord: { bg: '#3b82f6', color: 'white' },
      shared: { bg: '#f59e0b', color: 'white' },
      waived: { bg: '#6b7280', color: 'white' },
    };

    // Generate item rows
    const itemRows = items.map((item, index) => {
      const aiAnalysis = item.aiComparisonJson || {};
      const liability = liabilityColors[item.liabilityDecision] || liabilityColors.tenant;
      const liabilityLabel = item.liabilityDecision ?
        item.liabilityDecision.replace(/_/g, ' ').replace(/\b\w/g, (l: string) => l.toUpperCase()) :
        'Pending';

      const checkInPhotos = aiAnalysis.checkInPhotos || [];
      const checkOutPhotos = aiAnalysis.checkOutPhotos || [];

      return `
        <div class="item-card" style="page-break-inside: avoid; margin-bottom: 20px;">
          <div class="item-header" style="display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; background: #f9fafb; border-radius: 8px 8px 0 0; border: 1px solid #e5e7eb; border-bottom: none;">
            <div style="display: flex; align-items: center; gap: 12px;">
              <span style="font-weight: 700; color: #00D5CC; font-size: 14px;">#${index + 1}</span>
              <span style="font-weight: 600; font-size: 14px;">${escapeHtml(item.itemRef || item.fieldKey || 'Item')}</span>
            </div>
            <span style="padding: 4px 12px; border-radius: 4px; font-size: 11px; font-weight: 600; background: ${liability.bg}; color: ${liability.color};">
              ${liabilityLabel}
            </span>
          </div>
          <div style="padding: 16px; border: 1px solid #e5e7eb; border-radius: 0 0 8px 8px;">
            ${item.aiSummary ? `
              <div style="margin-bottom: 16px;">
                <div style="font-size: 11px; text-transform: uppercase; color: #666; margin-bottom: 4px; font-weight: 600;">AI Analysis</div>
                <div style="font-size: 13px; color: #374151; line-height: 1.5;">${escapeHtml(item.aiSummary)}</div>
              </div>
            ` : ''}
            
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; margin-bottom: 16px;">
              <div>
                <div style="font-size: 11px; text-transform: uppercase; color: #666; margin-bottom: 8px; font-weight: 600;">Check-In Photos</div>
                ${checkInPhotos.length > 0 ? `
                  <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    ${checkInPhotos.map((photo: string) => {
        const sanitizedUrl = sanitizeReportUrl(photo);
        if (!sanitizedUrl) {
          console.warn(`[PDF] Skipping invalid check-in photo URL: ${photo.substring(0, 50)}...`);
          return '';
        }
        return `<img src="${sanitizedUrl}" alt="Check-in photo" style="max-width: 150px; max-height: 120px; width: auto; height: auto; object-fit: contain; border-radius: 4px; border: 1px solid #e5e7eb; background: #f9fafb;" />`;
      }).filter((html: string) => html !== '').join('')}
                  </div>
                ` : '<span style="font-size: 12px; color: #999;">No photos</span>'}
              </div>
              <div>
                <div style="font-size: 11px; text-transform: uppercase; color: #666; margin-bottom: 8px; font-weight: 600;">Check-Out Photos</div>
                ${checkOutPhotos.length > 0 ? `
                  <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    ${checkOutPhotos.map((photo: string) => {
        const sanitizedUrl = sanitizeReportUrl(photo);
        if (!sanitizedUrl) {
          console.warn(`[PDF] Skipping invalid check-out photo URL: ${photo.substring(0, 50)}...`);
          return '';
        }
        return `<img src="${sanitizedUrl}" alt="Check-out photo" style="max-width: 150px; max-height: 120px; width: auto; height: auto; object-fit: contain; border-radius: 4px; border: 1px solid #e5e7eb; background: #f9fafb;" />`;
      }).filter((html: string) => html !== '').join('')}
                  </div>
                ` : '<span style="font-size: 12px; color: #999;">No photos</span>'}
              </div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; padding-top: 12px; border-top: 1px solid #e5e7eb;">
              <div>
                <div style="font-size: 11px; text-transform: uppercase; color: #666; margin-bottom: 2px;">Estimated Cost</div>
                <div style="font-size: 16px; font-weight: 700; color: #374151;">Â£${parseFloat(item.estimatedCost || '0').toFixed(2)}</div>
              </div>
              <div>
                <div style="font-size: 11px; text-transform: uppercase; color: #666; margin-bottom: 2px;">Depreciation</div>
                <div style="font-size: 16px; font-weight: 700; color: #f59e0b;">-Â£${parseFloat(item.depreciation || '0').toFixed(2)}</div>
              </div>
              <div>
                <div style="font-size: 11px; text-transform: uppercase; color: #666; margin-bottom: 2px;">Final Cost</div>
                <div style="font-size: 16px; font-weight: 700; color: #00D5CC;">Â£${parseFloat(item.finalCost || '0').toFixed(2)}</div>
              </div>
            </div>
            
            ${aiAnalysis.notes_comparison ? `
              <div style="margin-top: 12px; background: #fef3c7; border-left: 3px solid #f59e0b; padding: 12px; border-radius: 4px;">
                <div style="font-weight: 500; color: #92400e; margin-bottom: 4px; font-size: 13px;">Notes Comparison:</div>
                <div style="color: #78350f; font-size: 14px; white-space: pre-wrap;">${escapeHtml(aiAnalysis.notes_comparison)}</div>
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }).join('');

    // Generate comments section
    const commentsHtml = comments.length > 0 ? `
      <div style="page-break-before: always;">
        <h2 style="font-size: 20px; font-weight: 700; color: #1a1a1a; margin-bottom: 16px; border-bottom: 2px solid #00D5CC; padding-bottom: 8px;">Discussion Thread</h2>
        ${comments.map(comment => `
          <div style="padding: 12px; margin-bottom: 12px; background: #f9fafb; border-radius: 8px; border-left: 3px solid #00D5CC;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <span style="font-weight: 600; font-size: 13px;">${escapeHtml(comment.authorName)}</span>
              <span style="font-size: 11px; color: #666;">${format(new Date(comment.createdAt), "MMM d, yyyy 'at' h:mm a")}</span>
            </div>
            <div style="font-size: 13px; color: #374151; line-height: 1.5;">${escapeHtml(comment.content)}</div>
          </div>
        `).join('')}
      </div>
    ` : '';

    // Helper function to render signature (data URL or text)
    const renderSignature = (signature: string | null | undefined): string => {
      if (!signature) {
        return `
          <div style="padding: 16px; background: #fef2f2; border-radius: 6px; border: 1px solid #fecaca; text-align: center;">
            <span style="color: #dc2626; font-size: 13px;">Pending Signature</span>
          </div>
        `;
      }

      const trimmedSig = signature.trim();
      if (trimmedSig.startsWith('data:image/')) {
        // For data URLs, use single quotes in the src attribute to avoid issues with double quotes in the data URL
        // Only escape single quotes if they exist (though they shouldn't in base64)
        const safeDataUrl = trimmedSig.replace(/'/g, '&#039;');
        return `
          <div style="padding: 16px; background: #f0fdf4; border-radius: 6px; border: 1px solid #bbf7d0;">
            <img src='${safeDataUrl}' alt="Signature" style="max-width: 100%; max-height: 100px; height: auto; object-fit: contain; margin-bottom: 8px; display: block; background: white; padding: 4px;" />
          </div>
        `;
      } else {
        // For text signatures (backward compatibility)
        return `
          <div style="padding: 16px; background: #f0fdf4; border-radius: 6px; border: 1px solid #bbf7d0;">
            <div style="font-size: 18px; font-weight: 700; color: #166534; font-style: italic; margin-bottom: 8px;">${escapeHtml(trimmedSig)}</div>
          </div>
        `;
      }
    };

    // Signature section
    const signatureHtml = `
      <div style="page-break-before: always;">
        <h2 style="font-size: 20px; font-weight: 700; color: #1a1a1a; margin-bottom: 16px; border-bottom: 2px solid #00D5CC; padding-bottom: 8px;">Electronic Signatures</h2>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 24px;">
          <div style="padding: 20px; border: 1px solid #e5e7eb; border-radius: 8px;">
            <div style="font-weight: 600; margin-bottom: 12px; font-size: 14px;">Operator Signature</div>
            ${renderSignature(report.operatorSignature)}
            ${report.operatorSignature ? `
              <div style="font-size: 11px; color: #166534; margin-top: 8px;">
                Signed on ${report.operatorSignedAt ? format(new Date(report.operatorSignedAt), "MMMM d, yyyy 'at' h:mm a") : 'N/A'}
              </div>
            ` : ''}
          </div>
          <div style="padding: 20px; border: 1px solid #e5e7eb; border-radius: 8px;">
            <div style="font-weight: 600; margin-bottom: 12px; font-size: 14px;">Tenant Signature</div>
            ${renderSignature(report.tenantSignature)}
            ${report.tenantSignature ? `
              <div style="font-size: 11px; color: #166534; margin-top: 8px;">
                Signed on ${report.tenantSignedAt ? format(new Date(report.tenantSignedAt), "MMMM d, yyyy 'at' h:mm a") : 'N/A'}
              </div>
            ` : ''}
          </div>
        </div>
        <div style="margin-top: 16px; padding: 12px; background: #f9fafb; border-radius: 6px; font-size: 11px; color: #666; text-align: center;">
          Electronic signatures on this document are legally binding under the Electronic Signatures in Global and National Commerce Act (E-SIGN Act).
        </div>
      </div>
    `;

    return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.5;
      color: #333;
      background: white;
    }
    /* Cover Page - Landscape optimized */
    .cover-page {
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      background: linear-gradient(135deg, #00D5CC 0%, #3B7A8C 100%);
      color: white;
      page-break-after: always;
      position: relative;
      overflow: hidden;
    }
    .cover-page::before {
      content: '';
      position: absolute;
      top: -50%;
      right: -20%;
      width: 60%;
      height: 200%;
      background: rgba(255, 255, 255, 0.03);
      transform: rotate(15deg);
    }
    .cover-content {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .cover-logo-container { 
      margin-bottom: 32px; 
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
    }
    .cover-logo-img {
      max-height: 120px;
      max-width: 320px;
      width: auto;
      height: auto;
      object-fit: contain;
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.15));
    }
    .cover-logo-text {
      font-size: 56px;
      font-weight: 800;
      letter-spacing: -2px;
      text-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    .cover-company-name {
      font-size: 24px;
      font-weight: 600;
      opacity: 0.95;
    }
    .cover-divider {
      width: 100px;
      height: 3px;
      background: rgba(255, 255, 255, 0.5);
      margin: 28px 0;
      border-radius: 2px;
    }
    .cover-title { font-size: 38px; font-weight: 700; margin-bottom: 12px; }
    .cover-subtitle { font-size: 18px; opacity: 0.9; margin-bottom: 8px; }
    .cover-date { font-size: 14px; opacity: 0.8; margin-top: 16px; }
    .cover-contact {
      position: absolute;
      bottom: 32px;
      font-size: 13px;
      opacity: 0.8;
      z-index: 1;
    }
    /* Content area - Landscape optimized */
    .content { padding: 28px 36px; }
    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 3px solid #00D5CC;
      padding-bottom: 16px;
      margin-bottom: 24px;
    }
    .page-title { font-size: 26px; font-weight: 800; color: #00D5CC; }
    .page-date { font-size: 13px; color: #666; }
    .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin: 24px 0; }
    .stat-card { background: #f9fafb; padding: 16px; border-radius: 8px; border-left: 4px solid #00D5CC; }
    .stat-label { font-size: 11px; color: #666; text-transform: uppercase; margin-bottom: 6px; font-weight: 600; }
    .stat-value { font-size: 28px; font-weight: 700; color: #00D5CC; }
    .section-title { font-size: 20px; font-weight: 700; color: #1a1a1a; margin-top: 32px; margin-bottom: 14px; border-bottom: 2px solid #00D5CC; padding-bottom: 8px; }
    .info-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 24px; }
    .info-card { padding: 16px; background: #f9fafb; border-radius: 8px; }
    .info-label { font-size: 11px; color: #666; text-transform: uppercase; margin-bottom: 4px; font-weight: 600; }
    .info-value { font-size: 14px; font-weight: 600; color: #1a1a1a; }
    .footer { margin-top: 24px; padding-top: 12px; border-top: 1px solid #e5e7eb; font-size: 11px; color: #6b7280; text-align: center; }
  </style>
</head>
<body>
  <div class="cover-page">
    <div class="cover-content">
      <div class="cover-logo-container">
        ${logoHtml}
        ${companyNameHtml}
      </div>
      <div class="cover-divider"></div>
      <div class="cover-title">Comparison Report</div>
      <div class="cover-subtitle">${escapeHtml(property?.name || property?.unitNumber || 'Property')}</div>
      <div class="cover-subtitle">${escapeHtml(block?.name || '')}</div>
      <div class="cover-date">Generated on ${format(new Date(report.createdAt), "MMMM d, yyyy 'at' h:mm a")}</div>
    </div>
    ${contactInfoHtml}
  </div>

  <div class="content">
    <div class="page-header">
      <div class="page-title">Check-In vs Check-Out Comparison</div>
      <div style="display: flex; align-items: center; gap: 12px;">
        <span style="padding: 6px 14px; border-radius: 6px; font-size: 12px; font-weight: 600; background: ${statusStyle.bg}; color: ${statusStyle.color};">
          ${statusLabel}
        </span>
        <div class="page-date">${format(new Date(), "MMMM d, yyyy")}</div>
      </div>
    </div>

    <!-- Property & Inspection Info -->
    <div class="info-grid">
      <div class="info-card">
        <div class="info-label">Property</div>
        <div class="info-value">${escapeHtml(property?.name || property?.unitNumber || 'N/A')}</div>
        <div style="font-size: 12px; color: #666; margin-top: 4px;">${escapeHtml(property?.address || '')}</div>
      </div>
      <div class="info-card">
        <div class="info-label">Check-In Inspection</div>
        <div class="info-value">${checkInInspection?.inspectionDate ? format(new Date(checkInInspection.inspectionDate), "MMM d, yyyy") : 'N/A'}</div>
        <div style="font-size: 12px; color: #666; margin-top: 4px;">Type: ${escapeHtml(checkInInspection?.type || 'Check-In')}</div>
      </div>
      <div class="info-card">
        <div class="info-label">Check-Out Inspection</div>
        <div class="info-value">${checkOutInspection?.inspectionDate ? format(new Date(checkOutInspection.inspectionDate), "MMM d, yyyy") : 'N/A'}</div>
        <div style="font-size: 12px; color: #666; margin-top: 4px;">Type: ${escapeHtml(checkOutInspection?.type || 'Check-Out')}</div>
      </div>
    </div>

    <!-- Cost Summary -->
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">Total Items</div>
        <div class="stat-value">${items.length}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Estimated Cost</div>
        <div class="stat-value">Â£${totalEstimated.toFixed(2)}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Depreciation</div>
        <div class="stat-value" style="color: #f59e0b;">-Â£${totalDepreciation.toFixed(2)}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Final Amount</div>
        <div class="stat-value">Â£${totalFinal.toFixed(2)}</div>
      </div>
    </div>

    <!-- Liability Breakdown -->
    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 24px;">
      <div style="padding: 12px; background: #fef2f2; border-radius: 6px; text-align: center;">
        <div style="font-size: 24px; font-weight: 700; color: #dc2626;">${tenantLiableCount}</div>
        <div style="font-size: 11px; color: #dc2626; text-transform: uppercase;">Tenant Liable</div>
      </div>
      <div style="padding: 12px; background: #eff6ff; border-radius: 6px; text-align: center;">
        <div style="font-size: 24px; font-weight: 700; color: #2563eb;">${landlordLiableCount}</div>
        <div style="font-size: 11px; color: #2563eb; text-transform: uppercase;">Landlord</div>
      </div>
      <div style="padding: 12px; background: #fefce8; border-radius: 6px; text-align: center;">
        <div style="font-size: 24px; font-weight: 700; color: #ca8a04;">${sharedCount}</div>
        <div style="font-size: 11px; color: #ca8a04; text-transform: uppercase;">Shared</div>
      </div>
      <div style="padding: 12px; background: #f3f4f6; border-radius: 6px; text-align: center;">
        <div style="font-size: 24px; font-weight: 700; color: #6b7280;">${waivedCount}</div>
        <div style="font-size: 11px; color: #6b7280; text-transform: uppercase;">Waived</div>
      </div>
    </div>

    <!-- Item-by-Item Comparison -->
    <h2 class="section-title">Item-by-Item Comparison</h2>
    ${items.length > 0 ? itemRows : '<div style="text-align: center; padding: 40px; color: #999;">No items in this comparison report</div>'}

    ${commentsHtml}
    
    ${signatureHtml}

    <div class="footer">
      <p>Report generated by ${escapeHtml(companyName)}</p>
    </div>
  </div>
</body>
</html>
    `;
  }

  // ==================== COMPLIANCE ROUTES ====================

  app.post("/api/compliance", isAuthenticated, requireRole("owner", "compliance"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Validate request body
      // Note: expiryDate is coerced to Date by the schema using z.coerce.date()
      const validation = insertComplianceDocumentSchema.omit({ organizationId: true, uploadedBy: true }).safeParse(req.body);
      if (!validation.success) {
        console.error("Compliance document validation errors:", validation.error.errors);
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      const { documentType, documentUrl, expiryDate, propertyId, blockId } = validation.data;
      const propertyIds = req.body.propertyIds as string[] | undefined;

      // Create the main document (for block or single property)
      const doc = await storage.createComplianceDocument({
        organizationId: user.organizationId,
        propertyId: propertyId || null,
        blockId: blockId || null,
        documentType,
        documentUrl,
        // expiryDate is already a Date object from z.coerce.date() validation
        expiryDate: expiryDate || null,
        uploadedBy: userId,
      });

      // If propertyIds are provided, also create documents for each property
      if (propertyIds && Array.isArray(propertyIds) && propertyIds.length > 0) {
        for (const propId of propertyIds) {
          await storage.createComplianceDocument({
            organizationId: user.organizationId,
            propertyId: propId,
            blockId: null,
            documentType,
            documentUrl,
            expiryDate: expiryDate || null,
            uploadedBy: userId,
          });
        }
      }

      res.json(doc);
    } catch (error) {
      console.error("Error creating compliance document:", error);
      res.status(500).json({ message: "Failed to create compliance document" });
    }
  });

  app.get("/api/compliance", isAuthenticated, requireRole("owner", "compliance"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.json([]);
      }

      const docs = await storage.getComplianceDocuments(user.organizationId);
      res.json(docs);
    } catch (error) {
      console.error("Error fetching compliance documents:", error);
      res.status(500).json({ message: "Failed to fetch compliance documents" });
    }
  });

  // Download compliance document (serves file with proper headers for download)
  app.get("/api/compliance/:id/view", isAuthenticated, requireRole("owner", "compliance"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "No organization found" });
      }

      const docId = req.params.id;
      const doc = await storage.getComplianceDocument(docId);

      if (!doc || doc.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Compliance document not found" });
      }

      // Get the file from object storage
      const objectStorageService = new ObjectStorageService();

      // Normalize documentUrl - it might be absolute URL or relative path
      let documentPath = doc.documentUrl;
      if (documentPath.startsWith('http://') || documentPath.startsWith('https://')) {
        // Extract pathname from absolute URL
        try {
          const url = new URL(documentPath);
          documentPath = url.pathname;
        } catch (e) {
          // If URL parsing fails, try to extract path manually
          const match = documentPath.match(/\/objects\/[^?]+/);
          if (match) {
            documentPath = match[0];
          }
        }
      }

      // Ensure path starts with /objects/
      if (!documentPath.startsWith('/objects/')) {
        documentPath = `/objects/${documentPath.replace(/^\/+/, '')}`;
      }

      const objectFile = await objectStorageService.getObjectEntityFile(documentPath);

      // Read file buffer to detect actual file type (read first 4KB for detection)
      let fileBuffer: Buffer | undefined;
      let detectedContentType = 'application/octet-stream';

      try {
        // Verify file exists
        const [fileExists] = await objectFile.exists();
        if (!fileExists) {
          console.error(`[Compliance View] File does not exist: ${objectFile.name}`);
          return res.status(404).json({ message: "Document file not found" });
        }

        fileBuffer = await fs.readFile(objectFile.name);

        if (!fileBuffer || fileBuffer.length === 0) {
          console.error(`[Compliance View] File is empty: ${objectFile.name}`);
        } else {
          // Read first 4KB for detection (magic bytes are usually at the start)
          const sampleBuffer = fileBuffer.slice(0, Math.min(4096, fileBuffer.length));
          detectedContentType = detectFileMimeType(sampleBuffer);

          // Log first bytes for debugging
          const firstBytes = Array.from(sampleBuffer.slice(0, 8))
            .map(b => `0x${b.toString(16).padStart(2, '0')}`)
            .join(' ');
          console.log(`[Compliance View] File detection for ${docId}:`, {
            filePath: objectFile.name,
            firstBytes,
            detectedType: detectedContentType,
            fileSize: fileBuffer.length
          });
        }
      } catch (readError: any) {
        console.error(`[Compliance View] Error reading file for ${docId}:`, {
          error: readError?.message,
          filePath: objectFile.name,
          stack: readError?.stack
        });
        // Continue with metadata fallback
      }

      // Get file metadata (fallback if detection fails)
      const [metadata] = await objectFile.getMetadata();
      let contentType = detectedContentType !== 'application/octet-stream'
        ? detectedContentType
        : (metadata.contentType || "application/octet-stream");

      // If we still have octet-stream and have file buffer, try re-detection with larger sample
      if (contentType === 'application/octet-stream' && fileBuffer) {
        const largerSample = fileBuffer.slice(0, Math.min(8192, fileBuffer.length));
        const reDetected = detectFileMimeType(largerSample);
        if (reDetected !== 'application/octet-stream') {
          contentType = reDetected;
          console.log(`[Compliance View] Re-detected file type for ${docId}: ${reDetected}`);
        }
      }

      console.log(`[Compliance View] Document ${docId} final:`, {
        detectedType: detectedContentType,
        metadataType: metadata.contentType,
        finalType: contentType,
        documentType: doc.documentType,
        documentUrl: doc.documentUrl,
        filePath: documentPath
      });

      // Determine file extension from content type
      let fileExtension = 'pdf'; // default
      if (contentType === 'application/pdf') {
        fileExtension = 'pdf';
      } else if (contentType === 'application/msword') {
        fileExtension = 'doc';
      } else if (contentType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
        fileExtension = 'docx';
      } else if (contentType === 'application/vnd.ms-excel') {
        fileExtension = 'xls';
      } else if (contentType === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') {
        fileExtension = 'xlsx';
      } else if (contentType === 'application/vnd.openxmlformats-officedocument.presentationml.presentation') {
        fileExtension = 'pptx';
      } else if (contentType === 'application/zip') {
        fileExtension = 'zip';
      } else if (contentType.startsWith('image/')) {
        const imageType = contentType.split('/')[1];
        if (imageType === 'jpeg') fileExtension = 'jpg';
        else if (imageType) fileExtension = imageType;
      } else if (contentType === 'application/octet-stream') {
        // Last resort: default to PDF for compliance documents (most common)
        console.warn(`[Compliance View] Could not detect file type for ${docId}, defaulting to PDF`);
        fileExtension = 'pdf';
        // Also update content type to PDF for better browser handling
        contentType = 'application/pdf';
      } else {
        // Try to extract from content type
        const parts = contentType.split('/');
        if (parts.length > 1) {
          const subtype = parts[1].split(';')[0];
          if (subtype && subtype !== 'octet-stream') {
            fileExtension = subtype;
          }
        }
      }

      // Create filename from document type
      const safeDocumentType = doc.documentType.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_');
      const filename = `${safeDocumentType}.${fileExtension}`;

      // Encode filename for Content-Disposition header
      const encodedFilename = encodeURIComponent(filename);

      // Set headers for download with proper filename
      res.set({
        "Content-Type": contentType,
        "Content-Length": metadata.size,
        "Content-Disposition": `attachment; filename="${filename}"; filename*=UTF-8''${encodedFilename}`,
        "Cache-Control": "private, max-age=3600",
      });

      // Stream the file
      const stream = objectFile.createReadStream();
      stream.on("error", (err) => {
        console.error("Stream error:", err);
        if (!res.headersSent) {
          res.status(500).json({ error: "Error streaming file" });
        }
      });
      stream.pipe(res);
    } catch (error) {
      console.error("Error downloading compliance document:", error);
      if (error instanceof ObjectNotFoundError) {
        return res.status(404).json({ message: "Document file not found" });
      }
      res.status(500).json({ message: "Failed to download document" });
    }
  });

  app.get("/api/compliance/expiring", isAuthenticated, requireRole("owner", "compliance"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.json([]);
      }

      const daysAhead = parseInt(req.query.days as string) || 90;
      const docs = await storage.getExpiringCompliance(user.organizationId, daysAhead);
      res.json(docs);
    } catch (error) {
      console.error("Error fetching expiring compliance:", error);
      res.status(500).json({ message: "Failed to fetch expiring compliance" });
    }
  });

  app.patch("/api/compliance/:id", isAuthenticated, requireRole("owner", "compliance"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User must belong to an organization" });
      }

      const docId = req.params.id;
      const existingDoc = await storage.getComplianceDocument(docId);

      if (!existingDoc) {
        return res.status(404).json({ message: "Compliance document not found" });
      }

      if (existingDoc.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const updateSchema = insertComplianceDocumentSchema.partial().omit({
        organizationId: true,
        uploadedBy: true
      });

      const validation = updateSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      const updateData: any = { ...validation.data };
      if (updateData.expiryDate) {
        updateData.expiryDate = new Date(updateData.expiryDate);
      }

      const updatedDoc = await storage.updateComplianceDocument(docId, updateData);
      res.json(updatedDoc);
    } catch (error) {
      console.error("Error updating compliance document:", error);
      res.status(500).json({ message: "Failed to update compliance document" });
    }
  });

  // ==================== MAINTENANCE ROUTES ====================

  // AI analyze maintenance image for fix suggestions
  app.post("/api/maintenance/analyze-image", isAuthenticated, async (req: any, res) => {
    try {
      // Validate request body
      const validation = analyzeMaintenanceImageSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      const { imageUrl, issueDescription } = validation.data;

      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User must belong to an organization" });
      }

      // Check if organization has credits
      const creditBalance = await storage.getCreditBalance(user.organizationId);
      if (creditBalance.total < 1) {
        return res.status(402).json({
          message: "Insufficient credits. Please purchase more credits to use AI analysis.",
          creditBalance: creditBalance.total, // Using creditBalance instead of legacy creditsRemaining
          total: creditBalance.total
        });
      }

      // Use the same logic as tenant portal
      const openaiClient = getOpenAI();
      let imageUrlForAI: string | null = null;
      let suggestedFixes = "";

      // Process image URL - convert localhost/internal URLs to base64
      if (imageUrl) {
        const isLocalhost = imageUrl.includes('localhost') || imageUrl.includes('127.0.0.1');
        const isInternalPath = imageUrl.startsWith('/objects/') || (!imageUrl.startsWith('http') && imageUrl.includes('/objects/'));
        const isLocalhostHttp = imageUrl.startsWith('http://localhost') || imageUrl.startsWith('https://localhost');

        const needsConversion = isLocalhost || isInternalPath || isLocalhostHttp;

        console.log("[Maintenance Analyze Image] URL check:", {
          imageUrl,
          isLocalhost,
          isInternalPath,
          isLocalhostHttp,
          needsConversion
        });

        if (needsConversion) {
          console.log("[Maintenance Analyze Image] Detected localhost/internal URL, converting to base64:", imageUrl);
          try {
            const objectStorageService = new ObjectStorageService();
            let photoPath = imageUrl;
            if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
              try {
                const urlObj = new URL(imageUrl);
                photoPath = urlObj.pathname;
              } catch (e) {
                const pathMatch = imageUrl.match(/\/objects\/[^?#]+/);
                if (pathMatch) {
                  photoPath = pathMatch[0];
                } else {
                  throw new Error(`Could not extract path from URL: ${imageUrl}`);
                }
              }
            }

            if (!photoPath.startsWith('/objects/')) {
              if (!photoPath.startsWith('/')) {
                photoPath = `/objects/${photoPath}`;
              } else {
                photoPath = `/objects${photoPath}`;
              }
            }

            console.log("[Maintenance Analyze Image] Loading file from path:", photoPath);
            const objectFile = await objectStorageService.getObjectEntityFile(photoPath);
            const photoBuffer = await fs.readFile(objectFile.name);

            console.log("[Maintenance Analyze Image] File loaded, size:", photoBuffer.length, "bytes");

            let mimeType = detectImageMimeType(photoBuffer);
            if (!mimeType || !mimeType.startsWith('image/')) {
              console.warn(`[Maintenance Analyze Image] Invalid MIME type detected: ${mimeType}, defaulting to image/jpeg`);
              mimeType = 'image/jpeg';
            }

            const base64Image = photoBuffer.toString('base64');
            imageUrlForAI = `data:${mimeType};base64,${base64Image}`;

            console.log("[Maintenance Analyze Image] Successfully converted to base64 data URL, MIME type:", mimeType, "Size:", base64Image.length, "chars");
          } catch (error: any) {
            console.error("[Maintenance Analyze Image] Error converting image to base64, will proceed with text-only:", {
              imageUrl,
              message: error?.message || String(error),
              errorType: error?.constructor?.name,
            });
            imageUrlForAI = null;
          }
        } else {
          console.log("[Maintenance Analyze Image] Using external URL directly:", imageUrl);
          imageUrlForAI = imageUrl;
        }
      }

      // Make AI call using Responses API (consistent with rest of codebase)
      let aiCallSucceeded = false;

      // Build the input content using legacy format (text/image_url types)
      // then pass through normalizeApiContent which converts to input_text/input_image
      const contentItems: any[] = [];

      // Add text description first
      contentItems.push({
        type: "text",
        text: `You are a helpful maintenance assistant. Analyze this maintenance issue and provide simple, actionable suggestions on how to fix it. Be concise and practical.

Issue description: ${issueDescription || "Please analyze this maintenance issue"}

Provide 3-5 brief, practical suggestions for resolving this issue. Focus on what the person can do themselves first, then mention when to call a professional.`,
      });

      // Add image if available
      if (imageUrlForAI) {
        console.log("[Maintenance Analyze Image] Adding image to AI request");
        contentItems.push({
          type: "image_url",
          image_url: { url: imageUrlForAI },
        });
      }

      console.log("[Maintenance Analyze Image] Making AI call with Responses API");
      try {
        const response = await openaiClient.responses.create({
          model: "gpt-4o",
          input: [{ role: "user", content: normalizeApiContent(contentItems) }],
        });

        console.log("[Maintenance Analyze Image] OpenAI Response received, status:", response.status);

        // Extract content from response using standard pattern
        const outputContent = response.output_text || (response.output?.[0] as any)?.content?.[0]?.text || "";
        console.log("[Maintenance Analyze Image] Output content length:", outputContent?.length || 0);

        if (outputContent && outputContent.trim().length > 0) {
          suggestedFixes = cleanMarkdownText(outputContent.trim());
          aiCallSucceeded = true;
          console.log("[Maintenance Analyze Image] Successfully got AI response, length:", suggestedFixes.length);
        } else {
          console.warn("[Maintenance Analyze Image] OpenAI returned empty response");
        }
      } catch (aiError: any) {
        console.error("[Maintenance Analyze Image] Error with AI call:", aiError?.message);
        throw aiError;
      }

      if (!aiCallSucceeded || !suggestedFixes) {
        throw new Error("Failed to get AI analysis");
      }

      // Consume credit using credit batch system
      const { subscriptionService } = await import("./subscriptionService");
      await subscriptionService.consumeCredits(
        user.organizationId,
        1,
        "ai_analysis",
        `maintenance_${Date.now()}`,
        "AI maintenance image analysis"
      );

      // Get updated credit balance for response
      const updatedBalance = await storage.getCreditBalance(user.organizationId);

      res.json({
        suggestedFixes,
        analysis: {
          model: "gpt-4o",
          timestamp: new Date().toISOString()
        },
        creditBalance: updatedBalance.total, // Using creditBalance instead of legacy creditsRemaining
        total: updatedBalance.total
      });
    } catch (error: any) {
      console.error("[Maintenance Analyze Image] Error:", {
        error: error,
        message: error?.message,
        stack: error?.stack,
        code: error?.code,
        status: error?.status,
      });

      let errorMessage = "Failed to analyze image";
      if (error?.code === 'invalid_image_url' || error?.message?.includes('downloading')) {
        errorMessage = "I'm having trouble accessing the image you uploaded. Please try uploading the image again or describe the issue in text.";
      } else if (error?.message?.includes('base64')) {
        errorMessage = "I'm having trouble processing the image. Please try uploading it again or describe the issue in text.";
      } else if (error?.message?.includes('OpenAI') || error?.message?.includes('empty response')) {
        errorMessage = "I'm having trouble connecting to the AI service. Please try again in a moment.";
      } else if (error?.message) {
        errorMessage = error.message;
      }

      res.status(500).json({ message: errorMessage });
    }
  });

  app.post("/api/maintenance", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;

      // Get user to check organization
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Preprocess dueDate - convert string to Date if needed
      const requestBody = { ...req.body };
      if (requestBody.dueDate && typeof requestBody.dueDate === 'string') {
        requestBody.dueDate = new Date(requestBody.dueDate);
      }

      // Validate request body - allow optional propertyId and blockId
      const validation = insertMaintenanceRequestSchema.omit({ organizationId: true, reportedBy: true }).safeParse(requestBody);
      if (!validation.success) {
        console.error("[Maintenance] Validation failed:", JSON.stringify(validation.error.errors, null, 2));
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      const { propertyId, blockId, title, description, priority, photoUrls, aiSuggestedFixes, aiAnalysisJson, inspectionId, inspectionEntryId, source, dueDate } = validation.data;

      // Must have either propertyId or blockId
      if (!propertyId && !blockId) {
        return res.status(400).json({ message: "Either property or block must be specified" });
      }

      // Verify property exists and belongs to the same organization (if provided)
      if (propertyId) {
        const property = await storage.getProperty(propertyId);
        if (!property) {
          return res.status(404).json({ message: "Property not found" });
        }
        if (property.organizationId !== user.organizationId) {
          return res.status(403).json({ message: "Access denied: Property belongs to a different organization" });
        }
      }

      // Verify block exists and belongs to the same organization (if provided)
      if (blockId) {
        const block = await storage.getBlock(blockId);
        if (!block) {
          return res.status(404).json({ message: "Block not found" });
        }
        if (block.organizationId !== (user?.organizationId || "")) {
          return res.status(403).json({ message: "Access denied: Block belongs to a different organization" });
        }
      }

      const request = await storage.createMaintenanceRequest({
        organizationId: user.organizationId || "",
        propertyId: propertyId || null,
        blockId: blockId || null,
        reportedBy: userId,
        title,
        description: description || null,
        priority: priority || "medium",
        photoUrls: photoUrls || null,
        aiSuggestedFixes: aiSuggestedFixes || null,
        aiAnalysisJson: aiAnalysisJson || null,
        source: source || (user.role === "tenant" ? "tenant_portal" : "manual"),
        inspectionId: inspectionId || null,
        inspectionEntryId: inspectionEntryId || null,
        dueDate: dueDate ? new Date(dueDate) : null,
      });

      res.json(request);
    } catch (error) {
      console.error("Error creating maintenance request:", error);
      res.status(500).json({ message: "Failed to create maintenance request" });
    }
  });

  // Quick-add maintenance request from inspection (with offline support)
  app.post("/api/maintenance/quick", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;

      // Get user to check organization
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Validate request body with quick-add schema
      const validation = quickAddMaintenanceSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      const { propertyId, blockId, title, description, priority, photoUrls, inspectionId, inspectionEntryId, source } = validation.data;

      // Verify property or block exists and belongs to the same organization
      if (propertyId) {
        const property = await storage.getProperty(propertyId);
        if (!property) {
          return res.status(404).json({ message: "Property not found" });
        }
        if (property.organizationId !== user.organizationId) {
          return res.status(403).json({ message: "Access denied: Property belongs to a different organization" });
        }
      }

      if (blockId) {
        const block = await storage.getBlock(blockId);
        if (!block) {
          return res.status(404).json({ message: "Block not found" });
        }
        if (block.organizationId !== user.organizationId) {
          return res.status(403).json({ message: "Access denied: Block belongs to a different organization" });
        }
      }

      // If inspectionId provided, verify it exists and belongs to the same organization
      if (inspectionId) {
        const inspection = await storage.getInspection(inspectionId);
        if (!inspection) {
          return res.status(404).json({ message: "Inspection not found" });
        }

        // Verify organization via property or block
        let ownerOrgId: string | null = null;
        if (inspection.propertyId) {
          const inspectionProperty = await storage.getProperty(inspection.propertyId);
          ownerOrgId = inspectionProperty?.organizationId || null;
        } else if (inspection.blockId) {
          const inspectionBlock = await storage.getBlock(inspection.blockId);
          ownerOrgId = inspectionBlock?.organizationId || null;
        }

        if (ownerOrgId !== user.organizationId) {
          return res.status(403).json({ message: "Access denied: Inspection does not belong to your organization" });
        }
      }

      const request = await storage.createMaintenanceRequest({
        organizationId: user.organizationId || "",
        propertyId: propertyId || null,
        blockId: blockId || null,
        reportedBy: userId,
        title,
        description: description || null,
        priority: priority || "medium",
        photoUrls: photoUrls || null,
        source: source || "inspection",
        inspectionId: inspectionId || null,
        inspectionEntryId: inspectionEntryId || null,
      });

      res.json(request);
    } catch (error) {
      console.error("Error creating quick-add maintenance request:", error);
      res.status(500).json({ message: "Failed to create maintenance request" });
    }
  });

  // IMPORTANT: Route order matters in Express!
  // More specific routes MUST come before less specific ones
  // 1. /api/maintenance/:requestId/tags (most specific - has /tags suffix)
  // 2. /api/maintenance/:id (less specific - just ID)
  // 3. /api/maintenance (least specific - no ID)
  
  // Get single maintenance request by ID - comes AFTER /tags route but BEFORE /maintenance route
  console.log('[Routes] About to register GET /api/maintenance/:id route');
  app.get("/api/maintenance/:id", isAuthenticated, async (req: any, res) => {
    console.log(`[GET /api/maintenance/:id] Route handler called! URL: ${req.originalUrl}, ID param: ${req.params.id}`);
    
    // IMPORTANT: Check if this is actually a /tags route - Express will match /api/maintenance/:id
    // for /api/maintenance/123/tags because :id can be "123/tags"
    // So we need to explicitly check and reject if it contains /tags
    if (req.originalUrl.includes('/tags')) {
      // This should be handled by /api/maintenance/:requestId/tags route
      console.log(`[GET /api/maintenance/:id] Rejecting because URL contains /tags`);
      return res.status(404).json({ message: "Not found" });
    }
    
    try {
      const { id } = req.params;
      console.log(`[GET /api/maintenance/:id] Route matched - Fetching maintenance request: ${id}`);
      
      const user = await storage.getUser(req.user.id);

      if (!user?.organizationId) {
        console.log(`[GET /api/maintenance/:id] No organization ID for user`);
        return res.status(403).json({ message: "Unauthorized" });
      }

      // Fetch all requests for the organization and find the one with matching ID
      const requests = await storage.getMaintenanceByOrganization(user.organizationId);
      const request = requests.find(r => r.id === id);

      if (!request) {
        console.log(`[GET /api/maintenance/:id] Request not found: ${id}`);
        return res.status(404).json({ message: "Maintenance request not found" });
      }

      // Verify organization ownership
      if (request.organizationId !== user.organizationId) {
        console.log(`[GET /api/maintenance/:id] Organization mismatch`);
        return res.status(403).json({ message: "Unauthorized to access this request" });
      }

      console.log(`[GET /api/maintenance/:id] Successfully fetched request: ${id}`);
      res.json(request);
    } catch (error: any) {
      console.error("[GET /api/maintenance/:id] Error fetching maintenance request:", error);
      res.status(500).json({ message: "Failed to fetch maintenance request", error: error.message });
    }
  });

  // Get all maintenance requests - MUST come AFTER /api/maintenance/:id route
  app.get("/api/maintenance", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.json([]);
      }

      const requests = await storage.getMaintenanceByOrganization(user.organizationId);
      res.json(requests);
    } catch (error) {
      console.error("Error fetching maintenance requests:", error);
      res.status(500).json({ message: "Failed to fetch maintenance requests" });
    }
  });

  app.patch("/api/maintenance/:id", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const user = await storage.getUser(req.user.id);

      if (!user?.organizationId) {
        return res.status(403).json({ message: "Unauthorized" });
      }

      // Fetch the maintenance request to verify organization ownership
      const existingRequests = await storage.getMaintenanceByOrganization(user.organizationId);
      const existingRequest = existingRequests.find(r => r.id === id);

      if (!existingRequest) {
        return res.status(404).json({ message: "Maintenance request not found" });
      }

      // Verify organization ownership
      if (existingRequest.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Unauthorized to update this request" });
      }

      // Only owners and clerks can edit maintenance requests
      if (user.role !== "owner" && user.role !== "clerk") {
        return res.status(403).json({ message: "Insufficient permissions" });
      }

      // Normalize status values before validation
      // Map "assigned" and "in-progress" to "in_progress" to match the schema
      const normalizedBody = { ...req.body };
      if (normalizedBody.status) {
        if (normalizedBody.status === "assigned" || normalizedBody.status === "in-progress") {
          normalizedBody.status = "in_progress";
        }
      }

      // Preprocess dueDate - convert string to Date if needed
      if (normalizedBody.dueDate && typeof normalizedBody.dueDate === 'string') {
        normalizedBody.dueDate = new Date(normalizedBody.dueDate);
      }

      // Validate request body
      const validation = updateMaintenanceRequestSchema.safeParse(normalizedBody);
      if (!validation.success) {
        console.error("Validation errors:", validation.error.errors);
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      // Prevent organizationId from being changed
      const { organizationId: _, ...safeUpdates } = validation.data as any;

      // Use the new updateMaintenanceRequest method for full updates
      const request = await storage.updateMaintenanceRequest(id, safeUpdates);
      res.json(request);
    } catch (error) {
      console.error("Error updating maintenance request:", error);
      res.status(500).json({ message: "Failed to update maintenance request" });
    }
  });

  // ==================== CREDIT ROUTES ====================

  app.get("/api/credits/transactions", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.json([]);
      }

      const transactions = await storage.getCreditTransactions(user.organizationId);
      res.json(transactions);
    } catch (error) {
      console.error("Error fetching credit transactions:", error);
      res.status(500).json({ message: "Failed to fetch credit transactions" });
    }
  });

  // Get auto-renew settings
  app.get("/api/credits/auto-renew", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const org = await storage.getOrganization(user.organizationId);
      if (!org) {
        return res.status(404).json({ message: "Organization not found" });
      }

      res.json({
        enabled: org.autoRenewEnabled ?? false,
        bundleId: org.autoRenewBundleId,
        threshold: org.autoRenewThreshold ?? 10,
        lastRunAt: org.autoRenewLastRunAt,
        failureCount: org.autoRenewFailureCount ?? 0,
      });
    } catch (error) {
      console.error("Error fetching auto-renew settings:", error);
      res.status(500).json({ message: "Failed to fetch auto-renew settings" });
    }
  });

  // Update auto-renew settings
  app.put("/api/credits/auto-renew", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only owners can configure auto-renew
      if (user.role !== "owner") {
        return res.status(403).json({ message: "Only organization owners can configure auto-renew" });
      }

      const { enabled, bundleId, threshold } = req.body;

      // Validate bundle exists if enabling
      if (enabled && bundleId) {
        const bundles = await storage.getCreditBundles();
        const bundle = bundles.find(b => b.id === bundleId && b.isActive);
        if (!bundle) {
          return res.status(400).json({ message: "Invalid or inactive credit bundle" });
        }
      }

      // Update organization auto-renew settings
      await db.update(organizations)
        .set({
          autoRenewEnabled: enabled,
          autoRenewBundleId: bundleId || null,
          autoRenewThreshold: threshold ?? 10,
          autoRenewFailureCount: enabled ? 0 : undefined, // Reset failure count when re-enabling
          updatedAt: new Date(),
        })
        .where(eq(organizations.id, user.organizationId));

      res.json({ success: true });
    } catch (error) {
      console.error("Error updating auto-renew settings:", error);
      res.status(500).json({ message: "Failed to update auto-renew settings" });
    }
  });

  // Get available credit bundles for auto-renew
  app.get("/api/credits/bundles", isAuthenticated, async (req: any, res) => {
    try {
      const bundles = await storage.getCreditBundles();
      res.json(bundles.filter(b => b.isActive));
    } catch (error) {
      console.error("Error fetching credit bundles:", error);
      res.status(500).json({ message: "Failed to fetch credit bundles" });
    }
  });

  // ==================== STRIPE ROUTES ====================

  app.post("/api/stripe/create-checkout", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const organization = await storage.getOrganization(user.organizationId);
      if (!organization) {
        return res.status(404).json({ message: "Organization not found" });
      }

      const { credits } = req.body;
      const amount = credits * 100; // $1 per credit, in cents

      const stripe = await getUncachableStripeClient();
      const session = await stripe.checkout.sessions.create({
        payment_method_types: ["card"],
        line_items: [
          {
            price_data: {
              currency: "usd",
              product_data: {
                name: `${credits} Inspection Credits`,
                description: "Credits for AI-powered property inspections",
              },
              unit_amount: 100, // $1 per credit
            },
            quantity: credits,
          },
        ],
        mode: "payment",
        success_url: `${req.headers.origin}/dashboard?payment=success`,
        cancel_url: `${req.headers.origin}/dashboard?payment=cancelled`,
        client_reference_id: organization.id,
        metadata: {
          organizationId: organization.id,
          credits: credits.toString(),
        },
      });

      res.json({ url: session.url });
    } catch (error) {
      console.error("Error creating checkout session:", error);
      res.status(500).json({ message: "Failed to create checkout session" });
    }
  });

  // NOTE: Duplicate webhook handler removed - all webhook handling consolidated into /api/billing/webhook

  // ==================== BLOCK ROUTES ====================

  app.post("/api/blocks", isAuthenticated, requireRole("owner", "compliance"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Validate request body with Zod
      const parseResult = insertBlockSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({
          error: "Invalid request data",
          details: parseResult.error.errors
        });
      }

      const block = await storage.createBlock({
        ...parseResult.data,
        organizationId: user.organizationId,
      });
      res.status(201).json(block);
    } catch (error: any) {
      console.error("Error creating block:", error);
      res.status(500).json({ error: "Failed to create block" });
    }
  });

  app.get("/api/blocks", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const blocks = await storage.getBlocksWithStats(user.organizationId);
      res.json(blocks);
    } catch (error) {
      console.error("Error fetching blocks:", error);
      res.status(500).json({ error: "Failed to fetch blocks" });
    }
  });

  app.get("/api/blocks/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const block = await storage.getBlock(req.params.id);
      if (!block) {
        return res.status(404).json({ error: "Block not found" });
      }

      // Verify organization ownership
      if (block.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      res.json(block);
    } catch (error) {
      console.error("Error fetching block:", error);
      res.status(500).json({ error: "Failed to fetch block" });
    }
  });

  app.get("/api/blocks/:id/properties", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const blockId = req.params.id;

      // Verify block belongs to user's organization
      const block = await storage.getBlock(blockId);
      if (!block || block.organizationId !== user.organizationId) {
        return res.status(404).json({ error: "Block not found" });
      }

      const properties = await storage.getPropertiesWithStatsByBlock(blockId);
      res.json(properties);
    } catch (error) {
      console.error("Error fetching block properties:", error);
      res.status(500).json({ error: "Failed to fetch block properties" });
    }
  });

  // Get block compliance documents
  app.get("/api/blocks/:id/compliance", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const block = await storage.getBlock(id);
      if (!block || block.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Block not found" });
      }

      const allComplianceDocs = await storage.getComplianceDocuments(user.organizationId);
      const complianceDocs = allComplianceDocs.filter((d: any) => d.blockId === id);

      // Add status based on expiry and enhance with names
      const now = new Date();
      const enhancedDocs = complianceDocs.map((doc: any) => {
        let status = 'valid';
        if (doc.expiryDate) {
          const expiryDate = new Date(doc.expiryDate);
          const daysUntilExpiry = Math.ceil((expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));

          if (daysUntilExpiry < 0) {
            status = 'expired';
          } else if (daysUntilExpiry <= 30) {
            status = 'expiring';
          } else {
            status = 'valid';
          }
        }

        return {
          id: doc.id,
          documentName: doc.documentType,
          documentType: doc.documentType,
          documentUrl: doc.documentUrl,
          expiryDate: doc.expiryDate,
          status,
          uploadedAt: doc.createdAt,
        };
      });

      res.json(enhancedDocs);
    } catch (error) {
      console.error("Error fetching block compliance:", error);
      res.status(500).json({ message: "Failed to fetch compliance documents" });
    }
  });

  // Get block annual compliance report
  app.get("/api/blocks/:id/compliance-report", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const block = await storage.getBlock(id);
      if (!block || block.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Block not found" });
      }

      // Get year from query parameter, default to current year
      const yearParam = req.query.year;
      const year = yearParam ? parseInt(yearParam as string, 10) : new Date().getFullYear();

      // Get all inspections for this block
      const allInspections = await storage.getInspectionsByBlock(id);

      // Get all inspection templates
      const templates = await storage.getInspectionTemplatesByOrganization(user.organizationId);
      const activeTemplates = templates.filter(t => t.isActive && (t.scope === 'block' || t.scope === 'both'));

      // Build compliance data by template and month
      const currentYear = year;
      const months = [
        'January', 'February', 'March', 'April', 'May', 'June',
        'July', 'August', 'September', 'October', 'November', 'December'
      ];

      const complianceData = activeTemplates.map(template => {
        const templateInspections = allInspections.filter(i => i.templateId === template.id);

        const monthData = months.map((monthName, monthIndex) => {
          // Find inspections scheduled for this month
          const monthInspections = templateInspections.filter(inspection => {
            if (!inspection.scheduledDate) return false;
            const schedDate = new Date(inspection.scheduledDate);
            return schedDate.getFullYear() === currentYear && schedDate.getMonth() === monthIndex;
          });

          if (monthInspections.length === 0) {
            return { month: monthName, status: 'not_scheduled', count: 0 };
          }

          const now = new Date();
          const completedCount = monthInspections.filter(i => i.status === 'completed').length;
          const overdueCount = monthInspections.filter(i => {
            if (i.status === 'completed' || !i.scheduledDate) return false;
            const schedDate = new Date(i.scheduledDate);
            return schedDate < now;
          }).length;

          const dueCount = monthInspections.filter(i => {
            if (i.status === 'completed' || !i.scheduledDate) return false;
            const schedDate = new Date(i.scheduledDate);
            const daysUntil = Math.ceil((schedDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
            return daysUntil >= 0 && daysUntil <= 30;
          }).length;

          let status = 'not_scheduled';
          if (overdueCount > 0) {
            status = 'overdue';
          } else if (completedCount === monthInspections.length) {
            status = 'completed';
          } else if (dueCount > 0) {
            status = 'due';
          } else {
            status = 'scheduled';
          }

          return {
            month: monthName,
            status,
            count: monthInspections.length,
            completed: completedCount,
            overdue: overdueCount,
          };
        });

        // Calculate compliance percentage for this template
        const totalScheduled = monthData.reduce((sum, m) => sum + m.count, 0);
        const totalCompleted = monthData.reduce((sum, m) => sum + (m.completed || 0), 0);
        const complianceRate = totalScheduled > 0 ? Math.round((totalCompleted / totalScheduled) * 100) : 0;

        return {
          templateId: template.id,
          templateName: template.name,
          monthData,
          complianceRate,
          totalScheduled,
          totalCompleted,
        };
      });

      // Calculate overall compliance
      const totalScheduled = complianceData.reduce((sum, t) => sum + t.totalScheduled, 0);
      const totalCompleted = complianceData.reduce((sum, t) => sum + t.totalCompleted, 0);
      const overallCompliance = totalScheduled > 0 ? Math.round((totalCompleted / totalScheduled) * 100) : 100;

      res.json({
        year: currentYear,
        months,
        templates: complianceData,
        overallCompliance,
        totalScheduled,
        totalCompleted,
      });
    } catch (error) {
      console.error("Error fetching block compliance report:", error);
      res.status(500).json({ message: "Failed to fetch compliance report" });
    }
  });

  app.patch("/api/blocks/:id", isAuthenticated, requireRole("owner", "compliance"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify organization ownership
      const existing = await storage.getBlock(req.params.id);
      if (!existing) {
        return res.status(404).json({ error: "Block not found" });
      }
      if (existing.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      // Validate request body (partial update) with Zod
      const parseResult = insertBlockSchema.partial().safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({
          error: "Invalid request data",
          details: parseResult.error.errors
        });
      }

      const block = await storage.updateBlock(req.params.id, parseResult.data);
      res.json(block);
    } catch (error: any) {
      console.error("Error updating block:", error);
      res.status(500).json({ error: "Failed to update block" });
    }
  });

  app.delete("/api/blocks/:id", isAuthenticated, requireRole("owner", "compliance"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify organization ownership
      const existing = await storage.getBlock(req.params.id);
      if (!existing) {
        return res.status(404).json({ error: "Block not found" });
      }
      if (existing.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      await storage.deleteBlock(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting block:", error);
      res.status(500).json({ error: "Failed to delete block" });
    }
  });

  // Get tenant information for a block
  app.get("/api/blocks/:blockId/tenants", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const { blockId } = req.params;

      // Verify block belongs to user's organization
      const block = await storage.getBlock(blockId);
      if (!block) {
        return res.status(404).json({ error: "Block not found" });
      }
      if (block.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      // Get stats and tenant assignments
      const stats = await storage.getBlockTenantStats(blockId);
      const tenants = await storage.getTenantAssignmentsByBlock(blockId);

      res.json({
        stats,
        tenants,
      });
    } catch (error) {
      console.error("Error fetching block tenants:", error);
      res.status(500).json({ error: "Failed to fetch block tenants" });
    }
  });

  // Broadcast message to all block tenants
  app.post("/api/blocks/:blockId/broadcast", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const { blockId } = req.params;
      const { templateId, subject, body } = req.body;

      // Verify block belongs to user's organization
      const block = await storage.getBlock(blockId);
      if (!block) {
        return res.status(404).json({ error: "Block not found" });
      }
      if (block.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      // Get organization for name
      const organization = await storage.getOrganization(user.organizationId);

      // Prepare message template
      let templateData: { subject: string; body: string };

      if (templateId) {
        // Use existing template
        const template = await storage.getMessageTemplate(templateId);
        if (!template || template.organizationId !== user.organizationId) {
          return res.status(404).json({ error: "Template not found" });
        }
        templateData = { subject: template.subject, body: template.body };
      } else if (subject && body) {
        // Use custom message
        templateData = { subject, body };
      } else {
        return res.status(400).json({ error: "Either templateId or subject and body must be provided" });
      }

      // Get all tenant emails for this block
      const recipients = await storage.getBlockTenantsEmails(blockId, user.organizationId);

      if (recipients.length === 0) {
        return res.status(404).json({ error: "No active tenants found for this block" });
      }

      // Send broadcast
      const { broadcastMessageToTenants } = await import('./resend');
      const senderName = user.firstName
        ? `${user.firstName}${user.lastName ? ' ' + user.lastName : ''}`
        : user.email;
      const result = await broadcastMessageToTenants(
        recipients.map(r => ({
          email: r.email,
          firstName: r.firstName,
          lastName: r.lastName,
          propertyName: r.propertyName,
        })),
        templateData,
        {
          blockName: block.name,
          blockAddress: block.address || '',
          organizationName: organization?.name || 'Your Property Management',
          senderName: senderName,
        }
      );

      res.json(result);
    } catch (error) {
      console.error("Error broadcasting message:", error);
      res.status(500).json({ error: "Failed to broadcast message" });
    }
  });

  // ==================== MESSAGE TEMPLATE ROUTES ====================

  app.get("/api/message-templates", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const templates = await storage.getMessageTemplatesByOrganization(user.organizationId);
      res.json(templates);
    } catch (error) {
      console.error("Error fetching message templates:", error);
      res.status(500).json({ error: "Failed to fetch message templates" });
    }
  });

  app.post("/api/message-templates", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const validatedData = insertMessageTemplateSchema.safeParse(req.body);
      if (!validatedData.success) {
        return res.status(400).json({ error: "Invalid request data", details: validatedData.error.errors });
      }

      const template = await storage.createMessageTemplate({
        ...validatedData.data,
        organizationId: user.organizationId,
        createdBy: userId,
      });

      res.status(201).json(template);
    } catch (error) {
      console.error("Error creating message template:", error);
      res.status(500).json({ error: "Failed to create message template" });
    }
  });

  app.put("/api/message-templates/:id", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const existing = await storage.getMessageTemplate(req.params.id);
      if (!existing || existing.organizationId !== user.organizationId) {
        return res.status(404).json({ error: "Template not found" });
      }

      const validatedData = updateMessageTemplateSchema.safeParse(req.body);
      if (!validatedData.success) {
        return res.status(400).json({ error: "Invalid request data", details: validatedData.error.errors });
      }

      const updated = await storage.updateMessageTemplate(req.params.id, validatedData.data);
      res.json(updated);
    } catch (error) {
      console.error("Error updating message template:", error);
      res.status(500).json({ error: "Failed to update message template" });
    }
  });

  app.delete("/api/message-templates/:id", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const existing = await storage.getMessageTemplate(req.params.id);
      if (!existing || existing.organizationId !== user.organizationId) {
        return res.status(404).json({ error: "Template not found" });
      }

      await storage.deleteMessageTemplate(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting message template:", error);
      res.status(500).json({ error: "Failed to delete message template" });
    }
  });

  // ==================== TENANT ASSIGNMENT ROUTES ====================

  // Get all active tenants for the organization (for filter dropdowns)
  app.get("/api/tenants/active", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Get all active tenant assignments with tenant user info
      const assignments = await storage.getTenantAssignmentsByOrganization(user.organizationId);
      const activeAssignments = assignments.filter(a => a.isActive);

      // Get unique active tenants with their info
      const tenantIds = Array.from(new Set(activeAssignments.map(a => a.tenantId)));
      const tenants = await Promise.all(
        tenantIds.map(async (tenantId) => {
          const tenantUser = await storage.getUser(tenantId);
          if (!tenantUser) return null;
          return {
            id: tenantUser.id,
            firstName: tenantUser.firstName || '',
            lastName: tenantUser.lastName || '',
            email: tenantUser.email,
            name: `${tenantUser.firstName || ''} ${tenantUser.lastName || ''}`.trim() || tenantUser.email,
          };
        })
      );

      res.json(tenants.filter(t => t !== null));
    } catch (error) {
      console.error("Error fetching active tenants:", error);
      res.status(500).json({ error: "Failed to fetch active tenants" });
    }
  });

  // Get all tenant assignments for organization
  app.get("/api/tenant-assignments", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const assignments = await storage.getTenantAssignmentsByOrganization(user.organizationId);
      res.json(assignments);
    } catch (error) {
      console.error("Error fetching tenant assignments:", error);
      res.status(500).json({ error: "Failed to fetch tenant assignments" });
    }
  });

  app.post("/api/tenant-assignments", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Transform request body to match schema expectations
      // Dates come as ISO strings but Zod expects Date objects
      // Numeric fields come as numbers but Drizzle expects strings
      const transformedBody: any = {
        ...req.body,
      };

      // Convert date strings to Date objects
      if (req.body.leaseStartDate && typeof req.body.leaseStartDate === 'string') {
        transformedBody.leaseStartDate = new Date(req.body.leaseStartDate);
      }
      if (req.body.leaseEndDate && typeof req.body.leaseEndDate === 'string') {
        transformedBody.leaseEndDate = new Date(req.body.leaseEndDate);
      }

      // Convert numeric fields to strings (Drizzle numeric fields expect strings)
      if (req.body.monthlyRent !== undefined && req.body.monthlyRent !== null) {
        transformedBody.monthlyRent = String(req.body.monthlyRent);
      }
      if (req.body.depositAmount !== undefined && req.body.depositAmount !== null) {
        transformedBody.depositAmount = String(req.body.depositAmount);
      }

      const validatedData = insertTenantAssignmentSchema.safeParse(transformedBody);
      if (!validatedData.success) {
        console.error("[Tenant Assignment] Validation errors:", validatedData.error.errors);
        console.error("[Tenant Assignment] Request body:", req.body);
        console.error("[Tenant Assignment] Transformed body:", transformedBody);
        return res.status(400).json({
          error: "Invalid request data",
          message: validatedData.error.errors[0]?.message || "Validation failed",
          details: validatedData.error.errors
        });
      }

      // Verify property belongs to user's organization
      const property = await storage.getProperty(validatedData.data.propertyId);
      if (!property || property.organizationId !== user.organizationId) {
        return res.status(404).json({ error: "Property not found" });
      }

      // Verify tenant user exists and has tenant role
      const tenantUser = await storage.getUser(validatedData.data.tenantId);
      if (!tenantUser || tenantUser.role !== 'tenant' || tenantUser.organizationId !== user.organizationId) {
        return res.status(404).json({ error: "Tenant user not found" });
      }

      // Store original password if provided (for later retrieval when sending password)
      // This ensures we can send the EXACT password entered during tenant creation
      let assignmentData = { ...validatedData.data };
      if (req.body.originalPassword && typeof req.body.originalPassword === 'string') {
        // Store original password in notes field as JSON
        // If notes already exists and is not JSON, preserve it as a text note
        // Format: { "_originalPassword": "password123", "_userNotes": "existing notes text" }
        try {
          let notesObj: any = {};
          if (assignmentData.notes) {
            try {
              // Try to parse as JSON first
              notesObj = JSON.parse(assignmentData.notes);
            } catch {
              // If not JSON, preserve as user notes
              notesObj._userNotes = assignmentData.notes;
            }
          }
          // Store the exact password entered during tenant creation
          notesObj._originalPassword = req.body.originalPassword;
          assignmentData.notes = JSON.stringify(notesObj);
          console.log(`[Create Tenant Assignment] Stored original password for tenant assignment`);
        } catch (error) {
          // Fallback: create new JSON object
          console.error(`[Create Tenant Assignment] Error storing original password:`, error);
          assignmentData.notes = JSON.stringify({ _originalPassword: req.body.originalPassword });
        }
      } else {
        console.warn(`[Create Tenant Assignment] No original password provided - password will not be retrievable for sending`);
      }

      const assignment = await storage.createTenantAssignment({
        ...assignmentData,
        organizationId: user.organizationId,
      });

      // Auto-create contact for this tenant if one doesn't exist
      try {
        const existingContacts = await storage.getContactsByOrganization(user.organizationId);
        const hasContact = existingContacts.some(c => c.linkedUserId === tenantUser.id);

        if (!hasContact) {
          await storage.createContact({
            organizationId: user.organizationId,
            type: 'tenant',
            firstName: tenantUser.firstName || '',
            lastName: tenantUser.lastName || '',
            email: tenantUser.email,
            phone: tenantUser.phone || undefined,
            profileImageUrl: tenantUser.profileImageUrl || undefined,
            linkedUserId: tenantUser.id,
            notes: 'Created automatically with tenant assignment',
          });
          console.log(`âœ“ Auto-created contact for tenant ${tenantUser.id}`);
        }
      } catch (contactError) {
        // Log but don't fail the assignment creation
        console.error(`Warning: Failed to auto-create contact for tenant:`, contactError);
      }

      res.status(201).json(assignment);
    } catch (error) {
      console.error("Error creating tenant assignment:", error);
      res.status(500).json({ error: "Failed to create tenant assignment" });
    }
  });

  app.put("/api/tenant-assignments/:id", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify assignment belongs to user's organization
      const existing = await storage.getTenantAssignment(req.params.id);
      if (!existing || existing.organizationId !== user.organizationId) {
        return res.status(404).json({ error: "Tenant assignment not found" });
      }

      // Transform request body before validation (same as POST endpoint)
      const transformedBody = { ...req.body };

      // Convert date strings or Date objects to Date objects for Zod validation
      if (req.body.leaseStartDate !== undefined && req.body.leaseStartDate !== null) {
        if (typeof req.body.leaseStartDate === 'string') {
          transformedBody.leaseStartDate = new Date(req.body.leaseStartDate);
        } else if (req.body.leaseStartDate instanceof Date) {
          transformedBody.leaseStartDate = req.body.leaseStartDate;
        }
      }
      if (req.body.leaseEndDate !== undefined && req.body.leaseEndDate !== null) {
        if (typeof req.body.leaseEndDate === 'string') {
          transformedBody.leaseEndDate = new Date(req.body.leaseEndDate);
        } else if (req.body.leaseEndDate instanceof Date) {
          transformedBody.leaseEndDate = req.body.leaseEndDate;
        }
      }

      // Convert numeric fields to strings (Drizzle numeric fields expect strings)
      if (req.body.monthlyRent !== undefined && req.body.monthlyRent !== null) {
        transformedBody.monthlyRent = String(req.body.monthlyRent);
      }
      if (req.body.depositAmount !== undefined && req.body.depositAmount !== null) {
        transformedBody.depositAmount = String(req.body.depositAmount);
      }

      const validatedData = updateTenantAssignmentSchema.safeParse(transformedBody);
      if (!validatedData.success) {
        console.error("[Tenant Assignment Update] Validation errors:", validatedData.error.errors);
        console.error("[Tenant Assignment Update] Request body:", req.body);
        console.error("[Tenant Assignment Update] Transformed body:", transformedBody);
        return res.status(400).json({
          error: "Invalid request data",
          message: validatedData.error.errors[0]?.message || "Validation failed",
          details: validatedData.error.errors
        });
      }

      // Preserve original password from existing assignment when updating notes
      let updateData = { ...validatedData.data };
      if (updateData.notes !== undefined && existing.notes) {
        try {
          const existingNotesData = JSON.parse(existing.notes);
          if (existingNotesData._originalPassword) {
            // Preserve the original password
            try {
              const newNotesData = typeof updateData.notes === 'string' ? JSON.parse(updateData.notes) : updateData.notes;
              if (typeof newNotesData === 'object' && newNotesData !== null) {
                newNotesData._originalPassword = existingNotesData._originalPassword;
                updateData.notes = JSON.stringify(newNotesData);
              } else {
                // If new notes is not JSON, preserve it as user notes
                const notesObj: any = { _userNotes: updateData.notes };
                notesObj._originalPassword = existingNotesData._originalPassword;
                updateData.notes = JSON.stringify(notesObj);
              }
            } catch {
              // If new notes is not JSON, preserve it as user notes
              const notesObj: any = { _userNotes: updateData.notes };
              notesObj._originalPassword = existingNotesData._originalPassword;
              updateData.notes = JSON.stringify(notesObj);
            }
          }
        } catch {
          // Existing notes is not JSON, preserve original password if it exists
          // (This shouldn't happen, but handle gracefully)
        }
      }

      const updated = await storage.updateTenantAssignment(req.params.id, updateData);
      res.json(updated);
    } catch (error) {
      console.error("Error updating tenant assignment:", error);
      res.status(500).json({ error: "Failed to update tenant assignment" });
    }
  });

  app.delete("/api/tenant-assignments/:id", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify assignment belongs to user's organization
      const existing = await storage.getTenantAssignment(req.params.id);
      if (!existing || existing.organizationId !== user.organizationId) {
        return res.status(404).json({ error: "Tenant assignment not found" });
      }

      await storage.deleteTenantAssignment(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting tenant assignment:", error);
      res.status(500).json({ error: "Failed to delete tenant assignment" });
    }
  });

  // Get tags for a tenant assignment
  app.get("/api/tenant-assignments/:id/tags", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify assignment belongs to user's organization
      const assignment = await storage.getTenantAssignment(req.params.id);
      if (!assignment || assignment.organizationId !== user.organizationId) {
        return res.status(404).json({ error: "Tenant assignment not found" });
      }

      const tags = await storage.getTenantAssignmentTags(req.params.id, user.organizationId);
      res.json(tags);
    } catch (error) {
      console.error("Error fetching tenant assignment tags:", error);
      res.status(500).json({ error: "Failed to fetch tags" });
    }
  });

  // Update tags for a tenant assignment
  app.put("/api/tenant-assignments/:id/tags", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify assignment belongs to user's organization
      const assignment = await storage.getTenantAssignment(req.params.id);
      if (!assignment || assignment.organizationId !== user.organizationId) {
        return res.status(404).json({ error: "Tenant assignment not found" });
      }

      const { tagIds } = req.body;
      if (!Array.isArray(tagIds)) {
        return res.status(400).json({ error: "tagIds must be an array" });
      }

      await storage.updateTenantAssignmentTags(req.params.id, tagIds, user.organizationId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error updating tenant assignment tags:", error);
      res.status(500).json({ error: "Failed to update tags" });
    }
  });

  // Send portal credentials to tenant
  app.post("/api/tenant-assignments/:id/send-password", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify assignment belongs to user's organization
      const assignment = await storage.getTenantAssignment(req.params.id);
      if (!assignment || assignment.organizationId !== user.organizationId) {
        return res.status(404).json({ error: "Tenant assignment not found" });
      }

      // Get tenant user details
      const tenant = await storage.getUser(assignment.tenantId);
      if (!tenant) {
        return res.status(404).json({ error: "Tenant user not found" });
      }

      // Validate tenant has an email address
      if (!tenant.email || !tenant.email.trim()) {
        return res.status(400).json({ error: "Tenant user does not have an email address configured" });
      }

      // Use provided password, retrieve from stored original password, or generate a new one
      let passwordToSend: string;
      if (req.body.password && typeof req.body.password === 'string' && req.body.password.trim() !== '') {
        // Use the provided password (e.g., when creating a new tenant)
        passwordToSend = req.body.password;
        const { hashPassword } = await import('./auth');
        const hashedPassword = await hashPassword(passwordToSend);

        // Update tenant password with the provided password
        await storage.upsertUser({
          ...tenant,
          password: hashedPassword,
        });
      } else {
        // Try to retrieve original password from assignment notes
        let originalPassword: string | null = null;
        if (assignment.notes) {
          try {
            const notesData = JSON.parse(assignment.notes);
            if (notesData._originalPassword && typeof notesData._originalPassword === 'string') {
              originalPassword = notesData._originalPassword;
            }
          } catch {
            // Notes is not JSON, ignore
          }
        }

        if (originalPassword) {
          // Use the stored original password (the exact password entered during tenant creation)
          passwordToSend = originalPassword;
          const { hashPassword } = await import('./auth');
          const hashedPassword = await hashPassword(passwordToSend);

          // Update tenant password with the original password (in case it was changed)
          await storage.upsertUser({
            ...tenant,
            password: hashedPassword,
          });
          console.log(`[Send Password] Using stored original password for tenant ${tenant.email}`);
        } else {
          // No stored original password found - generate a new secure password
          console.log(`[Send Password] No stored original password found for tenant ${tenant.email}, generating new password`);

          // Generate a secure random password
          const { randomBytes } = await import('crypto');
          passwordToSend = randomBytes(8).toString('base64').replace(/[^a-zA-Z0-9]/g, '').slice(0, 12) + 'A1!';

          const { hashPassword } = await import('./auth');
          const hashedPassword = await hashPassword(passwordToSend);

          // Update tenant password with the new password
          await storage.upsertUser({
            ...tenant,
            password: hashedPassword,
          });

          // Store the new password for future use
          try {
            let notesObj: any = {};
            if (assignment.notes) {
              try {
                notesObj = JSON.parse(assignment.notes);
              } catch {
                notesObj._userNotes = assignment.notes;
              }
            }
            notesObj._originalPassword = passwordToSend;
            await storage.updateTenantAssignment(assignment.id, { notes: JSON.stringify(notesObj) });
            console.log(`[Send Password] Stored newly generated password for tenant ${tenant.email}`);
          } catch (storeError) {
            console.error(`[Send Password] Failed to store generated password:`, storeError);
          }
        }
      }

      // Send email with credentials using the proper helper function
      const fullName = [tenant.firstName, tenant.lastName].filter(Boolean).join(" ") || tenant.email;

      // Validate email and password before sending
      if (!tenant.email || !tenant.email.trim()) {
        return res.status(400).json({
          error: "Cannot send email: Tenant does not have a valid email address",
          emailSent: false
        });
      }

      if (!passwordToSend || !passwordToSend.trim()) {
        return res.status(400).json({
          error: "Cannot send email: No password available to send",
          emailSent: false
        });
      }

      console.log(`[Send Password] Sending credentials email to ${tenant.email} with password length: ${passwordToSend.length}`);

      let emailSent = false;
      try {
        const { sendTenantCredentialsEmail } = await import('./resend');
        await sendTenantCredentialsEmail(
          tenant.email.trim(),
          fullName,
          passwordToSend
        );
        emailSent = true;
        console.log(`[Send Password] Successfully sent credentials email to ${tenant.email}`);
      } catch (emailError) {
        console.error('Failed to send tenant credentials email:', emailError);
        // Return error but don't fail the entire request - password was already updated
        return res.status(500).json({
          error: "Failed to send email. Password was updated but email could not be sent.",
          emailSent: false,
          details: emailError instanceof Error ? emailError.message : 'Unknown error'
        });
      }

      res.json({
        success: true,
        message: "Credentials sent successfully",
        emailSent: true
      });
    } catch (error) {
      console.error("Error sending tenant password:", error);
      res.status(500).json({
        error: "Failed to send credentials",
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Get attachments for a tenant assignment
  app.get("/api/tenant-assignments/:id/attachments", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify assignment belongs to user's organization
      const assignment = await storage.getTenantAssignment(req.params.id);
      if (!assignment || assignment.organizationId !== user.organizationId) {
        return res.status(404).json({ error: "Tenant assignment not found" });
      }

      const attachments = await storage.getTenancyAttachments(req.params.id, user.organizationId);
      res.json(attachments);
    } catch (error) {
      console.error("Error fetching tenancy attachments:", error);
      res.status(500).json({ error: "Failed to fetch attachments" });
    }
  });

  // Upload tenancy attachment
  app.post("/api/tenancy-attachments", isAuthenticated, requireRole("owner", "clerk"), upload.single('file'), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const { tenantAssignmentId } = req.body;
      if (!tenantAssignmentId) {
        return res.status(400).json({ error: "tenantAssignmentId is required" });
      }

      // Verify assignment belongs to user's organization
      const assignment = await storage.getTenantAssignment(tenantAssignmentId);
      if (!assignment || assignment.organizationId !== user.organizationId) {
        return res.status(404).json({ error: "Tenant assignment not found" });
      }

      if (!req.file) {
        return res.status(400).json({ error: "No file uploaded" });
      }

      // Upload to local storage using ObjectStorageService
      const objectStorageService = new ObjectStorageService();
      const objectId = randomUUID();
      const normalizedPath = await objectStorageService.saveUploadedFile(
        objectId,
        req.file.buffer,
        req.file.mimetype
      );

      // Convert relative path to absolute URL
      const baseUrl = getBaseUrl(req);
      const fileUrl = `${baseUrl}${normalizedPath}`;

      // Set ACL to public so it can be accessed
      try {
        await objectStorageService.trySetObjectEntityAclPolicy(normalizedPath, {
          owner: userId,
          visibility: "public",
        });
      } catch (error) {
        console.warn("Failed to set ACL for tenancy attachment:", error);
      }

      // Create attachment record
      const attachment = await storage.createTenancyAttachment({
        tenantAssignmentId,
        fileName: req.file.originalname,
        fileUrl: normalizedPath, // Store relative path, convert to absolute when serving
        fileType: req.file.mimetype,
        fileSize: req.file.size,
        uploadedBy: userId,
        organizationId: user.organizationId,
      });

      res.status(201).json({
        ...attachment,
        fileUrl: fileUrl, // Return absolute URL in response
      });
    } catch (error) {
      console.error("Error uploading tenancy attachment:", error);
      res.status(500).json({ error: "Failed to upload attachment" });
    }
  });

  // Delete tenancy attachment
  app.delete("/api/tenancy-attachments/:id", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify attachment belongs to user's organization, get fileUrl, and delete database record
      let result: { fileUrl: string } | null = null;
      try {
        result = await storage.deleteTenancyAttachment(req.params.id, user.organizationId);
      } catch (storageError: any) {
        console.error("Error deleting tenancy attachment from database:", storageError);
        if (storageError.message === "Attachment not found or access denied") {
          return res.status(404).json({ error: storageError.message });
        }
        throw storageError;
      }

      // Delete the file from object storage (don't fail if file deletion fails)
      if (result?.fileUrl) {
        try {
          const objectStorageService = new ObjectStorageService();
          await objectStorageService.deleteObjectEntity(result.fileUrl);
        } catch (fileError) {
          // Log but don't fail - database record is already deleted
          console.warn("Failed to delete file from storage (database record already deleted):", fileError);
        }
      }

      res.status(204).send();
    } catch (error: any) {
      console.error("Error deleting tenancy attachment:", error);
      res.status(500).json({
        error: "Failed to delete attachment",
        message: error?.message || "An error occurred while deleting the attachment"
      });
    }
  });

  // ==================== ASSET INVENTORY ROUTES ====================

  app.post("/api/asset-inventory", isAuthenticated, requireRole("owner", "clerk", "compliance"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const validatedData = insertAssetInventorySchema.parse(req.body);

      const asset = await storage.createAssetInventory({
        ...validatedData,
        organizationId: user.organizationId,
      });
      res.status(201).json(asset);
    } catch (error: any) {
      safeErrorLog("Error creating asset inventory:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid request data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to create asset inventory" });
    }
  });

  // Quick-add asset from inspection (with offline support)
  app.post("/api/asset-inventory/quick", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Validate request body with quick-add schema
      const validation = quickAddAssetSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          error: "Invalid request data",
          details: validation.error.errors
        });
      }

      const { name, category, condition, cleanliness, location, description, propertyId, blockId, photos, inspectionId, inspectionEntryId } = validation.data;

      // Verify property or block exists and belongs to the same organization
      if (propertyId) {
        const property = await storage.getProperty(propertyId);
        if (!property) {
          return res.status(404).json({ error: "Property not found" });
        }
        if (property.organizationId !== user.organizationId) {
          return res.status(403).json({ error: "Access denied: Property belongs to a different organization" });
        }
      }

      if (blockId) {
        const block = await storage.getBlock(blockId);
        if (!block) {
          return res.status(404).json({ error: "Block not found" });
        }
        if (block.organizationId !== user.organizationId) {
          return res.status(403).json({ error: "Access denied: Block belongs to a different organization" });
        }
      }

      // If inspectionId provided, verify it exists and belongs to the same organization
      if (inspectionId) {
        const inspection = await storage.getInspection(inspectionId);
        if (!inspection) {
          return res.status(404).json({ error: "Inspection not found" });
        }

        // Verify organization via property or block
        let ownerOrgId: string | null = null;
        if (inspection.propertyId) {
          const inspectionProperty = await storage.getProperty(inspection.propertyId);
          ownerOrgId = inspectionProperty?.organizationId || null;
        } else if (inspection.blockId) {
          const inspectionBlock = await storage.getBlock(inspection.blockId);
          ownerOrgId = inspectionBlock?.organizationId || null;
        }

        if (ownerOrgId !== user.organizationId) {
          return res.status(403).json({ error: "Access denied: Inspection does not belong to your organization" });
        }
      }

      const asset = await storage.createAssetInventory({
        organizationId: user.organizationId,
        name,
        category: category || null,
        condition,
        cleanliness: cleanliness || null,
        location: location || null,
        description: description || null,
        propertyId: propertyId || null,
        blockId: blockId || null,
        photos: photos || null,
        inspectionId: inspectionId || null,
        inspectionEntryId: inspectionEntryId || null,
      });

      res.status(201).json(asset);
    } catch (error: any) {
      console.error("Error creating quick-add asset:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid request data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to create asset" });
    }
  });

  // Quick-update asset from inspection (with offline support)
  app.patch("/api/asset-inventory/:id/quick", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const { id } = req.params;

      // Verify asset exists and belongs to user's organization
      const existingAsset = await storage.getAssetInventory(id);
      if (!existingAsset) {
        return res.status(404).json({ error: "Asset not found" });
      }
      if (existingAsset.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied: Asset belongs to a different organization" });
      }

      // Validate request body with quick-update schema
      const validation = quickUpdateAssetSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          error: "Invalid request data",
          details: validation.error.errors
        });
      }

      const { condition, cleanliness, location, notes, photos, inspectionId, inspectionEntryId, offlineId } = validation.data;

      // Check for duplicate offline requests (deduplication)
      if (offlineId) {
        // In a production system, you'd store processed offlineIds in a cache/db
        // For now, we'll just log and continue (idempotent operation)
        console.log(`Processing offline update with ID: ${offlineId}`);
      }

      // If inspectionId provided, verify it exists and belongs to the same organization
      if (inspectionId) {
        const inspection = await storage.getInspection(inspectionId);
        if (!inspection) {
          return res.status(404).json({ error: "Inspection not found" });
        }

        // Verify organization via property or block
        let ownerOrgId: string | null = null;
        if (inspection.propertyId) {
          const inspectionProperty = await storage.getProperty(inspection.propertyId);
          ownerOrgId = inspectionProperty?.organizationId || null;
        } else if (inspection.blockId) {
          const inspectionBlock = await storage.getBlock(inspection.blockId);
          ownerOrgId = inspectionBlock?.organizationId || null;
        }

        if (ownerOrgId !== user.organizationId) {
          return res.status(403).json({ error: "Access denied: Inspection does not belong to your organization" });
        }
      }

      // Build update object with only provided fields
      // Map notes to description for consistency with asset table schema
      const updateData: any = {};
      if (condition !== undefined) updateData.condition = condition;
      if (cleanliness !== undefined) updateData.cleanliness = cleanliness;
      if (location !== undefined) updateData.location = location;
      if (notes !== undefined) updateData.description = notes; // Map notes -> description
      if (photos !== undefined) updateData.photos = photos;
      if (inspectionId !== undefined) updateData.inspectionId = inspectionId;
      if (inspectionEntryId !== undefined) updateData.inspectionEntryId = inspectionEntryId;

      const updatedAsset = await storage.updateAssetInventory(id, updateData);

      res.json(updatedAsset);
    } catch (error: any) {
      console.error("Error updating quick-update asset:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid request data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to update asset" });
    }
  });

  app.get("/api/asset-inventory", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const { propertyId, blockId } = req.query;

      // If propertyId is provided, filter by property
      if (propertyId) {
        const property = await storage.getProperty(propertyId);
        if (!property) {
          return res.status(404).json({ error: "Property not found" });
        }
        if (property.organizationId !== user.organizationId) {
          return res.status(403).json({ error: "Access denied" });
        }
        const assets = await storage.getAssetInventoryByProperty(propertyId);
        return res.json(assets);
      }

      // If blockId is provided, filter by block
      if (blockId) {
        const block = await storage.getBlock(blockId);
        if (!block) {
          return res.status(404).json({ error: "Block not found" });
        }
        if (block.organizationId !== user.organizationId) {
          return res.status(403).json({ error: "Access denied" });
        }
        const assets = await storage.getAssetInventoryByBlock(blockId);
        return res.json(assets);
      }

      // Otherwise return all assets for the organization
      const assets = await storage.getAssetInventoryByOrganization(user.organizationId);
      res.json(assets);
    } catch (error) {
      console.error("Error fetching asset inventory:", error);
      res.status(500).json({ error: "Failed to fetch asset inventory" });
    }
  });

  app.get("/api/asset-inventory/property/:propertyId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify property belongs to user's organization
      const property = await storage.getProperty(req.params.propertyId);
      if (!property) {
        return res.status(404).json({ error: "Property not found" });
      }
      if (property.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      const assets = await storage.getAssetInventoryByProperty(req.params.propertyId);
      res.json(assets);
    } catch (error) {
      console.error("Error fetching property asset inventory:", error);
      res.status(500).json({ error: "Failed to fetch property asset inventory" });
    }
  });

  app.get("/api/asset-inventory/block/:blockId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify block belongs to user's organization
      const block = await storage.getBlock(req.params.blockId);
      if (!block) {
        return res.status(404).json({ error: "Block not found" });
      }
      if (block.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      const assets = await storage.getAssetInventoryByBlock(req.params.blockId);
      res.json(assets);
    } catch (error) {
      console.error("Error fetching block asset inventory:", error);
      res.status(500).json({ error: "Failed to fetch block asset inventory" });
    }
  });

  app.get("/api/asset-inventory/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const asset = await storage.getAssetInventory(req.params.id);
      if (!asset) {
        return res.status(404).json({ error: "Asset not found" });
      }

      // Verify organization ownership
      if (asset.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      res.json(asset);
    } catch (error) {
      console.error("Error fetching asset inventory:", error);
      res.status(500).json({ error: "Failed to fetch asset inventory" });
    }
  });

  app.patch("/api/asset-inventory/:id", isAuthenticated, requireRole("owner", "clerk", "compliance"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify organization ownership
      const existing = await storage.getAssetInventory(req.params.id);
      if (!existing) {
        return res.status(404).json({ error: "Asset not found" });
      }
      if (existing.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      // Remove organizationId from request body (should not be updated)
      const { organizationId: _, ...updateData } = req.body;

      // Validate and coerce dates
      const validatedData = insertAssetInventorySchema.partial().parse(updateData);

      const asset = await storage.updateAssetInventory(req.params.id, validatedData);
      res.json(asset);
    } catch (error: any) {
      safeErrorLog("Error updating asset inventory:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid request data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to update asset inventory" });
    }
  });

  app.delete("/api/asset-inventory/:id", isAuthenticated, requireRole("owner", "clerk", "compliance"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify organization ownership
      const existing = await storage.getAssetInventory(req.params.id);
      if (!existing) {
        return res.status(404).json({ error: "Asset not found" });
      }
      if (existing.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      await storage.deleteAssetInventory(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting asset inventory:", error);
      res.status(500).json({ error: "Failed to delete asset inventory" });
    }
  });

  // ==================== INVENTORY TEMPLATE ROUTES ====================

  app.post("/api/inventory-templates", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const validatedData = insertInventoryTemplateSchema.parse(req.body);

      const template = await storage.createInventoryTemplate({
        ...validatedData,
        organizationId: user.organizationId,
      });
      res.status(201).json(template);
    } catch (error: any) {
      console.error("Error creating inventory template:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid request data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to create inventory template" });
    }
  });

  app.get("/api/inventory-templates", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const templates = await storage.getInventoryTemplatesByOrganization(user.organizationId);
      res.json(templates);
    } catch (error) {
      console.error("Error fetching inventory templates:", error);
      res.status(500).json({ error: "Failed to fetch inventory templates" });
    }
  });

  app.get("/api/inventory-templates/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const template = await storage.getInventoryTemplate(req.params.id);
      if (!template) {
        return res.status(404).json({ error: "Template not found" });
      }

      if (template.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      res.json(template);
    } catch (error) {
      console.error("Error fetching inventory template:", error);
      res.status(500).json({ error: "Failed to fetch inventory template" });
    }
  });

  app.patch("/api/inventory-templates/:id", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const existing = await storage.getInventoryTemplate(req.params.id);
      if (!existing) {
        return res.status(404).json({ error: "Template not found" });
      }
      if (existing.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      const validatedData = insertInventoryTemplateSchema.partial().parse(req.body);

      const template = await storage.updateInventoryTemplate(req.params.id, validatedData);
      res.json(template);
    } catch (error: any) {
      console.error("Error updating inventory template:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid request data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to update inventory template" });
    }
  });

  app.delete("/api/inventory-templates/:id", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const existing = await storage.getInventoryTemplate(req.params.id);
      if (!existing) {
        return res.status(404).json({ error: "Template not found" });
      }
      if (existing.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      await storage.deleteInventoryTemplate(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting inventory template:", error);
      res.status(500).json({ error: "Failed to delete inventory template" });
    }
  });

  // ==================== INVENTORY ROUTES ====================

  app.post("/api/inventories", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const validatedData = insertInventorySchema.parse(req.body);

      const inventory = await storage.createInventory({
        ...validatedData,
        organizationId: user.organizationId,
      });
      res.status(201).json(inventory);
    } catch (error: any) {
      console.error("Error creating inventory:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid request data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to create inventory" });
    }
  });

  app.get("/api/properties/:propertyId/inventories", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify property belongs to user's organization
      const property = await storage.getProperty(req.params.propertyId);
      if (!property) {
        return res.status(404).json({ error: "Property not found" });
      }
      if (property.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      const inventories = await storage.getInventoriesByProperty(req.params.propertyId);
      res.json(inventories);
    } catch (error) {
      console.error("Error fetching inventories:", error);
      res.status(500).json({ error: "Failed to fetch inventories" });
    }
  });

  app.get("/api/inventories/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const inventory = await storage.getInventory(req.params.id);
      if (!inventory) {
        return res.status(404).json({ error: "Inventory not found" });
      }

      if (inventory.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      res.json(inventory);
    } catch (error) {
      console.error("Error fetching inventory:", error);
      res.status(500).json({ error: "Failed to fetch inventory" });
    }
  });

  // ==================== INVENTORY ITEM ROUTES ====================

  app.post("/api/inventory-items", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const validatedData = insertInventoryItemSchema.parse(req.body);

      // Verify parent inventory belongs to user's organization
      const inventory = await storage.getInventory(validatedData.inventoryId);
      if (!inventory || inventory.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      const item = await storage.createInventoryItem(validatedData);
      res.status(201).json(item);
    } catch (error: any) {
      console.error("Error creating inventory item:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid request data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to create inventory item" });
    }
  });

  app.get("/api/inventories/:inventoryId/items", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify inventory belongs to user's organization
      const inventory = await storage.getInventory(req.params.inventoryId);
      if (!inventory || inventory.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      const items = await storage.getInventoryItems(req.params.inventoryId);
      res.json(items);
    } catch (error) {
      console.error("Error fetching inventory items:", error);
      res.status(500).json({ error: "Failed to fetch inventory items" });
    }
  });

  app.patch("/api/inventory-items/:id", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Note: This requires fetching the item first to verify access via parent inventory
      // For efficiency, we could add a getInventoryItem method to storage
      const validatedData = insertInventoryItemSchema.partial().parse(req.body);

      const item = await storage.updateInventoryItem(req.params.id, validatedData);
      res.json(item);
    } catch (error: any) {
      console.error("Error updating inventory item:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid request data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to update inventory item" });
    }
  });

  // ==================== WORK ORDER ROUTES ====================

  app.post("/api/work-orders", isAuthenticated, requireRole("owner", "contractor"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const validatedData = insertWorkOrderSchema.parse(req.body);

      // Security: Validate teamId belongs to organization if provided
      if (validatedData.teamId) {
        const team = await storage.getTeam(validatedData.teamId);
        if (!team || team.organizationId !== user.organizationId) {
          return res.status(403).json({ error: "Team not found or access denied" });
        }
      }

      // Security: Validate contractorId belongs to organization if provided
      // Contractors are stored in the contacts table, not users table
      if (validatedData.contractorId) {
        const contractor = await storage.getContact(validatedData.contractorId);
        if (!contractor || contractor.organizationId !== user.organizationId) {
          return res.status(403).json({ error: "Contractor not found or access denied" });
        }
      }

      // organizationId is handled separately as it's omitted from the schema
      // organizationId is omitted from schema, so we need to add it manually
      const workOrderData = {
        ...validatedData,
        organizationId: user.organizationId,
      } as any;
      const workOrder = await storage.createWorkOrder(workOrderData);

      // Send email notification to team if teamId is provided (best-effort, non-blocking)
      if (validatedData.teamId) {
        try {
          const team = await storage.getTeam(validatedData.teamId);
          const maintenanceRequest = await db
            .select()
            .from(maintenanceRequests)
            .where(eq(maintenanceRequests.id, validatedData.maintenanceRequestId))
            .limit(1)
            .then(rows => rows[0]);

          if (team?.email && maintenanceRequest) {
            // Fetch property details if available
            let propertyName: string | undefined;
            if (maintenanceRequest.propertyId) {
              const property = await storage.getProperty(maintenanceRequest.propertyId);
              propertyName = property?.name;
            }

            await sendTeamWorkOrderNotification(
              team.email,
              team.name,
              {
                id: workOrder.id,
                maintenanceTitle: maintenanceRequest.title,
                maintenanceDescription: maintenanceRequest.description || undefined,
                priority: maintenanceRequest.priority,
                propertyName,
                slaDue: validatedData.slaDue ? new Date(validatedData.slaDue) : null,
                costEstimate: validatedData.costEstimate || null,
              }
            );
            console.log(`Team notification email sent successfully for work order ${workOrder.id} to team ${team.name} (${team.email})`);
          }
        } catch (emailError) {
          // Log email failures but don't block work order creation
          console.error(`Failed to send team notification email for work order ${workOrder.id}:`, emailError);
          console.error(`Email error details:`, {
            workOrderId: workOrder.id,
            teamId: validatedData.teamId,
            error: emailError instanceof Error ? emailError.message : 'Unknown error',
          });
        }
      }

      // Send email notification to contractor if contractorId is provided (best-effort, non-blocking)
      // Contractors are stored in the contacts table, not users table
      if (validatedData.contractorId) {
        try {
          const contractor = await storage.getContact(validatedData.contractorId);
          const maintenanceRequest = await db
            .select()
            .from(maintenanceRequests)
            .where(eq(maintenanceRequests.id, validatedData.maintenanceRequestId))
            .limit(1)
            .then(rows => rows[0]);

          if (contractor?.email && maintenanceRequest) {
            // Fetch property details if available
            let propertyName: string | undefined;
            if (maintenanceRequest.propertyId) {
              const property = await storage.getProperty(maintenanceRequest.propertyId);
              propertyName = property?.name;
            }

            const contractorName = contractor.firstName
              ? `${contractor.firstName}${contractor.lastName ? ' ' + contractor.lastName : ''}`
              : contractor.companyName || 'Contractor';

            await sendContractorWorkOrderNotification(
              contractor.email,
              contractorName,
              {
                id: workOrder.id,
                maintenanceTitle: maintenanceRequest.title,
                maintenanceDescription: maintenanceRequest.description || undefined,
                priority: maintenanceRequest.priority,
                propertyName,
                slaDue: validatedData.slaDue ? new Date(validatedData.slaDue) : null,
                costEstimate: validatedData.costEstimate || null,
              }
            );
            console.log(`Contractor notification email sent successfully for work order ${workOrder.id} to ${contractorName} (${contractor.email})`);
          }
        } catch (emailError) {
          // Log email failures but don't block work order creation
          console.error(`Failed to send contractor notification email for work order ${workOrder.id}:`, emailError);
          console.error(`Email error details:`, {
            workOrderId: workOrder.id,
            contractorId: validatedData.contractorId,
            error: emailError instanceof Error ? emailError.message : 'Unknown error',
          });
        }
      }

      res.status(201).json(workOrder);
    } catch (error: any) {
      console.error("Error creating work order:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid request data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to create work order" });
    }
  });

  app.get("/api/work-orders", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // If user is a contractor, show only their work orders
      const workOrders = user.role === "contractor"
        ? await storage.getWorkOrdersByContractor(userId)
        : await storage.getWorkOrdersByOrganization(user.organizationId);

      res.json(workOrders);
    } catch (error) {
      console.error("Error fetching work orders:", error);
      res.status(500).json({ error: "Failed to fetch work orders" });
    }
  });

  app.get("/api/work-orders/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const workOrder = await storage.getWorkOrder(req.params.id);
      if (!workOrder) {
        return res.status(404).json({ error: "Work order not found" });
      }

      // Verify access: owner/org members can see all, contractors can only see their assigned orders
      if (user.role === "contractor") {
        if (workOrder.contractorId !== userId) {
          return res.status(403).json({ error: "Access denied" });
        }
      } else if (workOrder.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      res.json(workOrder);
    } catch (error) {
      console.error("Error fetching work order:", error);
      res.status(500).json({ error: "Failed to fetch work order" });
    }
  });

  app.patch("/api/work-orders/:id/status", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const workOrder = await storage.getWorkOrder(req.params.id);
      if (!workOrder) {
        return res.status(404).json({ error: "Work order not found" });
      }

      // Verify access
      if (user.role === "contractor") {
        if (workOrder.contractorId !== userId) {
          return res.status(403).json({ error: "Access denied" });
        }
      } else if (workOrder.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      const { status } = req.body;
      const completedAt = status === "completed" ? new Date() : undefined;
      const updated = await storage.updateWorkOrderStatus(req.params.id, status, completedAt);
      res.json(updated);
    } catch (error) {
      console.error("Error updating work order status:", error);
      res.status(500).json({ error: "Failed to update work order status" });
    }
  });

  app.patch("/api/work-orders/:id/cost", isAuthenticated, requireRole("owner", "contractor"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const workOrder = await storage.getWorkOrder(req.params.id);
      if (!workOrder) {
        return res.status(404).json({ error: "Work order not found" });
      }

      // Verify access
      if (user.role === "contractor") {
        if (workOrder.contractorId !== userId) {
          return res.status(403).json({ error: "Access denied" });
        }
      } else if (workOrder.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      const { costActual, variationNotes } = req.body;
      const updated = await storage.updateWorkOrderCost(req.params.id, costActual, variationNotes);
      res.json(updated);
    } catch (error) {
      console.error("Error updating work order cost:", error);
      res.status(500).json({ error: "Failed to update work order cost" });
    }
  });

  // ==================== WORK LOG ROUTES ====================

  app.post("/api/work-logs", isAuthenticated, requireRole("owner", "contractor"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const validatedData = insertWorkLogSchema.parse(req.body);

      // Verify parent work order belongs to user's organization or contractor
      const workOrder = await storage.getWorkOrder(validatedData.workOrderId);
      if (!workOrder) {
        return res.status(404).json({ error: "Work order not found" });
      }

      // Verify access
      if (user.role === "contractor") {
        if (workOrder.contractorId !== userId) {
          return res.status(403).json({ error: "Access denied" });
        }
      } else if (workOrder.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      const log = await storage.createWorkLog(validatedData);
      res.status(201).json(log);
    } catch (error: any) {
      console.error("Error creating work log:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid request data", details: error.errors });
      }
      res.status(500).json({ error: "Failed to create work log" });
    }
  });

  app.get("/api/work-orders/:workOrderId/logs", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Verify work order belongs to user's organization or contractor
      const workOrder = await storage.getWorkOrder(req.params.workOrderId);
      if (!workOrder) {
        return res.status(404).json({ error: "Work order not found" });
      }

      // Verify access
      if (user.role === "contractor") {
        if (workOrder.contractorId !== userId) {
          return res.status(403).json({ error: "Access denied" });
        }
      } else if (workOrder.organizationId !== user.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      const logs = await storage.getWorkLogs(req.params.workOrderId);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching work logs:", error);
      res.status(500).json({ error: "Failed to fetch work logs" });
    }
  });

  // Get work order analytics
  app.get("/api/analytics/work-orders", isAuthenticated, requireRole("owner"), async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Get all work orders for the organization
      const workOrders = await storage.getWorkOrdersByOrganization(user.organizationId);

      // Batch fetch all teams to avoid N+1 queries
      const allTeams = await storage.getTeamsByOrganization(user.organizationId);
      const teamsById = new Map(allTeams.map(t => [t.id, t]));

      // Batch fetch all maintenance requests to avoid N+1 queries
      const maintenanceRequestIds = workOrders.map(wo => wo.maintenanceRequestId);
      const maintenanceRequestsData = await db
        .select()
        .from(maintenanceRequests)
        .where(eq(maintenanceRequests.organizationId, user.organizationId));
      const maintenanceRequestsById = new Map(maintenanceRequestsData.map(mr => [mr.id, mr]));

      // Map work order statuses to UI groupings
      // assigned/waiting_parts â†’ "open", in_progress â†’ "in_progress", completed â†’ "completed", rejected â†’ "rejected"
      const statusDistribution: { [key: string]: number } = {
        open: 0,
        in_progress: 0,
        completed: 0,
        rejected: 0,
      };

      for (const wo of workOrders) {
        if (wo.status === "assigned" || wo.status === "waiting_parts") {
          statusDistribution.open++;
        } else if (wo.status === "in_progress") {
          statusDistribution.in_progress++;
        } else if (wo.status === "completed") {
          statusDistribution.completed++;
        } else if (wo.status === "rejected") {
          statusDistribution.rejected++;
        }
      }

      // Calculate priority distribution from linked maintenance requests
      const priorityDistribution: { [key: string]: number } = {};
      for (const wo of workOrders) {
        const mr = maintenanceRequestsById.get(wo.maintenanceRequestId);
        if (mr?.priority) {
          priorityDistribution[mr.priority] = (priorityDistribution[mr.priority] || 0) + 1;
        }
      }

      // Calculate average resolution time for completed work orders
      const completedWorkOrders = workOrders.filter(wo => wo.status === "completed" && wo.completedAt && wo.createdAt);
      const averageResolutionTimeMinutes = completedWorkOrders.length > 0
        ? completedWorkOrders.reduce((sum, wo) => {
          const resolutionTime = wo.completedAt!.getTime() - wo.createdAt!.getTime();
          return sum + (resolutionTime / (1000 * 60)); // Convert to minutes
        }, 0) / completedWorkOrders.length
        : 0;

      // Calculate team distribution
      const teamDistribution: { [key: string]: { name: string; count: number } } = {};
      for (const wo of workOrders) {
        if (wo.teamId) {
          if (!teamDistribution[wo.teamId]) {
            const team = teamsById.get(wo.teamId);
            teamDistribution[wo.teamId] = {
              name: team?.name || 'Unknown Team',
              count: 0
            };
          }
          teamDistribution[wo.teamId].count++;
        }
      }

      // Calculate category distribution from linked maintenance requests
      const categoryDistribution: { [key: string]: number } = {};
      for (const wo of workOrders) {
        const mr = maintenanceRequestsById.get(wo.maintenanceRequestId) as any;
        if (mr?.category) {
          categoryDistribution[mr.category] = (categoryDistribution[mr.category] || 0) + 1;
        }
      }

      res.json({
        total: workOrders.length,
        statusDistribution,
        priorityDistribution,
        teamDistribution,
        categoryDistribution,
        averageResolutionTimeMinutes: Math.round(averageResolutionTimeMinutes),
      });
    } catch (error) {
      console.error("Error fetching work order analytics:", error);
      res.status(500).json({ error: "Failed to fetch analytics" });
    }
  });

  // ==================== TAG ROUTES ====================

  // Create a new tag
  app.post("/api/tags", isAuthenticated, requireRole("owner", "clerk", "compliance"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user || !user.organizationId) {
        return res.status(403).json({ error: "User not associated with an organization" });
      }

      const validatedData = insertTagSchema.parse({
        ...req.body,
        organizationId: user.organizationId,
      });

      const tag = await storage.createTag(validatedData);
      res.json(tag);
    } catch (error: any) {
      console.error("Error creating tag:", error);
      res.status(400).json({ error: error.message || "Failed to create tag" });
    }
  });

  // Get all tags for the organization
  app.get("/api/tags", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user || !user.organizationId) {
        return res.status(403).json({ error: "User not associated with an organization" });
      }

      const tags = await storage.getTagsByOrganization(user.organizationId);
      res.json(tags);
    } catch (error) {
      console.error("Error fetching tags:", error);
      res.status(500).json({ error: "Failed to fetch tags" });
    }
  });

  // Update a tag
  app.patch("/api/tags/:id", isAuthenticated, requireRole("owner", "clerk", "compliance"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      const tag = await storage.getTag(req.params.id);

      if (!tag) {
        return res.status(404).json({ error: "Tag not found" });
      }

      if (tag.organizationId !== user?.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      const updated = await storage.updateTag(req.params.id, req.body);
      res.json(updated);
    } catch (error) {
      console.error("Error updating tag:", error);
      res.status(500).json({ error: "Failed to update tag" });
    }
  });

  // Delete a tag
  app.delete("/api/tags/:id", isAuthenticated, requireRole("owner", "clerk", "compliance"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      const tag = await storage.getTag(req.params.id);

      if (!tag) {
        return res.status(404).json({ error: "Tag not found" });
      }

      if (tag.organizationId !== user?.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      await storage.deleteTag(req.params.id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting tag:", error);
      res.status(500).json({ error: "Failed to delete tag" });
    }
  });

  // Add tag to block
  app.post("/api/blocks/:blockId/tags/:tagId", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      const block = await storage.getBlock(req.params.blockId);
      const tag = await storage.getTag(req.params.tagId);

      if (!block || !tag) {
        return res.status(404).json({ error: "Block or tag not found" });
      }

      if (block.organizationId !== user?.organizationId || tag.organizationId !== user?.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      await storage.addTagToBlock(req.params.blockId, req.params.tagId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error adding tag to block:", error);
      res.status(500).json({ error: "Failed to add tag to block" });
    }
  });

  // Remove tag from block
  app.delete("/api/blocks/:blockId/tags/:tagId", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      await storage.removeTagFromBlock(req.params.blockId, req.params.tagId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error removing tag from block:", error);
      res.status(500).json({ error: "Failed to remove tag from block" });
    }
  });

  // Get tags for block
  app.get("/api/blocks/:blockId/tags", isAuthenticated, async (req: any, res) => {
    try {
      const tags = await storage.getTagsForBlock(req.params.blockId);
      res.json(tags);
    } catch (error) {
      console.error("Error fetching block tags:", error);
      res.status(500).json({ error: "Failed to fetch block tags" });
    }
  });

  // Add tag to property
  app.post("/api/properties/:propertyId/tags/:tagId", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      const property = await storage.getProperty(req.params.propertyId);
      const tag = await storage.getTag(req.params.tagId);

      if (!property || !tag) {
        return res.status(404).json({ error: "Property or tag not found" });
      }

      if (property.organizationId !== user?.organizationId || tag.organizationId !== user?.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      await storage.addTagToProperty(req.params.propertyId, req.params.tagId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error adding tag to property:", error);
      res.status(500).json({ error: "Failed to add tag to property" });
    }
  });

  // Remove tag from property
  app.delete("/api/properties/:propertyId/tags/:tagId", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      await storage.removeTagFromProperty(req.params.propertyId, req.params.tagId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error removing tag from property:", error);
      res.status(500).json({ error: "Failed to remove tag from property" });
    }
  });

  // Get tags for property
  app.get("/api/properties/:propertyId/tags", isAuthenticated, async (req: any, res) => {
    try {
      const tags = await storage.getTagsForProperty(req.params.propertyId);
      res.json(tags);
    } catch (error) {
      console.error("Error fetching property tags:", error);
      res.status(500).json({ error: "Failed to fetch property tags" });
    }
  });

  // Add tag to user
  app.post("/api/users/:userId/tags/:tagId", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      const targetUser = await storage.getUser(req.params.userId);
      const tag = await storage.getTag(req.params.tagId);

      if (!targetUser || !tag) {
        return res.status(404).json({ error: "User or tag not found" });
      }

      if (targetUser.organizationId !== user?.organizationId || tag.organizationId !== user?.organizationId) {
        return res.status(403).json({ error: "Access denied" });
      }

      await storage.addTagToUser(req.params.userId, req.params.tagId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error adding tag to user:", error);
      res.status(500).json({ error: "Failed to add tag to user" });
    }
  });

  // Remove tag from user
  app.delete("/api/users/:userId/tags/:tagId", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      await storage.removeTagFromUser(req.params.userId, req.params.tagId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error removing tag from user:", error);
      res.status(500).json({ error: "Failed to remove tag from user" });
    }
  });

  // Get tags for user
  app.get("/api/users/:userId/tags", isAuthenticated, async (req: any, res) => {
    try {
      const tags = await storage.getTagsForUser(req.params.userId);
      res.json(tags);
    } catch (error) {
      console.error("Error fetching user tags:", error);
      res.status(500).json({ error: "Failed to fetch user tags" });
    }
  });

  // Add tag to compliance document
  app.post("/api/compliance/:complianceId/tags/:tagId", isAuthenticated, requireRole("owner", "compliance"), async (req: any, res) => {
    try {
      await storage.addTagToComplianceDocument(req.params.complianceId, req.params.tagId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error adding tag to compliance document:", error);
      res.status(500).json({ error: "Failed to add tag to compliance document" });
    }
  });

  // Remove tag from compliance document
  app.delete("/api/compliance/:complianceId/tags/:tagId", isAuthenticated, requireRole("owner", "compliance"), async (req: any, res) => {
    try {
      await storage.removeTagFromComplianceDocument(req.params.complianceId, req.params.tagId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error removing tag from compliance document:", error);
      res.status(500).json({ error: "Failed to remove tag from compliance document" });
    }
  });

  // Get tags for compliance document
  app.get("/api/compliance/:complianceId/tags", isAuthenticated, async (req: any, res) => {
    try {
      const tags = await storage.getTagsForComplianceDocument(req.params.complianceId);
      res.json(tags);
    } catch (error) {
      console.error("Error fetching compliance document tags:", error);
      res.status(500).json({ error: "Failed to fetch compliance document tags" });
    }
  });

  // ==================== COMPLIANCE DOCUMENT TYPES ====================

  // Get all document types for organization
  app.get("/api/compliance/document-types", isAuthenticated, requireRole("owner", "compliance"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const types = await storage.getComplianceDocumentTypes(user.organizationId);
      res.json(types);
    } catch (error) {
      console.error("Error fetching compliance document types:", error);
      res.status(500).json({ message: "Failed to fetch compliance document types" });
    }
  });

  // Create new document type
  app.post("/api/compliance/document-types", isAuthenticated, requireRole("owner", "compliance"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { insertComplianceDocumentTypeSchema } = await import("@shared/schema");
      const validation = insertComplianceDocumentTypeSchema.safeParse({
        ...req.body,
        organizationId: user.organizationId,
      });

      if (!validation.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      const type = await storage.createComplianceDocumentType(validation.data);
      res.json(type);
    } catch (error) {
      console.error("Error creating compliance document type:", error);
      res.status(500).json({ message: "Failed to create compliance document type" });
    }
  });

  // Update document type
  app.patch("/api/compliance/document-types/:id", isAuthenticated, requireRole("owner", "compliance"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { id } = req.params;
      const existingTypes = await storage.getComplianceDocumentTypes(user.organizationId);
      const type = existingTypes.find(t => t.id === id);

      if (!type || type.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Document type not found" });
      }

      const { insertComplianceDocumentTypeSchema } = await import("@shared/schema");
      const updateSchema = insertComplianceDocumentTypeSchema.partial().omit({
        organizationId: true,
      });

      const validation = updateSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }

      const updated = await storage.updateComplianceDocumentType(id, validation.data);
      res.json(updated);
    } catch (error) {
      console.error("Error updating compliance document type:", error);
      res.status(500).json({ message: "Failed to update compliance document type" });
    }
  });

  // Delete document type
  app.delete("/api/compliance/document-types/:id", isAuthenticated, requireRole("owner", "compliance"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { id } = req.params;
      const existingTypes = await storage.getComplianceDocumentTypes(user.organizationId);
      const type = existingTypes.find(t => t.id === id);

      if (!type || type.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Document type not found" });
      }

      await storage.deleteComplianceDocumentType(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting compliance document type:", error);
      res.status(500).json({ message: "Failed to delete compliance document type" });
    }
  });

  // Add tag to asset inventory
  app.post("/api/asset-inventory/:assetId/tags/:tagId", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      await storage.addTagToAssetInventory(req.params.assetId, req.params.tagId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error adding tag to asset inventory:", error);
      res.status(500).json({ error: "Failed to add tag to asset inventory" });
    }
  });

  // Remove tag from asset inventory
  app.delete("/api/asset-inventory/:assetId/tags/:tagId", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      await storage.removeTagFromAssetInventory(req.params.assetId, req.params.tagId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error removing tag from asset inventory:", error);
      res.status(500).json({ error: "Failed to remove tag from asset inventory" });
    }
  });

  // Get tags for asset inventory
  app.get("/api/asset-inventory/:assetId/tags", isAuthenticated, async (req: any, res) => {
    try {
      const tags = await storage.getTagsForAssetInventory(req.params.assetId);
      res.json(tags);
    } catch (error) {
      console.error("Error fetching asset inventory tags:", error);
      res.status(500).json({ error: "Failed to fetch asset inventory tags" });
    }
  });

  // Add tag to maintenance request
  app.post("/api/maintenance/:requestId/tags/:tagId", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      await storage.addTagToMaintenanceRequest(req.params.requestId, req.params.tagId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error adding tag to maintenance request:", error);
      res.status(500).json({ error: "Failed to add tag to maintenance request" });
    }
  });

  // Remove tag from maintenance request
  app.delete("/api/maintenance/:requestId/tags/:tagId", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      await storage.removeTagFromMaintenanceRequest(req.params.requestId, req.params.tagId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error removing tag from maintenance request:", error);
      res.status(500).json({ error: "Failed to remove tag from maintenance request" });
    }
  });

  // Get tags for maintenance request
  app.get("/api/maintenance/:requestId/tags", isAuthenticated, async (req: any, res) => {
    try {
      const tags = await storage.getTagsForMaintenanceRequest(req.params.requestId);
      res.json(tags);
    } catch (error) {
      console.error("Error fetching maintenance request tags:", error);
      res.status(500).json({ error: "Failed to fetch maintenance request tags" });
    }
  });

  // Add tag to contact
  app.post("/api/contacts/:contactId/tags/:tagId", isAuthenticated, requireRole("owner", "clerk", "compliance"), async (req: any, res) => {
    try {
      await storage.addTagToContact(req.params.contactId, req.params.tagId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error adding tag to contact:", error);
      res.status(500).json({ error: "Failed to add tag to contact" });
    }
  });

  // Remove tag from contact
  app.delete("/api/contacts/:contactId/tags/:tagId", isAuthenticated, requireRole("owner", "clerk", "compliance"), async (req: any, res) => {
    try {
      await storage.removeTagFromContact(req.params.contactId, req.params.tagId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error removing tag from contact:", error);
      res.status(500).json({ error: "Failed to remove tag from contact" });
    }
  });

  // Get tags for contact
  app.get("/api/contacts/:contactId/tags", isAuthenticated, async (req: any, res) => {
    try {
      const tags = await storage.getTagsForContact(req.params.contactId);
      res.json(tags);
    } catch (error) {
      console.error("Error fetching contact tags:", error);
      res.status(500).json({ error: "Failed to fetch contact tags" });
    }
  });

  // Search entities by tags
  app.post("/api/tags/search", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user || !user.organizationId) {
        return res.status(403).json({ error: "User not associated with an organization" });
      }

      const { tagIds } = req.body;
      if (!Array.isArray(tagIds)) {
        return res.status(400).json({ error: "tagIds must be an array" });
      }

      const results = await storage.searchByTags(user.organizationId, tagIds);
      res.json(results);
    } catch (error) {
      console.error("Error searching by tags:", error);
      res.status(500).json({ error: "Failed to search by tags" });
    }
  });

  // ==================== DASHBOARD STATS ROUTES ====================

  // Get comprehensive dashboard statistics for BTR operators
  app.get("/api/dashboard/stats", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const orgId = user.organizationId;

      // Get filter parameters
      const filterBlockId = req.query.blockId as string | undefined;
      const filterPropertyId = req.query.propertyId as string | undefined;

      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const days7Ago = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
      const days30Ago = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);
      const days90Ago = new Date(today.getTime() - 90 * 24 * 60 * 60 * 1000);
      const days7Future = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);
      const days30Future = new Date(today.getTime() + 30 * 24 * 60 * 60 * 1000);

      // Fetch all required data
      const [allProperties, allBlocks, allInspections, allCompliance, allMaintenance, allTenantAssignments] = await Promise.all([
        storage.getPropertiesByOrganization(orgId),
        storage.getBlocksByOrganization(orgId),
        storage.getInspectionsByOrganization(orgId),
        storage.getComplianceDocuments(orgId),
        storage.getMaintenanceByOrganization(orgId),
        storage.getTenantAssignmentsByOrganization(orgId),
      ]);

      // Apply filters
      let properties = allProperties;
      let blocks = allBlocks;
      let inspections = allInspections;
      let compliance = allCompliance;
      let maintenance = allMaintenance;
      let tenantAssignments = allTenantAssignments;

      // Filter by specific property
      if (filterPropertyId) {
        properties = properties.filter((p: any) => p.id === filterPropertyId);
        inspections = inspections.filter((i: any) => i.propertyId === filterPropertyId);
        compliance = compliance.filter((c: any) => c.propertyId === filterPropertyId);
        maintenance = maintenance.filter((m: any) => m.propertyId === filterPropertyId);
        tenantAssignments = tenantAssignments.filter((t: any) => t.propertyId === filterPropertyId);
        // Get block from property
        const propertyBlock = allProperties.find((p: any) => p.id === filterPropertyId);
        if (propertyBlock?.blockId) {
          blocks = blocks.filter((b: any) => b.id === propertyBlock.blockId);
        }
      }
      // Filter by block (includes all properties in that block)
      else if (filterBlockId) {
        const blockPropertyIds = new Set(allProperties.filter((p: any) => p.blockId === filterBlockId).map((p: any) => p.id));
        blocks = blocks.filter((b: any) => b.id === filterBlockId);
        properties = properties.filter((p: any) => p.blockId === filterBlockId);
        inspections = inspections.filter((i: any) => i.blockId === filterBlockId || (i.propertyId && blockPropertyIds.has(i.propertyId)));
        compliance = compliance.filter((c: any) => c.blockId === filterBlockId || (c.propertyId && blockPropertyIds.has(c.propertyId)));
        maintenance = maintenance.filter((m: any) => blockPropertyIds.has(m.propertyId));
        tenantAssignments = tenantAssignments.filter((t: any) => blockPropertyIds.has(t.propertyId));
      }

      // Calculate overdue inspections
      const overdueInspections = inspections.filter(i => {
        if (i.status === 'completed' || i.status === 'cancelled') return false;
        if (!i.scheduledDate) return false;
        return new Date(i.scheduledDate) < today;
      });

      // Inspections due in next 7 days
      const inspectionsDueNext7Days = inspections.filter(i => {
        if (i.status === 'completed' || i.status === 'cancelled') return false;
        if (!i.scheduledDate) return false;
        const scheduled = new Date(i.scheduledDate);
        return scheduled >= today && scheduled <= days7Future;
      });

      // Inspections due in next 30 days
      const inspectionsDueNext30Days = inspections.filter(i => {
        if (i.status === 'completed' || i.status === 'cancelled') return false;
        if (!i.scheduledDate) return false;
        const scheduled = new Date(i.scheduledDate);
        return scheduled >= today && scheduled <= days30Future;
      });

      // Calculate overdue compliance
      const overdueCompliance = compliance.filter(c => {
        if (!c.expiryDate) return false;
        return new Date(c.expiryDate) < today;
      });

      // Compliance expiring in next 30 days
      const complianceExpiringNext30Days = compliance.filter(c => {
        if (!c.expiryDate) return false;
        const expiry = new Date(c.expiryDate);
        return expiry >= today && expiry <= days30Future;
      });

      // Compliance expiring in next 90 days
      const complianceExpiringNext90Days = compliance.filter(c => {
        if (!c.expiryDate) return false;
        const expiry = new Date(c.expiryDate);
        return expiry >= today && expiry <= new Date(today.getTime() + 90 * 24 * 60 * 60 * 1000);
      });

      // Maintenance stats - include all non-completed/closed items for overdue check
      const activeMaintenance = maintenance.filter(m => m.status !== 'completed' && m.status !== 'closed');
      // Urgent maintenance includes: high/urgent priority OR overdue due dates (regardless of priority)
      const urgentMaintenance = activeMaintenance.filter(m => {
        // Check priority first
        if (m.priority === 'urgent' || m.priority === 'high') {
          return true;
        }
        // Check if due date has passed (for any priority level)
        if (m.dueDate) {
          try {
            const dueDate = new Date(m.dueDate);
            // Normalize to midnight for date-only comparison
            const dueDateOnly = new Date(dueDate.getFullYear(), dueDate.getMonth(), dueDate.getDate());
            // Return true if due date is before today (overdue)
            return dueDateOnly < today;
          } catch (error) {
            // If date parsing fails, skip this check
            console.error('Error parsing dueDate for maintenance', m.id, error);
            return false;
          }
        }
        return false;
      });
      // For openMaintenance count (used in KPIs), only count open/in_progress
      const openMaintenance = maintenance.filter(m => m.status === 'open' || m.status === 'in_progress');
      const inProgressMaintenance = maintenance.filter(m => m.status === 'in_progress');

      // Calculate average resolution time for completed maintenance (last 90 days)
      const completedMaintenance = maintenance.filter(m => {
        if (m.status !== 'completed') return false;
        if (!m.completedAt) return false;
        return new Date(m.completedAt) >= days90Ago;
      });

      let avgResolutionDays = 0;
      if (completedMaintenance.length > 0) {
        const totalDays = completedMaintenance.reduce((sum, m) => {
          if (!m.createdAt || !m.completedAt) return sum;
          const created = new Date(m.createdAt);
          const completed = new Date(m.completedAt);
          return sum + Math.ceil((completed.getTime() - created.getTime()) / (1000 * 60 * 60 * 24));
        }, 0);
        avgResolutionDays = Math.round(totalDays / completedMaintenance.length * 10) / 10;
      }

      // Calculate occupancy rate - count properties with active tenant assignments
      // Tenant assignments use isActive boolean field (mapped from is_active in DB)
      // Handle both camelCase (isActive) and snake_case (is_active) for compatibility
      const activeAssignments = tenantAssignments.filter(t => {
        const isActive = t.isActive !== undefined ? t.isActive : (t as any).is_active;
        return isActive === true;
      });
      const occupiedProperties = new Set(activeAssignments.map(t => t.propertyId || (t as any).property_id));
      const occupancyRate = properties.length > 0
        ? Math.round((occupiedProperties.size / properties.length) * 100)
        : 0;

      // Debug logging (remove in production if needed)
      if (process.env.NODE_ENV !== 'production') {
        console.log('[Dashboard Stats] Occupancy calculation:', {
          totalProperties: properties.length,
          totalTenantAssignments: tenantAssignments.length,
          activeAssignments: activeAssignments.length,
          occupiedProperties: occupiedProperties.size,
          occupancyRate,
          sampleAssignment: tenantAssignments[0] ? {
            id: tenantAssignments[0].id,
            propertyId: tenantAssignments[0].propertyId || (tenantAssignments[0] as any).property_id,
            isActive: tenantAssignments[0].isActive !== undefined ? tenantAssignments[0].isActive : (tenantAssignments[0] as any).is_active,
            allKeys: Object.keys(tenantAssignments[0] || {})
          } : null
        });
      }

      // Calculate compliance rate (valid documents vs total required)
      const validCompliance = compliance.filter(c => {
        if (!c.expiryDate) return true; // No expiry = always valid
        return new Date(c.expiryDate) >= today;
      });
      const complianceRate = compliance.length > 0
        ? Math.round((validCompliance.length / compliance.length) * 100)
        : 100;

      // Inspection completion rate (last 90 days)
      const recentInspections = inspections.filter(i => {
        if (!i.createdAt) return false;
        const createdAt = i.createdAt instanceof Date ? i.createdAt : new Date(i.createdAt);
        return createdAt >= days90Ago;
      });
      const completedRecentInspections = recentInspections.filter(i => i.status === 'completed');
      const inspectionCompletionRate = recentInspections.length > 0
        ? Math.round((completedRecentInspections.length / recentInspections.length) * 100)
        : 0;

      // Properties at risk (have overdue inspections or expired compliance)
      const propertiesWithOverdueInspections = new Set(overdueInspections.map(i => i.propertyId).filter(Boolean));
      const propertiesWithExpiredCompliance = new Set(overdueCompliance.map(c => c.propertyId).filter(Boolean));
      const propertiesAtRisk = new Set([...Array.from(propertiesWithOverdueInspections), ...Array.from(propertiesWithExpiredCompliance)]);

      // Blocks at risk
      const blocksWithOverdueInspections = new Set(overdueInspections.map(i => i.blockId).filter(Boolean));
      const blocksAtRisk = blocksWithOverdueInspections;

      // Trend data - inspections scheduled, completed, and overdue per week for last 12 weeks
      const inspectionTrendData = [];
      for (let i = 11; i >= 0; i--) {
        const weekStart = new Date(today.getTime() - (i + 1) * 7 * 24 * 60 * 60 * 1000);
        const weekEnd = new Date(today.getTime() - i * 7 * 24 * 60 * 60 * 1000);

        // Count scheduled inspections for this week
        const scheduled = inspections.filter(insp => {
          if (!insp.scheduledDate) return false;
          const scheduledDate = new Date(insp.scheduledDate);
          return scheduledDate >= weekStart && scheduledDate < weekEnd;
        }).length;

        // Count completed inspections for this week
        const completed = inspections.filter(insp => {
          if (insp.status !== 'completed' || !insp.completedDate) return false;
          const completedDateValue = new Date(insp.completedDate);
          return completedDateValue >= weekStart && completedDateValue < weekEnd;
        }).length;

        // Count overdue inspections as of this week's end (scheduled before weekEnd but not completed by weekEnd)
        const overdue = inspections.filter(insp => {
          if (!insp.scheduledDate) return false;
          const scheduledDate = new Date(insp.scheduledDate);
          // Was scheduled before the week ended
          if (scheduledDate >= weekEnd) return false;
          // Check if it was overdue as of this week
          if (insp.status === 'completed' && insp.completedDate) {
            const completedDate = new Date(insp.completedDate);
            // If completed after scheduled date and that happened within this week period
            return scheduledDate < weekStart && completedDate >= weekStart && completedDate < weekEnd && completedDate > scheduledDate;
          }
          // Still not completed and was scheduled before this week
          return insp.status !== 'completed' && scheduledDate < weekStart;
        }).length;

        inspectionTrendData.push({
          week: weekStart.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
          scheduled,
          completed,
          overdue
        });
      }

      // Maintenance trend - new requests per week for last 12 weeks
      const maintenanceTrendData = [];
      for (let i = 11; i >= 0; i--) {
        const weekStart = new Date(today.getTime() - (i + 1) * 7 * 24 * 60 * 60 * 1000);
        const weekEnd = new Date(today.getTime() - i * 7 * 24 * 60 * 60 * 1000);
        const created = maintenance.filter(m => {
          if (!m.createdAt) return false;
          const createdDate = new Date(m.createdAt);
          return createdDate >= weekStart && createdDate < weekEnd;
        }).length;
        maintenanceTrendData.push({
          week: weekStart.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
          created
        });
      }

      res.json({
        // Summary counts
        totals: {
          properties: properties.length,
          blocks: blocks.length,
          inspections: inspections.length,
          maintenance: maintenance.length,
          compliance: compliance.length,
        },

        // Critical alerts
        alerts: {
          overdueInspections: overdueInspections.length,
          overdueInspectionsList: overdueInspections.slice(0, 10).map(i => ({
            id: i.id,
            propertyId: i.propertyId,
            blockId: i.blockId,
            type: i.type,
            scheduledDate: i.scheduledDate,
            daysOverdue: Math.ceil((today.getTime() - new Date(i.scheduledDate!).getTime()) / (1000 * 60 * 60 * 24))
          })),
          overdueCompliance: overdueCompliance.length,
          overdueComplianceList: overdueCompliance.slice(0, 10).map(c => ({
            id: c.id,
            propertyId: c.propertyId,
            blockId: c.blockId,
            documentType: c.documentType,
            expiryDate: c.expiryDate,
            daysOverdue: Math.ceil((today.getTime() - new Date(c.expiryDate!).getTime()) / (1000 * 60 * 60 * 24))
          })),
          urgentMaintenance: urgentMaintenance.length,
          urgentMaintenanceList: urgentMaintenance.slice(0, 10).map(m => {
            let daysOverdue = 0;
            if (m.dueDate) {
              try {
                const dueDate = new Date(m.dueDate);
                const dueDateOnly = new Date(dueDate.getFullYear(), dueDate.getMonth(), dueDate.getDate());
                if (dueDateOnly < today) {
                  daysOverdue = Math.ceil((today.getTime() - dueDateOnly.getTime()) / (1000 * 60 * 60 * 24));
                }
              } catch (error) {
                // Ignore date parsing errors
              }
            }

            return {
              id: m.id,
              title: m.title,
              propertyId: m.propertyId,
              priority: m.priority,
              dueDate: m.dueDate,
              daysOverdue: daysOverdue,
              createdAt: m.createdAt
            };
          }),
        },

        // Due soon
        upcoming: {
          inspectionsDueNext7Days: inspectionsDueNext7Days.length,
          inspectionsDueNext30Days: inspectionsDueNext30Days.length,
          complianceExpiringNext30Days: complianceExpiringNext30Days.length,
          complianceExpiringNext90Days: complianceExpiringNext90Days.length,
        },

        // KPIs
        kpis: {
          occupancyRate,
          complianceRate,
          inspectionCompletionRate,
          avgMaintenanceResolutionDays: avgResolutionDays,
          openMaintenanceCount: openMaintenance.length,
          inProgressMaintenanceCount: inProgressMaintenance.length,
        },

        // Risk summary
        risk: {
          propertiesAtRiskCount: propertiesAtRisk.size,
          blocksAtRiskCount: blocksAtRisk.size,
          propertiesAtRiskIds: Array.from(propertiesAtRisk).slice(0, 20),
          blocksAtRiskIds: Array.from(blocksAtRisk).slice(0, 20),
        },

        // Trend data for charts
        trends: {
          inspections: inspectionTrendData,
          maintenance: maintenanceTrendData,
        }
      });
    } catch (error) {
      console.error("Error fetching dashboard stats:", error);
      res.status(500).json({ message: "Failed to fetch dashboard stats" });
    }
  });

  // ==================== DASHBOARD PREFERENCES ROUTES ====================

  // Define role-based panel permissions
  const PANEL_PERMISSIONS: Record<string, string[]> = {
    stats: ["owner", "clerk", "compliance"],
    inspections: ["owner", "clerk"],
    compliance: ["owner", "compliance"],
    maintenance: ["owner", "clerk"],
    assets: ["owner", "clerk"],
    workOrders: ["owner", "contractor"],
    inspectionTrend: ["owner", "clerk"],
    statusDistribution: ["owner", "clerk", "compliance"],
    credits: ["owner"],
  };

  // Get allowed panels for a role
  function getAllowedPanels(role: string): string[] {
    return Object.keys(PANEL_PERMISSIONS).filter(panel =>
      PANEL_PERMISSIONS[panel].includes(role)
    );
  }

  // Filter panels based on role permissions
  function filterPanelsByRole(panels: string[], role: string): string[] {
    const allowed = getAllowedPanels(role);
    return panels.filter(panel => allowed.includes(panel));
  }

  // Get dashboard preferences
  app.get("/api/dashboard/preferences", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      const prefs = await storage.getDashboardPreferences(userId);

      // Default panels based on role
      const defaultPanels = getAllowedPanels(user.role);

      if (!prefs) {
        return res.json({ enabledPanels: defaultPanels });
      }

      // Parse enabled panels if stored as string
      let enabledPanels = prefs.enabledPanels;
      if (typeof enabledPanels === "string") {
        enabledPanels = JSON.parse(enabledPanels);
      }

      // Filter panels to only those allowed for user's role
      const filteredPanels = filterPanelsByRole(enabledPanels as string[], user.role);

      res.json({ enabledPanels: filteredPanels });
    } catch (error) {
      console.error("Error fetching dashboard preferences:", error);
      res.status(500).json({ error: "Failed to fetch dashboard preferences" });
    }
  });

  // Update dashboard preferences
  app.put("/api/dashboard/preferences", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      const { enabledPanels } = req.body;

      if (!Array.isArray(enabledPanels)) {
        return res.status(400).json({ error: "enabledPanels must be an array" });
      }

      // Filter panels to only those allowed for user's role
      const filteredPanels = filterPanelsByRole(enabledPanels, user.role);

      const prefs = await storage.updateDashboardPreferences(userId, filteredPanels);
      res.json({ ...prefs, enabledPanels: filteredPanels });
    } catch (error) {
      console.error("Error updating dashboard preferences:", error);
      res.status(500).json({ error: "Failed to update dashboard preferences" });
    }
  });

  // ==================== INSPECTION TEMPLATE ROUTES ====================

  // Template Categories
  app.get("/api/template-categories", isAuthenticated, requireRole('owner', 'clerk', 'compliance'), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const categories = await storage.getTemplateCategoriesByOrganization(user.organizationId);
      res.json(categories);
    } catch (error) {
      console.error("Error fetching template categories:", error);
      res.status(500).json({ message: "Failed to fetch template categories" });
    }
  });

  app.post("/api/template-categories", isAuthenticated, requireRole('owner', 'clerk'), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const validatedData = insertTemplateCategorySchema.parse({
        ...req.body,
        organizationId: user.organizationId
      });
      const category = await storage.createTemplateCategory(validatedData);
      res.status(201).json(category);
    } catch (error) {
      console.error("Error creating template category:", error);
      res.status(400).json({ message: "Failed to create template category" });
    }
  });

  app.put("/api/template-categories/:id", isAuthenticated, requireRole('owner', 'clerk'), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      // Verify ownership
      const existing = await storage.getTemplateCategory(req.params.id);
      if (!existing || existing.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Category not found" });
      }
      const category = await storage.updateTemplateCategory(req.params.id, req.body);
      res.json(category);
    } catch (error) {
      console.error("Error updating template category:", error);
      res.status(400).json({ message: "Failed to update template category" });
    }
  });

  app.delete("/api/template-categories/:id", isAuthenticated, requireRole('owner'), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const existing = await storage.getTemplateCategory(req.params.id);
      if (!existing || existing.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Category not found" });
      }
      await storage.deleteTemplateCategory(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting template category:", error);
      res.status(500).json({ message: "Failed to delete template category" });
    }
  });

  // Inspection Templates
  app.get("/api/inspection-templates", isAuthenticated, requireRole('owner', 'clerk', 'compliance'), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const { scope, categoryId, active } = req.query;
      let templates = await storage.getInspectionTemplatesByOrganization(user.organizationId);

      // Apply filtering based on query parameters
      if (scope && scope !== 'all') {
        if (scope === 'both') {
          // When filtering by "both", show ONLY templates with scope='both'
          templates = templates.filter(t => t.scope === 'both');
        } else {
          // When filtering by specific scope (property/block), also include templates with scope='both'
          templates = templates.filter(t => t.scope === scope || t.scope === 'both');
        }
      }
      if (categoryId && categoryId !== 'all') {
        templates = templates.filter(t => t.categoryId === categoryId);
      }
      if (active !== undefined && active !== 'all') {
        const isActive = active === 'true';
        templates = templates.filter(t => t.isActive === isActive);
      }

      res.json(templates);
    } catch (error) {
      console.error("Error fetching inspection templates:", error);
      res.status(500).json({ message: "Failed to fetch inspection templates" });
    }
  });

  app.get("/api/inspection-templates/:id", isAuthenticated, requireRole('owner', 'clerk', 'compliance'), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const template = await storage.getInspectionTemplate(req.params.id);
      if (!template || template.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Template not found" });
      }
      res.json(template);
    } catch (error) {
      console.error("Error fetching inspection template:", error);
      res.status(500).json({ message: "Failed to fetch inspection template" });
    }
  });

  app.post("/api/inspection-templates", isAuthenticated, requireRole('owner', 'clerk'), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const validatedData = insertInspectionTemplateSchema.parse({
        ...req.body,
        organizationId: user.organizationId,
        createdBy: req.user.id
      });
      const template = await storage.createInspectionTemplate(validatedData);
      res.status(201).json(template);
    } catch (error) {
      console.error("Error creating inspection template:", error);
      res.status(400).json({ message: "Failed to create inspection template" });
    }
  });

  app.put("/api/inspection-templates/:id", isAuthenticated, requireRole('owner', 'clerk'), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const existing = await storage.getInspectionTemplate(req.params.id);
      if (!existing || existing.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Template not found" });
      }

      // Prepare updates - stringify structureJson if it's an object
      const updates: any = { ...req.body };
      if (updates.structureJson && typeof updates.structureJson !== 'string') {
        updates.structureJson = JSON.stringify(updates.structureJson);
      }

      // Remove fields that shouldn't be updated via API
      delete updates.id;
      delete updates.organizationId;
      delete updates.createdBy;
      delete updates.createdAt;
      delete updates.updatedAt;

      const template = await storage.updateInspectionTemplate(req.params.id, updates);
      res.json(template);
    } catch (error) {
      console.error("Error updating inspection template:", error);
      res.status(400).json({ message: "Failed to update inspection template" });
    }
  });

  app.delete("/api/inspection-templates/:id", isAuthenticated, requireRole('owner'), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const existing = await storage.getInspectionTemplate(req.params.id);
      if (!existing || existing.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Template not found" });
      }
      await storage.deleteInspectionTemplate(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting inspection template:", error);
      res.status(500).json({ message: "Failed to delete inspection template" });
    }
  });

  // Clone template (create new version)
  app.post("/api/inspection-templates/:id/clone", isAuthenticated, requireRole('owner', 'clerk'), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const existing = await storage.getInspectionTemplate(req.params.id);
      if (!existing || existing.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Template not found" });
      }

      // Create new template with incremented version
      const newVersion = existing.version + 1;
      const clonedTemplate = await storage.createInspectionTemplate({
        organizationId: user.organizationId,
        name: req.body.name || `${existing.name} (v${newVersion})`,
        description: req.body.description || existing.description,
        categoryId: existing.categoryId,
        scope: existing.scope,
        structureJson: existing.structureJson as any,
        version: newVersion,
        parentTemplateId: existing.parentTemplateId || existing.id,
        isActive: req.body.isActive ?? false,
        createdBy: req.user.id
      });

      res.status(201).json(clonedTemplate);
    } catch (error) {
      console.error("Error cloning inspection template:", error);
      res.status(400).json({ message: "Failed to clone inspection template" });
    }
  });

  // Template Inventory Links
  app.get("/api/inspection-templates/:templateId/inventory-links", isAuthenticated, requireRole('owner', 'clerk', 'compliance'), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const template = await storage.getInspectionTemplate(req.params.templateId);
      if (!template || template.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Template not found" });
      }
      const links = await storage.getTemplateInventoryLinks(req.params.templateId);
      res.json(links);
    } catch (error) {
      console.error("Error fetching template inventory links:", error);
      res.status(500).json({ message: "Failed to fetch template inventory links" });
    }
  });

  app.post("/api/template-inventory-links", isAuthenticated, requireRole('owner', 'clerk'), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const validatedData = insertTemplateInventoryLinkSchema.parse(req.body);
      // Verify template ownership
      const template = await storage.getInspectionTemplate(validatedData.templateId);
      if (!template || template.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Unauthorized" });
      }
      const link = await storage.createTemplateInventoryLink(validatedData);
      res.status(201).json(link);
    } catch (error) {
      console.error("Error creating template inventory link:", error);
      res.status(400).json({ message: "Failed to create template inventory link" });
    }
  });

  app.delete("/api/template-inventory-links/:id", isAuthenticated, requireRole('owner', 'clerk'), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      await storage.deleteTemplateInventoryLink(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting template inventory link:", error);
      res.status(500).json({ message: "Failed to delete template inventory link" });
    }
  });

  // Inspection Entries
  app.get("/api/inspections/:inspectionId/entries", isAuthenticated, async (req: any, res) => {
    try {
      const { inspectionId } = req.params;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user) {
        return res.status(403).json({ message: "Access denied" });
      }

      // For tenants, verify access to the inspection
      if (user.role === "tenant") {
        const inspection = await storage.getInspection(inspectionId);
        if (!inspection) {
          return res.status(404).json({ message: "Inspection not found" });
        }
        const tenancy = await storage.getTenancyByTenantId(userId);
        if (!tenancy || tenancy.propertyId !== inspection.propertyId) {
          return res.status(403).json({ message: "Access denied" });
        }
        if (inspection.type !== "check_in") {
          return res.status(403).json({ message: "Access denied: Tenants can only view check-in inspections" });
        }
      } else if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      // Set cache-control headers to prevent caching
      res.setHeader("Cache-Control", "no-cache, no-store, must-revalidate");
      res.setHeader("Pragma", "no-cache");
      res.setHeader("Expires", "0");
      const entries = await storage.getInspectionEntries(inspectionId);
      
      
      res.json(entries);
    } catch (error) {
      console.error("Error fetching inspection entries:", error);
      res.status(500).json({ message: "Failed to fetch inspection entries" });
    }
  });

  // Get most recent check-in inspection for a property (for copying to check-out)
  app.get("/api/properties/:propertyId/most-recent-checkin", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const { propertyId } = req.params;
      const property = await storage.getProperty(propertyId);

      if (!property || property.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Property not found" });
      }

      const checkInInspection = await storage.getMostRecentCheckInInspection(propertyId);

      if (!checkInInspection) {
        return res.json(null);
      }

      // Also fetch the entries for this check-in inspection
      const entries = await storage.getInspectionEntries(checkInInspection.id);

      res.json({
        inspection: checkInInspection,
        entries: entries,
      });
    } catch (error) {
      console.error("Error fetching most recent check-in inspection:", error);
      res.status(500).json({ message: "Failed to fetch check-in inspection" });
    }
  });

  app.get("/api/inspection-entries/:id", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const entry = await storage.getInspectionEntry(req.params.id);
      if (!entry) {
        return res.status(404).json({ message: "Entry not found" });
      }
      res.json(entry);
    } catch (error) {
      console.error("Error fetching inspection entry:", error);
      res.status(500).json({ message: "Failed to fetch inspection entry" });
    }
  });

  app.post("/api/inspection-entries", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const validatedData = insertInspectionEntrySchema.parse(req.body);

      // Debug: Log valueJson structure
      if (validatedData.valueJson && typeof validatedData.valueJson === 'object' && 'audioUrl' in validatedData.valueJson) {
        console.log('[Server] Saving entry with audioUrl:', {
          sectionRef: validatedData.sectionRef,
          fieldKey: validatedData.fieldKey,
          valueJson: validatedData.valueJson,
          audioUrl: (validatedData.valueJson as any).audioUrl
        });
      }

      // Check if an entry already exists for this inspection, section, and field
      // This allows updating existing entries instead of creating duplicates
      const existingEntries = await storage.getInspectionEntries(validatedData.inspectionId);
      const existingEntry = existingEntries.find(
        (e: any) =>
          e.sectionRef === validatedData.sectionRef &&
          e.fieldKey === validatedData.fieldKey &&
          e.inspectionId === validatedData.inspectionId
      );

      let entry;
      if (existingEntry?.id) {
        // Update existing entry
        entry = await storage.updateInspectionEntry(existingEntry.id, validatedData);
        // Debug: Log what was saved
        if (entry.valueJson && typeof entry.valueJson === 'object' && 'audioUrl' in entry.valueJson) {
          console.log('[Server] Updated entry with audioUrl:', {
            id: entry.id,
            valueJson: entry.valueJson,
            audioUrl: (entry.valueJson as any).audioUrl
          });
        }
        res.json(entry);
      } else {
        // Create new entry
        entry = await storage.createInspectionEntry(validatedData);
        // Debug: Log what was saved
        if (entry.valueJson && typeof entry.valueJson === 'object' && 'audioUrl' in entry.valueJson) {
          console.log('[Server] Created entry with audioUrl:', {
            id: entry.id,
            valueJson: entry.valueJson,
            audioUrl: (entry.valueJson as any).audioUrl
          });
        }
        res.status(201).json(entry);
      }
    } catch (error) {
      console.error("Error creating/updating inspection entry:", error);
      res.status(400).json({ message: "Failed to create/update inspection entry" });
    }
  });

  // Batch create entries (for offline sync)
  app.post("/api/inspection-entries/batch", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const { entries } = req.body;
      if (!Array.isArray(entries)) {
        return res.status(400).json({ message: "entries must be an array" });
      }
      const validatedEntries = entries.map(e => insertInspectionEntrySchema.parse(e));
      const created = await storage.createInspectionEntriesBatch(validatedEntries);
      res.status(201).json(created);
    } catch (error) {
      console.error("Error batch creating inspection entries:", error);
      res.status(400).json({ message: "Failed to batch create inspection entries" });
    }
  });

  app.put("/api/inspection-entries/:id", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const entry = await storage.updateInspectionEntry(req.params.id, req.body);
      res.json(entry);
    } catch (error) {
      console.error("Error updating inspection entry:", error);
      res.status(400).json({ message: "Failed to update inspection entry" });
    }
  });

  app.patch("/api/inspection-entries/:id", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const entry = await storage.updateInspectionEntry(req.params.id, req.body);
      res.json(entry);
    } catch (error) {
      console.error("Error updating inspection entry:", error);
      res.status(400).json({ message: "Failed to update inspection entry" });
    }
  });

  app.delete("/api/inspection-entries/:id", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      await storage.deleteInspectionEntry(req.params.id);
      res.status(204).send();
    } catch (error) {
      console.error("Error deleting inspection entry:", error);
      res.status(500).json({ message: "Failed to delete inspection entry" });
    }
  });

  // AI Image Analyses
  app.get("/api/inspections/:inspectionId/ai-analyses", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const analyses = await storage.getAiImageAnalysesByInspection(req.params.inspectionId);
      res.json(analyses);
    } catch (error) {
      console.error("Error fetching AI analyses:", error);
      res.status(500).json({ message: "Failed to fetch AI analyses" });
    }
  });

  app.get("/api/inspection-entries/:entryId/ai-analyses", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }
      const analyses = await storage.getAiImageAnalysesByEntry(req.params.entryId);
      res.json(analyses);
    } catch (error) {
      console.error("Error fetching AI analyses:", error);
      res.status(500).json({ message: "Failed to fetch AI analyses" });
    }
  });

  app.post("/api/ai-analyses", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user || !user.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const { inspectionId, inspectionEntryId, imageUrl, context } = req.body;

      // Verify user has access to this inspection
      const inspection = await storage.getInspection(inspectionId);
      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }

      // Check if organization has credits
      const creditBalance = await storage.getCreditBalance(user.organizationId);
      if (creditBalance.total < 1) {
        return res.status(402).json({ message: "Insufficient AI credits" });
      }

      // Convert image URL to base64 data URL (for internal object storage)
      console.log("[Individual Photo Analysis] Processing photo:", imageUrl);

      let dataUrl: string;
      if (imageUrl.startsWith("http")) {
        // External URL - use directly
        dataUrl = imageUrl;
        console.log("[Individual Photo Analysis] Using external URL directly");
      } else {
        // Internal object storage - convert to base64
        try {
          const objectStorageService = new ObjectStorageService();
          // Ensure path starts with /objects/
          const photoPath = imageUrl.startsWith('/objects/') ? imageUrl : `/objects/${imageUrl}`;
          const objectFile = await objectStorageService.getObjectEntityFile(photoPath);

          // Read the file contents using fs.readFile first
          const photoBuffer = await fs.readFile(objectFile.name);

          // Always detect MIME type from buffer for reliability
          let mimeType = detectImageMimeType(photoBuffer);

          // Get metadata for logging purposes
          const [metadata] = await objectFile.getMetadata();
          const metadataContentType = metadata.contentType;

          console.log(`[Individual Photo Analysis] MIME type detection:`, {
            detected: mimeType,
            fromMetadata: metadataContentType,
            bufferSize: photoBuffer.length,
            firstBytes: Array.from(photoBuffer.slice(0, 12)).map(b => `0x${b.toString(16).padStart(2, '0')}`).join(' ')
          });

          // Ensure we have a valid image MIME type
          if (!mimeType || !mimeType.startsWith('image/')) {
            console.warn(`[Individual Photo Analysis] Invalid MIME type detected: ${mimeType}, defaulting to image/jpeg`);
            mimeType = 'image/jpeg';
          }

          // Convert to base64 data URL
          const base64Image = photoBuffer.toString('base64');
          dataUrl = `data:${mimeType};base64,${base64Image}`;

          // Validate the data URL format
          if (!dataUrl.startsWith(`data:${mimeType};base64,`)) {
            throw new Error(`Invalid data URL format: ${dataUrl.substring(0, 50)}...`);
          }

          console.log("[Individual Photo Analysis] Converted to base64 data URL:", photoPath, `(${mimeType}, ${base64Image.length} bytes)`);
        } catch (error: any) {
          // Safely log error without circular reference issues
          const errorMessage = error?.message || String(error);
          console.error("[Individual Photo Analysis] Error converting photo to base64:", {
            imageUrl,
            message: errorMessage,
            errorType: error?.constructor?.name,
          });
          if (error instanceof ObjectNotFoundError) {
            throw new Error(`Photo not found: ${imageUrl}. The file may have been deleted or moved.`);
          }
          throw new Error(`Failed to load photo for analysis: ${imageUrl}. ${errorMessage}`);
        }
      }

      // Call OpenAI Vision API using Responses API
      const openaiClient = getOpenAI();
      const response = await openaiClient.responses.create({
        model: "gpt-5", // the newest OpenAI model is "gpt-5" which was released August 7, 2025. do not change this unless explicitly requested by the user
        input: [
          {
            role: "user",
            content: normalizeApiContent([
              {
                type: "text",
                text: context || "Analyze this inspection photo. Identify the room/item, assess its condition, note any defects, damage, or issues that require attention. Provide a detailed assessment."
              },
              {
                type: "image_url",
                image_url: dataUrl
              }
            ])
          }
        ],
        max_output_tokens: 500
      });

      let analysisText = response.output_text || (response.output?.[0] as any)?.content?.[0]?.text || "";

      // Strip markdown asterisks from the response
      analysisText = analysisText.replace(/\*\*/g, '');

      // Consume credit using credit batch system
      const { subscriptionService } = await import("./subscriptionService");
      await subscriptionService.consumeCredits(
        user.organizationId,
        1,
        "ai_analysis",
        inspectionId || inspectionEntryId || "individual_photo",
        "Individual photo AI analysis"
      );

      // Get updated credit balance for response
      const updatedBalance = await storage.getCreditBalance(user.organizationId);

      // Save analysis
      const validatedData = insertAiImageAnalysisSchema.parse({
        inspectionId: inspectionId || undefined,
        inspectionEntryId: inspectionEntryId || undefined,
        mediaUrl: imageUrl, // Schema expects mediaUrl, not imageUrl
        mediaType: "photo",
        model: "gpt-5",
        resultJson: { text: analysisText, model: "gpt-5" },
      });
      const analysis = await storage.createAiImageAnalysis(validatedData);

      res.status(201).json({ ...analysis, remainingCredits: updatedBalance.total });
    } catch (error: any) {
      // Safely log error without circular reference issues
      const errorMessage = error?.message || String(error);
      const errorStack = error?.stack;
      console.error("Error creating AI analysis:", {
        message: errorMessage,
        stack: errorStack,
        status: error?.status,
        code: error?.code,
        type: error?.type,
      });
      res.status(500).json({ message: "Failed to create AI analysis" });
    }
  });

  // ==================== DEFAULT LOGO ROUTE ====================
  // Serve the default Inspect360 logo for mobile app (matching web app's @assets import)
  app.get("/default-logo.png", async (req, res) => {
    try {
      const path = require("path");
      const fs = require("fs");
      const logoPath = path.resolve(import.meta.dirname, "..", "attached_assets", "Inspect360 Logo_1761302629835.png");
      
      if (fs.existsSync(logoPath)) {
        res.setHeader("Content-Type", "image/png");
        res.setHeader("Cache-Control", "public, max-age=31536000, immutable");
        res.sendFile(logoPath);
      } else {
        // Fallback to logo.png in client/public if attached_assets logo doesn't exist
        const fallbackPath = path.resolve(import.meta.dirname, "..", "client", "public", "logo.png");
        if (fs.existsSync(fallbackPath)) {
          res.setHeader("Content-Type", "image/png");
          res.setHeader("Cache-Control", "public, max-age=31536000, immutable");
          res.sendFile(fallbackPath);
        } else {
          res.sendStatus(404);
        }
      }
    } catch (error) {
      console.error("Error serving default logo:", error);
      res.sendStatus(500);
    }
  });

  // ==================== OBJECT STORAGE ROUTES ====================

  app.get("/objects/:objectPath(*)", async (req: any, res) => {
    const userId = req.user?.claims?.sub || req.user?.id;
    const objectStorageService = new ObjectStorageService();
    try {
      const objectFile = await objectStorageService.getObjectEntityFile(req.path);

      // Community banners are public by default (for tenant portal access)
      const isCommunityBanner = req.path.includes('/community-banners/');

      let canAccess = false;
      if (isCommunityBanner) {
        // For community banners, check ACL but also allow if no ACL exists (treat as public)
        const aclPolicy = await getObjectAclPolicy(objectFile);
        if (!aclPolicy || aclPolicy.visibility === 'public') {
          canAccess = true;
        } else {
          canAccess = await objectStorageService.canAccessObjectEntity({
            objectFile,
            userId: userId,
            requestedPermission: ObjectPermission.READ,
          });
        }
      } else {
        canAccess = await objectStorageService.canAccessObjectEntity({
          objectFile,
          userId: userId,
          requestedPermission: ObjectPermission.READ,
        });
      }

      if (!canAccess) {
        return res.sendStatus(401);
      }
      objectStorageService.downloadObject(objectFile, res);
    } catch (error) {
      if (error instanceof ObjectNotFoundError) {
        // Object not found is a normal case, return 404 without logging as error
        return res.sendStatus(404);
      }
      // Only log unexpected errors
      console.error("Error checking object access:", error);
      return res.sendStatus(500);
    }
  });

  app.post("/api/objects/upload", isAuthenticated, async (req, res) => {
    try {
      const objectStorageService = new ObjectStorageService();
      const relativePath = await objectStorageService.getObjectEntityUploadURL();

      // Convert relative path to absolute URL
      const baseUrl = getBaseUrl(req);
      const uploadURL = `${baseUrl}${relativePath}`;

      res.json({ uploadURL });
    } catch (error: any) {
      console.error("Error generating upload URL:", error);
      res.status(500).json({ error: "Failed to generate upload URL" });
    }
  });

  // Generate upload URL for branding/logo uploads (used by Settings page)
  app.post("/api/upload/generate-upload-url", isAuthenticated, async (req, res) => {
    try {
      const objectStorageService = new ObjectStorageService();
      const relativePath = await objectStorageService.getObjectEntityUploadURL();

      // Convert relative path to absolute URL
      const baseUrl = getBaseUrl(req);
      const uploadUrl = `${baseUrl}${relativePath}`;

      res.json({ uploadUrl });
    } catch (error: any) {
      console.error("Error generating upload URL:", error);
      res.status(500).json({ error: "Failed to generate upload URL" });
    }
  });

  // Direct upload endpoint for local storage (returns upload URL that points to upload-file)
  // Supports both POST (multer) and PUT (raw body) for compatibility with Uppy AwsS3 plugin
  app.post("/api/objects/upload-direct", isAuthenticated, upload.single('file'), async (req: any, res: any) => {
    try {
      const objectId = req.query.objectId || randomUUID();
      const objectStorageService = new ObjectStorageService();

      if (!req.file) {
        return res.status(400).json({ error: "No file uploaded" });
      }

      const normalizedPath = await objectStorageService.saveUploadedFile(
        objectId as string,
        req.file.buffer,
        req.file.mimetype
      );

      // Generate ETag for S3 compatibility (Uppy AwsS3 plugin requires this)
      const etag = createHash('md5').update(req.file.buffer).digest('hex');

      // Set ETag header for S3 compatibility (required by Uppy)
      res.set('ETag', `"${etag}"`);
      // Also set CORS headers to allow reading ETag
      res.set('Access-Control-Expose-Headers', 'ETag');

      // Set ACL to public
      const userId = req.user?.claims?.sub || req.user?.id;
      if (userId) {
        try {
          await objectStorageService.trySetObjectEntityAclPolicy(normalizedPath, {
            owner: userId,
            visibility: "public",
          });
        } catch (error) {
          console.warn("Failed to set ACL:", error);
        }
      }

      res.json({
        url: normalizedPath,
        uploadURL: normalizedPath
      });
    } catch (error) {
      console.error("Error in upload-direct:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Helper: convert audio buffer to MP3 (iOS M4A compatibility - Whisper often rejects iOS M4A)
  async function convertToMp3(inputBuffer: Buffer, inputExt: string): Promise<Buffer> {
    const ffmpegPath = (await import("ffmpeg-static"))?.default;
    if (!ffmpegPath) throw new Error("ffmpeg not available");
    const ffmpegMod = await import("fluent-ffmpeg");
    const ffmpeg = (ffmpegMod as any).default ?? ffmpegMod;
    (ffmpeg as any).setFfmpegPath(ffmpegPath);
    const inputPath = path.join(os.tmpdir(), `whisper-in-${randomUUID()}.${inputExt}`);
    const outputPath = path.join(os.tmpdir(), `whisper-out-${randomUUID()}.mp3`);
    await fs.writeFile(inputPath, inputBuffer);
    try {
      await new Promise<void>((resolve, reject) => {
        ffmpeg(inputPath)
          .noVideo()
          .audioCodec('libmp3lame')
          .audioBitrate(128)
          .format('mp3')
          .save(outputPath)
          .on('end', () => resolve())
          .on('error', (err: Error) => reject(err));
      });
      const mp3Buffer = await fs.readFile(outputPath);
      return mp3Buffer;
    } finally {
      await fs.unlink(inputPath).catch(() => {});
      await fs.unlink(outputPath).catch(() => {});
    }
  }

  // Helper: convert to WAV (fallback when MP3 fails - Whisper reliably handles WAV)
  async function convertToWav(inputBuffer: Buffer, inputExt: string): Promise<Buffer> {
    const ffmpegPath = (await import("ffmpeg-static"))?.default;
    if (!ffmpegPath) throw new Error("ffmpeg not available");
    const ffmpegMod = await import("fluent-ffmpeg");
    const ffmpeg = (ffmpegMod as any).default ?? ffmpegMod;
    (ffmpeg as any).setFfmpegPath(ffmpegPath);
    const inputPath = path.join(os.tmpdir(), `whisper-wav-in-${randomUUID()}.${inputExt}`);
    const outputPath = path.join(os.tmpdir(), `whisper-wav-out-${randomUUID()}.wav`);
    await fs.writeFile(inputPath, inputBuffer);
    try {
      await new Promise<void>((resolve, reject) => {
        ffmpeg(inputPath)
          .noVideo()
          .audioCodec('pcm_s16le')
          .format('wav')
          .outputOptions(['-ac', '1', '-ar', '16000'])
          .save(outputPath)
          .on('end', () => resolve())
          .on('error', (err: Error) => reject(err));
      });
      return await fs.readFile(outputPath);
    } finally {
      await fs.unlink(inputPath).catch(() => {});
      await fs.unlink(outputPath).catch(() => {});
    }
  }

  // Audio transcription via base64 (avoids multipart/FormData binary corruption on mobile)
  app.post("/api/audio/transcribe-base64", isAuthenticated, async (req: any, res: any) => {
    try {
      const { audioBase64, fileName: reqFileName } = req.body || {};
      if (!audioBase64 || typeof audioBase64 !== 'string') {
        return res.status(400).json({ error: "Missing audioBase64 in request body" });
      }
      const buffer = Buffer.from(audioBase64, 'base64');
      const fileName = (reqFileName && typeof reqFileName === 'string' && reqFileName.toLowerCase().endsWith('.m4a'))
        ? reqFileName
        : 'recording.m4a';
      const size = buffer.length;
      if (size > 25 * 1024 * 1024) {
        return res.status(400).json({ error: "Audio file too large. Maximum size is 25MB" });
      }
      if (size < 1000) {
        return res.status(400).json({ error: "Audio file too small or corrupted. Try recording again." });
      }
      console.log('[Transcribe-base64] Received:', { size, fileName });
      const openaiClient = getOpenAI();
      // Always convert M4A/MP4 for mobile (iOS/Android) - Whisper often rejects iOS M4A with "could not be decoded"
      const isM4A = fileName.toLowerCase().endsWith('.m4a') || fileName.toLowerCase().endsWith('.mp4');
      let audioBuffer = buffer;
      let ext = 'm4a';
      let mime = 'audio/mp4';
      if (isM4A) {
        let converted = false;
        try {
          console.log('[Transcribe-base64] Converting M4A to MP3 for Whisper compatibility');
          audioBuffer = await convertToMp3(buffer, 'm4a');
          ext = 'mp3';
          mime = 'audio/mpeg';
          converted = true;
        } catch (mp3Err: any) {
          console.warn('[Transcribe-base64] MP3 conversion failed, trying WAV:', mp3Err?.message);
        }
        if (!converted) {
          try {
            console.log('[Transcribe-base64] Converting M4A to WAV (iOS fallback)');
            audioBuffer = await convertToWav(buffer, 'm4a');
            ext = 'wav';
            mime = 'audio/wav';
            converted = true;
          } catch (wavErr: any) {
            console.warn('[Transcribe-base64] WAV conversion failed:', wavErr?.message);
          }
        }
        if (!converted) {
          console.error('[Transcribe-base64] Both MP3 and WAV conversion failed for iOS M4A');
          return res.status(400).json({
            error: "The audio file could not be processed. Try recording again or use a shorter clip.",
          });
        }
      }
      const audioFile = await toFile(audioBuffer, `audio.${ext}`, { type: mime });
      const transcription = await openaiClient.audio.transcriptions.create({
        file: audioFile,
        model: "whisper-1",
        language: "en",
        response_format: "text"
      });
      const transcribedText = typeof transcription === 'string'
        ? transcription
        : (transcription as any)?.text || String(transcription || '').trim();
      if (!transcribedText || transcribedText.trim().length === 0) {
        return res.status(500).json({ error: "Transcription returned empty result" });
      }
      res.json({ text: transcribedText.trim() });
    } catch (error: any) {
      console.error("Error in audio transcription (base64):", error);
      if (error?.message?.includes('OpenAI') || error?.status === 401) {
        return res.status(500).json({ error: "OpenAI API error. Please check your API configuration." });
      }
      if (error?.status === 413 || error?.message?.includes('too large')) {
        return res.status(400).json({ error: "Audio file too large. Maximum size is 25MB" });
      }
      const msg = error?.message || "Failed to transcribe audio";
      const errLower = msg.toLowerCase();
      const isFormatError =
        errLower.includes('invalid file format') ||
        errLower.includes('unrecognized file format') ||
        errLower.includes('could not be decoded') ||
        errLower.includes('format is not supported') ||
        errLower.includes('format not supported');
      const status = isFormatError || error?.status === 400 ? 400 : 500;
      res.status(status).json({ error: isFormatError ? "The audio file could not be processed. Try recording again or use a shorter clip." : msg });
    }
  });

  // Audio transcription endpoint using OpenAI Whisper API (multipart/form-data)
  app.post("/api/audio/transcribe", isAuthenticated, upload.single('audio'), async (req: any, res: any) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: "No audio file uploaded" });
      }

      console.log('[Transcribe] Received file:', {
        mimetype: req.file.mimetype,
        originalname: req.file.originalname,
        size: req.file.size,
        encoding: req.file.encoding,
        fieldname: req.file.fieldname,
      });

      // Validate audio file type - accept both audio/m4a and audio/mp4 (they're the same format)
      const allowedMimeTypes = [
        'audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/webm', 
        'audio/ogg', 'audio/m4a', 'audio/x-m4a', 'audio/mp4',
        'audio/flac', 'audio/oga', 'audio/mpga', 'audio/mpeg',
        'application/octet-stream' // Sometimes multer detects M4A as this
      ];
      
      // Normalize MIME type for validation (accept both m4a and mp4 as they're the same)
      const normalizedMimeType = req.file.mimetype.toLowerCase();
      const isValidMimeType = allowedMimeTypes.some(type => 
        normalizedMimeType === type.toLowerCase() || 
        (normalizedMimeType === 'audio/m4a' && type === 'audio/mp4') ||
        (normalizedMimeType === 'audio/mp4' && type === 'audio/m4a') ||
        (normalizedMimeType === 'application/octet-stream' && (req.file.originalname?.toLowerCase().endsWith('.m4a') || req.file.originalname?.toLowerCase().endsWith('.mp4')))
      );
      
      if (!isValidMimeType) {
        console.error('[Transcribe] Invalid MIME type:', req.file.mimetype);
        return res.status(400).json({ 
          error: `Invalid audio format: ${req.file.mimetype}. Supported formats: MP3, WAV, WebM, OGG, M4A, MP4, FLAC` 
        });
      }

      // Check file size (max 25MB for Whisper API)
      const maxSize = 25 * 1024 * 1024; // 25MB
      if (req.file.size > maxSize) {
        return res.status(400).json({ 
          error: "Audio file too large. Maximum size is 25MB" 
        });
      }

      // Get OpenAI client
      const openaiClient = getOpenAI();

      // Map MIME types to OpenAI-compatible formats
      // OpenAI supports: flac, m4a, mp3, mp4, mpeg, mpga, oga, ogg, wav, webm
      // IMPORTANT: OpenAI checks the file extension in the filename, so .m4a files need .m4a extension
      // The MIME type can be audio/mp4 or audio/m4a for .m4a files, but extension must be .m4a
      const mimeTypeMap: Record<string, { mimeType: string; extension: string }> = {
        'audio/mpeg': { mimeType: 'audio/mpeg', extension: 'mp3' },
        'audio/mp3': { mimeType: 'audio/mpeg', extension: 'mp3' },
        'audio/mp4': { mimeType: 'audio/mp4', extension: 'm4a' }, // Use audio/mp4 MIME type with .m4a extension (OpenAI accepts this)
        'audio/m4a': { mimeType: 'audio/mp4', extension: 'm4a' },
        'audio/x-m4a': { mimeType: 'audio/mp4', extension: 'm4a' },
        'audio/wav': { mimeType: 'audio/wav', extension: 'wav' },
        'audio/x-wav': { mimeType: 'audio/wav', extension: 'wav' },
        'audio/webm': { mimeType: 'audio/webm', extension: 'webm' },
        'audio/ogg': { mimeType: 'audio/ogg', extension: 'ogg' },
        'audio/oga': { mimeType: 'audio/ogg', extension: 'oga' },
        'audio/flac': { mimeType: 'audio/flac', extension: 'flac' },
      };

      // Normalize MIME type and get proper extension
      // Handle application/octet-stream by checking filename extension
      let detectedMimeType = req.file.mimetype.toLowerCase();
      if (detectedMimeType === 'application/octet-stream' || !detectedMimeType.startsWith('audio/')) {
        const fileExt = req.file.originalname?.toLowerCase().split('.').pop() || '';
        if (fileExt === 'm4a' || fileExt === 'mp4') {
          detectedMimeType = 'audio/mp4';
        } else if (fileExt === 'mp3') {
          detectedMimeType = 'audio/mpeg';
        } else if (fileExt === 'wav') {
          detectedMimeType = 'audio/wav';
        } else if (fileExt === 'webm') {
          detectedMimeType = 'audio/webm';
        } else if (fileExt === 'ogg' || fileExt === 'oga') {
          detectedMimeType = 'audio/ogg';
        } else if (fileExt === 'flac') {
          detectedMimeType = 'audio/flac';
        }
      }
      
      const normalized = mimeTypeMap[detectedMimeType] || 
        mimeTypeMap[req.file.mimetype] || 
        { mimeType: 'audio/mp4', extension: 'm4a' }; // Default to audio/mp4 with .m4a extension for mobile recordings

      // Ensure filename has correct extension that matches what OpenAI expects
      let fileName = req.file.originalname || `audio.${normalized.extension}`;
      const currentExt = fileName.toLowerCase().split('.').pop() || '';
      
      // If current extension is not the normalized one, replace it
      if (currentExt !== normalized.extension.toLowerCase()) {
        const baseName = fileName.replace(/\.[^/.]+$/, '');
        fileName = `${baseName}.${normalized.extension}`;
      }

      console.log('[Transcribe] Normalized audio file:', {
        originalMimeType: req.file.mimetype,
        normalizedMimeType: normalized.mimeType,
        originalName: req.file.originalname,
        normalizedName: fileName,
        extension: normalized.extension,
        size: req.file.size,
        bufferLength: req.file.buffer?.length || 0,
      });

      // Use toFile() from OpenAI SDK - ensures correct File object with proper filename
      // Whisper API infers format from file extension, so filename must have correct extension
      let transcription: any;
      const tmpPath = path.join(os.tmpdir(), `whisper-${randomUUID()}.${normalized.extension}`);

      const transcribeWithFile = async (fileInput: any) => {
        return openaiClient.audio.transcriptions.create({
          file: fileInput,
          model: "whisper-1",
          language: "en",
          response_format: "text"
        });
      };

      try {
        const audioFile = await toFile(req.file.buffer, fileName, { type: normalized.mimeType });
        console.log('[Transcribe] Created File via toFile:', {
          name: audioFile.name,
          type: audioFile.type,
          size: audioFile.size,
        });
        transcription = await transcribeWithFile(audioFile);
      } catch (firstError: any) {
        const isInvalidFormat = (firstError?.message || '').toLowerCase().includes('invalid file format') ||
          (firstError?.message || '').toLowerCase().includes('unrecognized file format');
        if (isInvalidFormat) {
          // Fallback 1: temp file + stream (fixes binary issues)
          console.log('[Transcribe] Format rejected, retrying with temp file');
          await fs.writeFile(tmpPath, req.file.buffer);
          try {
            const { createReadStream } = await import('fs');
            transcription = await transcribeWithFile(createReadStream(tmpPath));
          } catch (streamErr: any) {
            const stillInvalid = (streamErr?.message || '').toLowerCase().includes('invalid file format') || (streamErr?.message || '').toLowerCase().includes('unrecognized file format');
            if (stillInvalid) {
              // Fallback 2: convert to MP3 (mobile M4A compatibility)
              console.log('[Transcribe] Still rejected, converting to MP3');
              const mp3Buffer = await convertToMp3(req.file.buffer, normalized.extension);
              const mp3File = await toFile(mp3Buffer, 'audio.mp3', { type: 'audio/mpeg' });
              transcription = await transcribeWithFile(mp3File);
            } else {
              throw streamErr;
            }
          } finally {
            await fs.unlink(tmpPath).catch(() => {});
          }
        } else {
          throw firstError;
        }
      }

      // Extract transcribed text
      // Whisper API with response_format: "text" returns a string directly
      const transcribedText = typeof transcription === 'string' 
        ? transcription 
        : (transcription as any)?.text || String(transcription || '').trim();

      if (!transcribedText || transcribedText.trim().length === 0) {
        return res.status(500).json({ 
          error: "Transcription returned empty result" 
        });
      }

      res.json({ 
        text: transcribedText.trim() 
      });
    } catch (error: any) {
      console.error("Error in audio transcription:", error);
      
      // Handle specific OpenAI errors
      if (error?.message?.includes('OpenAI') || error?.status === 401) {
        return res.status(500).json({ 
          error: "OpenAI API error. Please check your API configuration." 
        });
      }
      
      if (error?.status === 413 || error?.message?.includes('too large')) {
        return res.status(400).json({ 
          error: "Audio file too large. Maximum size is 25MB" 
        });
      }

      // User-friendly message for common Whisper API format errors
      const msg = error?.message || "Failed to transcribe audio";
      const isFormatError = msg.toLowerCase().includes('invalid file format') ||
        msg.toLowerCase().includes('unrecognized file format');
      const userMessage = isFormatError
        ? "Invalid audio format. Please ensure the recording is in a supported format (M4A, MP3, WAV). Try recording again."
        : msg;

      res.status(500).json({ 
        error: userMessage 
      });
    }
  });

  // Handle PUT requests (for Uppy AwsS3 plugin - raw body, not multer)
  // IMPORTANT: This endpoint must ALWAYS return JSON on errors to prevent HTML parsing errors in Uppy
  app.put("/api/objects/upload-direct", async (req: any, res: any) => {
    console.log('[upload-direct] PUT request received:', {
      method: req.method,
      url: req.url,
      path: req.path,
      authenticated: req.isAuthenticated(),
      hasBody: !!req.body,
      contentType: req.headers['content-type'],
    });

    // Set JSON content type IMMEDIATELY to prevent any HTML responses
    res.set('Content-Type', 'application/json');

    // Check authentication first and return JSON if not authenticated
    if (!req.isAuthenticated()) {
      console.error('[upload-direct] Unauthenticated PUT request');
      return res.status(401).json({ error: "Unauthorized" });
    }

    // Set content type early to prevent HTML responses
    // For successful uploads, return empty body (S3-compatible)
    // For errors, return JSON

    let responseSent = false;
    const sendError = (status: number, message: string) => {
      if (!responseSent) {
        responseSent = true;
        res.set('Content-Type', 'application/json');
        console.error(`[upload-direct] Error ${status}: ${message}`);
        res.status(status).json({ error: message });
      }
    };

    try {
      const objectId = req.query.objectId || randomUUID();
      const objectStorageService = new ObjectStorageService();

      // For PUT requests, read raw body
      const chunks: Buffer[] = [];

      req.on('data', (chunk: Buffer) => {
        chunks.push(chunk);
      });

      req.on('end', async () => {
        try {
          const fileBuffer = Buffer.concat(chunks);

          if (fileBuffer.length === 0) {
            return sendError(400, "No file uploaded");
          }

          // Get content type from headers
          const contentType = req.headers['content-type'] || 'application/octet-stream';

          const normalizedPath = await objectStorageService.saveUploadedFile(
            objectId as string,
            fileBuffer,
            contentType
          );

          // Generate ETag for S3 compatibility (Uppy AwsS3 plugin requires this)
          const etag = createHash('md5').update(fileBuffer).digest('hex');

          // Set ETag header for S3 compatibility (required by Uppy)
          res.set('ETag', `"${etag}"`);
          // Also set CORS headers to allow reading ETag
          res.set('Access-Control-Expose-Headers', 'ETag');

          // Set ACL to public
          const userId = req.user?.claims?.sub || req.user?.id;
          if (userId) {
            try {
              await objectStorageService.trySetObjectEntityAclPolicy(normalizedPath, {
                owner: userId,
                visibility: "public",
              });
            } catch (error) {
              console.warn("Failed to set ACL:", error);
              // Don't fail the upload if ACL setting fails
            }
          }

          if (!responseSent) {
            responseSent = true;
            // Uppy AwsS3 plugin expects S3-compatible response
            // Return empty body with just ETag header (S3 standard)
            // The extractFileUrlFromUploadResponse utility will use the upload URL from metadata
            // Remove Content-Type header for empty body (S3 doesn't send it)
            res.removeHeader('Content-Type');
            res.status(200).end();
          }
        } catch (error: any) {
          console.error("Error in upload-direct PUT (end handler):", error);
          sendError(500, error.message || "Internal server error");
        }
      });

      req.on('error', (error: any) => {
        console.error("Error reading request body in upload-direct PUT:", error);
        sendError(500, "Error reading file data");
      });

      // Set timeout to prevent hanging requests
      req.setTimeout(300000, () => { // 5 minutes
        if (!responseSent) {
          sendError(408, "Request timeout");
        }
      });
    } catch (error: any) {
      console.error("Error in upload-direct PUT (outer catch):", error);
      sendError(500, error.message || "Internal server error");
    }
  });

  // Set ACL endpoint - must be BEFORE the catch-all route
  app.put("/api/objects/set-acl", isAuthenticated, async (req: any, res) => {
    if (!req.body.photoUrl) {
      return res.status(400).json({ error: "photoUrl is required" });
    }

    const userId = req.user?.claims?.sub;

    try {
      const objectStorageService = new ObjectStorageService();
      const objectPath = await objectStorageService.trySetObjectEntityAclPolicy(
        req.body.photoUrl,
        {
          owner: userId,
          visibility: "public",
        },
      );

      res.status(200).json({ objectPath });
    } catch (error: any) {
      safeErrorLog("Error setting object ACL:", error);
      const errorMessage = error?.message || "Internal server error";
      res.status(500).json({ error: errorMessage });
    }
  });

  // Catch-all for any other PUT requests to /api/objects/* that don't match
  // This ensures we return JSON instead of HTML if the route doesn't match
  app.put("/api/objects/*", (req: any, res: any) => {
    console.error('[upload-direct] PUT request to unmatched route:', req.path);
    res.set('Content-Type', 'application/json');
    res.status(404).json({ error: "Upload endpoint not found" });
  });

  // Audio upload via base64 (avoids FormData binary corruption on mobile - fixes silent playback on web)
  app.post("/api/objects/upload-audio-base64", isAuthenticated, async (req: any, res) => {
    res.set('Content-Type', 'application/json');
    try {
      const { fileBase64, fileName = 'voice-note.m4a', mimeType = 'audio/mp4' } = req.body || {};
      if (!fileBase64 || typeof fileBase64 !== 'string') {
        return res.status(400).json({ error: "Missing fileBase64 in request body" });
      }
      const buffer = Buffer.from(fileBase64, 'base64');
      if (buffer.length > 25 * 1024 * 1024) {
        return res.status(400).json({ error: "Audio file too large. Maximum 25MB" });
      }
      const objectId = (req.query.objectId as string) || randomUUID();
      const objectStorageService = new ObjectStorageService();
      const normalizedPath = await objectStorageService.saveUploadedFile(objectId, buffer, mimeType);
      const userId = req.user?.claims?.sub || req.user?.id;
      if (userId) {
        try {
          await objectStorageService.trySetObjectEntityAclPolicy(normalizedPath, {
            owner: userId,
            visibility: "public",
          });
        } catch (e) {
          console.warn("Failed to set ACL for audio upload:", e);
        }
      }
      res.json({ url: normalizedPath, path: normalizedPath, objectId });
    } catch (error: any) {
      console.error("Error in upload-audio-base64:", error);
      res.status(500).json({ error: error.message || "Failed to upload audio" });
    }
  });

  // File upload endpoint using multer
  app.post("/api/objects/upload-file", isAuthenticated, upload.single('file'), async (req: any, res) => {
    // Always set JSON content type to prevent HTML responses
    res.set('Content-Type', 'application/json');

    try {
      const objectId = req.query.objectId || randomUUID();
      const objectStorageService = new ObjectStorageService();

      if (!req.file) {
        return res.status(400).json({ error: "No file uploaded" });
      }

      const normalizedPath = await objectStorageService.saveUploadedFile(
        objectId as string,
        req.file.buffer,
        req.file.mimetype
      );

      // Set ACL to public by default
      const userId = req.user?.claims?.sub || req.user?.id;
      if (userId) {
        try {
          await objectStorageService.trySetObjectEntityAclPolicy(normalizedPath, {
            owner: userId,
            visibility: "public",
          });
        } catch (error) {
          console.warn("Failed to set ACL for uploaded file:", error);
        }
      }

      res.json({
        url: normalizedPath,
        path: normalizedPath,
        objectId: objectId
      });
    } catch (error: any) {
      console.error("Error uploading file:", error);
      // Ensure we always return JSON, even on errors
      res.set('Content-Type', 'application/json');
      res.status(500).json({ error: error.message || "Failed to upload file" });
    }
  });

  // Alternative endpoint for S3-compatible clients (like Uppy)
  app.post("/api/object-storage/upload", isAuthenticated, upload.single('file'), async (req: any, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: "No file uploaded" });
      }

      const objectId = randomUUID();
      const objectStorageService = new ObjectStorageService();

      const normalizedPath = await objectStorageService.saveUploadedFile(
        objectId,
        req.file.buffer,
        req.file.mimetype
      );

      // Set ACL to public
      const userId = req.user?.claims?.sub || req.user?.id;
      if (userId) {
        try {
          await objectStorageService.trySetObjectEntityAclPolicy(normalizedPath, {
            owner: userId,
            visibility: "public",
          });
        } catch (error) {
          console.warn("Failed to set ACL:", error);
        }
      }

      // Return S3-compatible response
      res.json({
        url: normalizedPath,
        key: normalizedPath,
        bucket: "local",
      });
    } catch (error) {
      console.error("Error in S3-compatible upload:", error);
      res.status(500).json({ error: "Failed to upload file" });
    }
  });

  app.post("/api/objects/normalize", isAuthenticated, async (req, res) => {
    const { photoUrl } = req.body;
    if (!photoUrl) {
      return res.status(400).json({ error: "photoUrl is required" });
    }
    const objectStorageService = new ObjectStorageService();
    const normalizedPath = objectStorageService.normalizeObjectEntityPath(photoUrl);
    res.json({ normalizedPath });
  });

  // Fix existing photos - make them public
  app.post("/api/objects/fix-acls", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      const objectStorageService = new ObjectStorageService();

      // Get all assets with photos
      const assets = await storage.getAssetInventoryByOrganization(user.organizationId);
      const photosToFix: string[] = [];

      for (const asset of assets) {
        if (asset.photos && asset.photos.length > 0) {
          photosToFix.push(...asset.photos);
        }
      }

      // Get all inspection entries with photos
      const inspections = await storage.getInspectionsByOrganization(user.organizationId);
      for (const inspection of inspections) {
        const entries = await storage.getInspectionEntries(inspection.id);
        for (const entry of entries) {
          if (entry.photos && entry.photos.length > 0) {
            photosToFix.push(...entry.photos);
          }
        }
      }

      // Update ACL for each photo
      const fixed: string[] = [];
      const errors: string[] = [];

      for (const photoPath of photosToFix) {
        try {
          await objectStorageService.trySetObjectEntityAclPolicy(
            photoPath,
            {
              owner: userId,
              visibility: "public",
            },
          );
          fixed.push(photoPath);
        } catch (error) {
          console.error(`Failed to fix ACL for ${photoPath}:`, error);
          errors.push(photoPath);
        }
      }

      res.json({
        message: `Fixed ${fixed.length} photos (assets + inspections), ${errors.length} errors`,
        fixed: fixed.length,
        errors: errors.length
      });
    } catch (error) {
      console.error("Error fixing ACLs:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Backfill route: Sync photos from valueJson to photos column for all inspection entries
  app.post("/api/objects/sync-entry-photos", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ error: "No organization found" });
      }

      // Get all inspections for the organization
      const inspections = await storage.getInspectionsByOrganization(user.organizationId);
      let syncedCount = 0;
      let errorCount = 0;

      for (const inspection of inspections) {
        const entries = await storage.getInspectionEntries(inspection.id);
        for (const entry of entries) {
          try {
            // Extract photos from valueJson
            let extractedPhotos: string[] | null = null;
            const valueJson = entry.valueJson as any;

            if (valueJson && typeof valueJson === 'object') {
              if (Array.isArray(valueJson.photos)) {
                extractedPhotos = valueJson.photos;
              } else if (typeof valueJson.photo === 'string' && valueJson.photo) {
                extractedPhotos = [valueJson.photo];
              } else if (Array.isArray(valueJson)) {
                const isAllStrings = valueJson.every((item: any) => typeof item === 'string');
                if (isAllStrings && valueJson.length > 0) {
                  extractedPhotos = valueJson;
                }
              }
            }

            // Check if photos column needs updating
            const currentPhotos = entry.photos || [];
            const newPhotos = extractedPhotos || [];

            // Only update if there's a difference
            const photosMatch = currentPhotos.length === newPhotos.length &&
              currentPhotos.every((p, i) => p === newPhotos[i]);

            if (!photosMatch && extractedPhotos !== null) {
              await storage.updateInspectionEntry(entry.id, {
                photos: extractedPhotos.length > 0 ? extractedPhotos : null
              } as any);
              syncedCount++;
              console.log(`[Sync Entry Photos] Updated entry ${entry.id}: ${currentPhotos.length} -> ${newPhotos.length} photos`);
            }
          } catch (error) {
            console.error(`Error syncing photos for entry ${entry.id}:`, error);
            errorCount++;
          }
        }
      }

      res.json({
        message: `Synced photos for ${syncedCount} entries, ${errorCount} errors`,
        synced: syncedCount,
        errors: errorCount
      });
    } catch (error) {
      console.error("Error syncing entry photos:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // ==================== ADMIN ROUTES ====================

  // Admin authentication middleware
  const isAdminAuthenticated = (req: any, res: any, next: any) => {
    if (req.session && (req.session as any).adminUser) {
      return next();
    }
    return res.status(401).json({ message: "Unauthorized - Admin access required" });
  };

  // Admin Login
  app.post("/api/admin/login", async (req, res) => {
    try {
      const { email, password } = req.body;

      if (!email || !password) {
        return res.status(400).json({ message: "Email and password are required" });
      }

      // Normalize email to lowercase for case-insensitive matching
      const normalizedEmail = email.toLowerCase().trim();

      const adminUser = await storage.getAdminByEmail(normalizedEmail);

      if (!adminUser) {
        console.error(`[Admin Login] Admin user not found for email: ${normalizedEmail}`);
        return res.status(401).json({ message: "Invalid credentials" });
      }

      // Log for debugging (remove in production)
      console.log(`[Admin Login] Retrieved password hash length: ${adminUser.password.length}, starts with: ${adminUser.password.substring(0, 10)}`);
      console.log(`[Admin Login] Password hash format: ${adminUser.password.startsWith("$2") ? "bcrypt" : adminUser.password.includes(".") ? "scrypt" : "unknown"}`);

      // Use comparePasswords which supports both scrypt (from hashPassword) and bcrypt formats
      const isValidPassword = await comparePasswords(password, adminUser.password);

      if (!isValidPassword) {
        console.error(`[Admin Login] Invalid password for admin: ${normalizedEmail}`);
        return res.status(401).json({ message: "Invalid credentials" });
      }

      console.log(`[Admin Login] Successful login for admin: ${normalizedEmail}`);

      // Set admin session
      (req.session as any).adminUser = {
        id: adminUser.id,
        email: adminUser.email,
        firstName: adminUser.firstName,
        lastName: adminUser.lastName,
      };

      // Explicitly save the session before responding
      await new Promise<void>((resolve, reject) => {
        req.session.save((err) => {
          if (err) {
            console.error("[Admin Login] Error saving session:", err);
            reject(err);
          } else {
            resolve();
          }
        });
      });

      res.json({
        id: adminUser.id,
        email: adminUser.email,
        firstName: adminUser.firstName,
        lastName: adminUser.lastName,
      });
    } catch (error) {
      console.error("Admin login error:", error);
      res.status(500).json({ message: "Login failed" });
    }
  });

  // Admin Logout
  app.post("/api/admin/logout", async (req, res) => {
    try {
      // Clear admin session
      (req.session as any).adminUser = null;
      
      // Explicitly save the session to persist the logout
      await new Promise<void>((resolve, reject) => {
        req.session.save((err) => {
          if (err) {
            console.error("[Admin Logout] Error saving session:", err);
            reject(err);
          } else {
            resolve();
          }
        });
      });

      // Optionally destroy the session completely
      await new Promise<void>((resolve, reject) => {
        req.session.destroy((err) => {
          if (err) {
            console.error("[Admin Logout] Error destroying session:", err);
            // Don't reject - session might already be destroyed
            resolve();
          } else {
            resolve();
          }
        });
      });

      res.json({ message: "Logged out successfully" });
    } catch (error) {
      console.error("Admin logout error:", error);
      res.status(500).json({ message: "Logout failed" });
    }
  });

  // Get current admin user
  app.get("/api/admin/me", isAdminAuthenticated, (req: any, res) => {
    res.json(req.session.adminUser);
  });

  // ==================== ADMIN INSTANCE MANAGEMENT ====================

  // Get all instances (organizations) with owner details
  app.get("/api/admin/instances", isAdminAuthenticated, async (req, res) => {
    try {
      const orgs = await storage.getAllOrganizationsWithOwners();

      // Enrich with instance subscription data and credit balance from batch system
      const instances = await Promise.all(orgs.map(async (org) => {
        const subscription = await storage.getInstanceSubscription(org.id);
        const tiers = await storage.getSubscriptionTiers();
        const tier = subscription?.currentTierId ? tiers.find(t => t.id === subscription.currentTierId) : null;

        // Get credit balance from batch system (not legacy creditsRemaining)
        const creditBalance = await storage.getCreditBalance(org.id);

        return {
          ...org,
          subscription,
          tierName: tier?.name || null,
          tierCode: tier?.code || null,
          creditBalance: {
            total: creditBalance.total,
            current: creditBalance.current,
            rolled: creditBalance.rolled,
            expiresOn: creditBalance.expiresOn,
          },
        };
      }));

      res.json(instances);
    } catch (error) {
      console.error("Error fetching instances:", error);
      res.status(500).json({ message: "Failed to fetch instances" });
    }
  });

  // Get single instance details
  app.get("/api/admin/instances/:id", isAdminAuthenticated, async (req, res) => {
    try {
      const instance = await storage.getOrganizationWithOwner(req.params.id);
      if (!instance) {
        return res.status(404).json({ message: "Instance not found" });
      }
      res.json(instance);
    } catch (error) {
      console.error("Error fetching instance:", error);
      res.status(500).json({ message: "Failed to fetch instance" });
    }
  });

  // Update instance (tier, credits, active status, modules)
  app.patch("/api/admin/instances/:id", isAdminAuthenticated, async (req, res) => {
    try {
      const { tierId, credits, isActive, enabledModules, preferredCurrency } = req.body; // Changed from creditsRemaining to credits

      // Get organization to get currency
      const org = await storage.getOrganization(req.params.id);
      if (!org) {
        return res.status(404).json({ message: "Organization not found" });
      }

      // IMPORTANT: Prevent currency changes if there's an active subscription
      // Currency changes mid-subscription can cause billing inconsistencies
      if (preferredCurrency && preferredCurrency !== org.preferredCurrency) {
        // Check if organization has an active subscription
        const instanceSub = await storage.getInstanceSubscription(req.params.id);
        const legacySub = await storage.getSubscriptionByOrganization(req.params.id);
        
        const hasActiveSubscription = 
          (instanceSub && instanceSub.subscriptionStatus === "active") ||
          (legacySub && legacySub.stripeSubscriptionId);
        
        if (hasActiveSubscription) {
          return res.status(400).json({ 
            message: "Cannot change currency while an active subscription exists. Please cancel the subscription first or wait until it expires.",
            error: "CURRENCY_CHANGE_BLOCKED"
          });
        }
      }

      // If credits is being updated, grant credits via the credit batch system
      // This ensures the credits show up on the operator's billing page
      if (credits !== undefined && credits !== null) {
        // Get current credit balance from batches (this is what the operator sees)
        const currentBalance = await storage.getCreditBalance(req.params.id);
        const currentBalanceTotal = currentBalance.total;
        
        // Calculate how many credits to grant/revoke
        // Target balance should match credits
        const creditsToAdjust = credits - currentBalanceTotal;
        
        if (creditsToAdjust > 0) {
          // Grant credits using the subscription service
          const { subscriptionService } = await import("./subscriptionService");
          await subscriptionService.grantCredits(
            req.params.id,
            creditsToAdjust,
            "admin_grant",
            undefined, // No expiration
            {
              adminNotes: `Admin adjustment: Updated from ${currentBalanceTotal} to ${credits} credits`,
              createdBy: (req.session as any).adminUser?.id || "admin",
            }
          );
          console.log(`[Admin] Granted ${creditsToAdjust} credits to org ${req.params.id} (new total: ${credits})`);
        } else if (creditsToAdjust < 0) {
          // For reducing credits, try to consume them
          const { subscriptionService } = await import("./subscriptionService");
          const creditsToConsume = Math.abs(creditsToAdjust);
          try {
            await subscriptionService.consumeInspectionCredits(req.params.id, creditsToConsume, "admin_adjustment");
            console.log(`[Admin] Consumed ${creditsToConsume} credits from org ${req.params.id} (new total: ${credits})`);
          } catch (consumeError: any) {
            // If consumption fails (not enough credits), log warning but continue
            console.warn(`[Admin] Could not consume ${creditsToConsume} credits (current: ${currentBalanceTotal}, target: ${credits}): ${consumeError.message}`);
          }
        }
      }

      // Update organization status
      const updated = await storage.updateOrganization(req.params.id, {
        isActive,
      });

      // Update instance subscription tier if provided
      if (tierId) {
        const subscription = await storage.getInstanceSubscription(req.params.id);
        const tiers = await storage.getSubscriptionTiers();
        const selectedTier = tiers.find(t => t.id === tierId);
        
        if (subscription) {
          // Update existing subscription
          await storage.updateInstanceSubscription(subscription.id, {
            currentTierId: tierId,
            // Update inspection quota to match tier's included inspections
            inspectionQuotaIncluded: selectedTier?.includedInspections || subscription.inspectionQuotaIncluded,
          });
        } else {
          // Create new instance subscription if it doesn't exist
          await storage.createInstanceSubscription({
            organizationId: req.params.id,
            registrationCurrency: org.preferredCurrency || 'GBP',
            currentTierId: tierId,
            inspectionQuotaIncluded: selectedTier?.includedInspections || 0,
            billingCycle: 'monthly',
            subscriptionStatus: 'active',
          });
        }
        
        // Invalidate queries to refresh operator-side data
        // This ensures changes reflect immediately on the operator's billing page
        console.log(`[Admin] Updated instance ${req.params.id}: tier=${tierId}${credits !== undefined ? `, credits=${credits}` : ''}`);
      }

      // Update modules if provided
      if (enabledModules !== undefined && Array.isArray(enabledModules)) {
        const subscription = await storage.getInstanceSubscription(req.params.id);
        if (subscription) {
          // Get all available modules
          const allModules = await storage.getMarketplaceModules();
          const allModuleIds = allModules.map(m => m.id);
          
          // Get current instance modules
          const currentInstanceModules = await storage.getInstanceModules(subscription.id);
          const currentEnabledModuleIds = currentInstanceModules
            .filter(im => im.isEnabled)
            .map(im => im.moduleId);
          
          // Determine which modules to enable and disable
          const modulesToEnable = enabledModules.filter((moduleId: string) => 
            !currentEnabledModuleIds.includes(moduleId) && allModuleIds.includes(moduleId)
          );
          const modulesToDisable = currentEnabledModuleIds.filter((moduleId: string) => 
            !enabledModules.includes(moduleId)
          );
          
          // Enable new modules
          for (const moduleId of modulesToEnable) {
            await storage.toggleInstanceModule(subscription.id, moduleId, true);
            console.log(`[Admin] Enabled module ${moduleId} for instance ${req.params.id}`);
          }
          
          // Disable removed modules
          for (const moduleId of modulesToDisable) {
            await storage.toggleInstanceModule(subscription.id, moduleId, false);
            console.log(`[Admin] Disabled module ${moduleId} for instance ${req.params.id}`);
          }
          
          console.log(`[Admin] Updated modules for instance ${req.params.id}: enabled=${modulesToEnable.length}, disabled=${modulesToDisable.length}`);
        }
      }

      res.json(updated);
    } catch (error) {
      console.error("Error updating instance:", error);
      res.status(500).json({ message: "Failed to update instance" });
    }
  });

  // Disable/Enable instance
  app.post("/api/admin/instances/:id/toggle-status", isAdminAuthenticated, async (req, res) => {
    try {
      const org = await storage.getOrganization(req.params.id);
      if (!org) {
        return res.status(404).json({ message: "Instance not found" });
      }

      const wasActive = org.isActive !== false;
      const newStatus = !wasActive;

      // Update organization status
      const updated = await storage.updateOrganization(req.params.id, {
        isActive: newStatus,
      });

      // If disabling organization, invalidate all user sessions
      if (!newStatus && wasActive) {
        try {
          // Get all users in this organization
          const orgUsers = await storage.getUsersByOrganization(req.params.id);
          const userIds = orgUsers.map(u => u.id);
          
          console.log(`[Toggle Status] Organization ${req.params.id} disabled. ${userIds.length} users will be logged out on next request.`);
          
          // Destroy all sessions for users in this organization
          // Query the sessions table directly to find and destroy sessions
          const { db } = await import("./db");
          const { sql } = await import("drizzle-orm");
          
          if (userIds.length > 0) {
            // Get session store to destroy sessions
            const { getSessionStore } = await import("./auth");
            const sessionStore = getSessionStore();
            
            // Query all sessions from the sessions table
            // connect-pg-simple stores sessions as JSON in the 'sess' column
            // The user ID is stored in sess.passport.user
            try {
              // Use the existing database pool
              const { pool } = await import("./db");
              
              const sessionsResult = await pool.query(`
                SELECT sid, sess 
                FROM sessions 
                WHERE sess::text LIKE '%"passport"%'
              `);
              
              let destroyedCount = 0;
              for (const sessionRow of sessionsResult.rows) {
                try {
                  // Parse the session data (sess is stored as JSON text)
                  let sessionData: any;
                  if (typeof sessionRow.sess === 'string') {
                    sessionData = JSON.parse(sessionRow.sess);
                  } else {
                    sessionData = sessionRow.sess;
                  }
                  
                  // Check if this session belongs to one of our users
                  if (sessionData?.passport?.user && userIds.includes(sessionData.passport.user)) {
                    // Destroy this session
                    await new Promise<void>((resolve, reject) => {
                      sessionStore.destroy(sessionRow.sid as string, (err) => {
                        if (err) {
                          console.error(`[Toggle Status] Error destroying session ${sessionRow.sid}:`, err);
                          reject(err);
                        } else {
                          destroyedCount++;
                          resolve();
                        }
                      });
                    });
                  }
                } catch (parseError) {
                  console.error(`[Toggle Status] Error parsing session ${sessionRow.sid}:`, parseError);
                  // Continue with next session
                }
              }
              
              console.log(`[Toggle Status] Destroyed ${destroyedCount} sessions for organization ${req.params.id}`);
            } catch (sessionsQueryError) {
              console.error("[Toggle Status] Error querying sessions:", sessionsQueryError);
              // Continue - auth checks will handle it on next request
            }
          }
          
          // Note: Even if session destruction fails, authentication checks in isAuthenticated 
          // middleware will block access on the next request and log users out
        } catch (sessionError) {
          console.error("[Toggle Status] Error invalidating sessions:", sessionError);
          // Continue even if session invalidation fails - auth checks will handle it
        }
      }

      res.json(updated);
    } catch (error) {
      console.error("Error toggling instance status:", error);
      res.status(500).json({ message: "Failed to toggle status" });
    }
  });

  // Get users for an organization (admin only)
  app.get("/api/admin/instances/:id/users", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const users = await storage.getUsersByOrganization(id);
      // Remove password from response
      const sanitizedUsers = users.map(({ password, resetToken, resetTokenExpiry, ...user }) => ({
        ...user,
        // Include additional computed fields
        fullName: `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.email,
      }));
      res.json(sanitizedUsers);
    } catch (error) {
      console.error("Error fetching organization users:", error);
      res.status(500).json({ message: "Failed to fetch organization users" });
    }
  });

  // ==================== ADMIN TEAM MANAGEMENT ====================

  // Get all admin users
  app.get("/api/admin/team", isAdminAuthenticated, async (req, res) => {
    try {
      const admins = await storage.getAllAdmins();
      // Remove password from response
      const sanitizedAdmins = admins.map(({ password, ...admin }) => admin);
      res.json(sanitizedAdmins);
    } catch (error) {
      console.error("Error fetching admin team:", error);
      res.status(500).json({ message: "Failed to fetch admin team" });
    }
  });

  // Create admin user
  app.post("/api/admin/team", isAdminAuthenticated, async (req, res) => {
    try {
      const { email, password, firstName, lastName } = req.body;

      if (!email || !password || !firstName || !lastName) {
        return res.status(400).json({ message: "All fields are required" });
      }

      const hashedPassword = await bcrypt.hash(password, 10);
      
      // Log for debugging (remove in production)
      console.log(`[Create Admin] Password hash length: ${hashedPassword.length}, starts with: ${hashedPassword.substring(0, 10)}`);

      const admin = await storage.createAdmin({
        email,
        password: hashedPassword,
        firstName,
        lastName,
      });
      
      // Verify the stored password
      const storedAdmin = await storage.getAdminByEmail(email);
      if (storedAdmin) {
        console.log(`[Create Admin] Stored password hash length: ${storedAdmin.password.length}, starts with: ${storedAdmin.password.substring(0, 10)}`);
        if (storedAdmin.password.length !== hashedPassword.length) {
          console.error(`[Create Admin] WARNING: Password hash was truncated! Original: ${hashedPassword.length} chars, Stored: ${storedAdmin.password.length} chars`);
        }
      }

      // Remove password from response
      const { password: _, ...sanitizedAdmin } = admin;
      res.json(sanitizedAdmin);
    } catch (error: any) {
      console.error("Error creating admin:", error);
      if (error.message?.includes("duplicate") || error.code === "23505") {
        return res.status(400).json({ message: "Email already exists" });
      }
      res.status(500).json({ message: "Failed to create admin" });
    }
  });

  // Update admin user
  app.patch("/api/admin/team/:id", isAdminAuthenticated, async (req, res) => {
    try {
      const { email, firstName, lastName, password } = req.body;
      const updateData: any = { email, firstName, lastName };

      if (password) {
        updateData.password = await bcrypt.hash(password, 10);
      }

      const admin = await storage.updateAdmin(req.params.id, updateData);
      const { password: _, ...sanitizedAdmin } = admin;
      res.json(sanitizedAdmin);
    } catch (error) {
      console.error("Error updating admin:", error);
      res.status(500).json({ message: "Failed to update admin" });
    }
  });

  // Delete admin user
  app.delete("/api/admin/team/:id", isAdminAuthenticated, async (req: any, res) => {
    try {
      // Prevent self-deletion
      if (req.params.id === req.session.adminUser.id) {
        return res.status(400).json({ message: "Cannot delete your own account" });
      }

      await storage.deleteAdmin(req.params.id);
      res.json({ message: "Admin deleted successfully" });
    } catch (error) {
      console.error("Error deleting admin:", error);
      res.status(500).json({ message: "Failed to delete admin" });
    }
  });

  // Reset admin password (utility endpoint for fixing password issues)
  app.post("/api/admin/team/:id/reset-password", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { password } = req.body;
      const adminId = req.params.id;

      if (!password) {
        return res.status(400).json({ message: "Password is required" });
      }

      const hashedPassword = await bcrypt.hash(password, 10);
      console.log(`[Reset Admin Password] Hash length: ${hashedPassword.length}, starts with: ${hashedPassword.substring(0, 10)}`);

      const updatedAdmin = await storage.updateAdmin(adminId, { password: hashedPassword });
      
      // Verify the stored password
      const storedAdmin = await storage.getAdminByEmail(updatedAdmin.email);
      if (storedAdmin) {
        console.log(`[Reset Admin Password] Stored hash length: ${storedAdmin.password.length}, starts with: ${storedAdmin.password.substring(0, 10)}`);
        if (storedAdmin.password.length !== hashedPassword.length) {
          console.error(`[Reset Admin Password] WARNING: Password hash was truncated! Original: ${hashedPassword.length} chars, Stored: ${storedAdmin.password.length} chars`);
        }
      }

      const { password: _, ...sanitizedAdmin } = updatedAdmin;
      res.json({ message: "Password reset successfully", admin: sanitizedAdmin });
    } catch (error: any) {
      console.error("Error resetting admin password:", error);
      res.status(500).json({ message: "Failed to reset password" });
    }
  });

  // ==================== ADMIN QUOTATION MANAGEMENT ====================

  // Get all quotation requests with filters
  app.get("/api/admin/quotations", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { status, assignedAdminId, search } = req.query;
      const requests = await storage.getQuotationRequests({
        status: status || undefined,
        assignedAdminId: assignedAdminId || undefined,
        search: search || undefined,
      });

      // Enrich with organization details
      const enriched = await Promise.all(requests.map(async (req) => {
        const org = await storage.getOrganization(req.organizationId);
        const quotation = await storage.getQuotationByRequest(req.id);
        const assignedAdmin = req.assignedAdminId ? await storage.getAdmin(req.assignedAdminId) : null;
        
        return {
          ...req,
          organization: org ? {
            name: org.name,
            countryCode: org.countryCode,
            createdAt: org.createdAt,
          } : null,
          quotation,
          assignedAdmin: assignedAdmin ? {
            id: assignedAdmin.id,
            firstName: assignedAdmin.firstName,
            lastName: assignedAdmin.lastName,
            email: assignedAdmin.email,
          } : null,
        };
      }));

      res.json(enriched);
    } catch (error: any) {
      console.error("Error fetching quotations:", error);
      res.status(500).json({ message: "Failed to fetch quotations", error: error.message });
    }
  });

  // Get quotation statistics
  app.get("/api/admin/quotations/stats", isAdminAuthenticated, async (req: any, res) => {
    try {
      const stats = await storage.getQuotationRequestStats();
      res.json(stats);
    } catch (error: any) {
      console.error("Error fetching quotation stats:", error);
      res.status(500).json({ message: "Failed to fetch stats", error: error.message });
    }
  });

  // Get single quotation request with full details
  app.get("/api/admin/quotations/:id", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const request = await storage.getQuotationRequest(id);
      
      if (!request) {
        return res.status(404).json({ message: "Quotation request not found" });
      }

      const org = await storage.getOrganization(request.organizationId);
      const quotation = await storage.getQuotationByRequest(id);
      const activityLog = await storage.getQuotationActivityLog(id);
      const assignedAdmin = request.assignedAdminId ? await storage.getAdmin(request.assignedAdminId) : null;
      
      // Get organization owner/contact
      const owner = org ? await storage.getUser(org.ownerId) : null;
      
      // Get instance subscription for usage stats
      const instanceSub = org ? await storage.getInstanceSubscription(org.id) : null;
      
      // Get subscription history (if any)
      const subscription = org ? await storage.getSubscriptionByOrganization(org.id) : null;

      res.json({
        request,
        organization: org ? {
          id: org.id,
          name: org.name,
          countryCode: org.countryCode,
          createdAt: org.createdAt,
          owner: owner ? {
            id: owner.id,
            firstName: owner.firstName,
            lastName: owner.lastName,
            email: owner.email,
            phone: owner.phone,
          } : null,
          instanceSubscription: instanceSub ? {
            currentTierId: instanceSub.currentTierId,
            billingCycle: instanceSub.billingCycle,
            subscriptionStatus: instanceSub.subscriptionStatus,
          } : null,
          subscription: subscription ? {
            id: subscription.id,
            status: subscription.status,
            billingInterval: subscription.billingInterval,
            currentPeriodStart: subscription.currentPeriodStart,
            currentPeriodEnd: subscription.currentPeriodEnd,
          } : null,
        } : null,
        quotation,
        assignedAdmin: assignedAdmin ? {
          id: assignedAdmin.id,
          firstName: assignedAdmin.firstName,
          lastName: assignedAdmin.lastName,
          email: assignedAdmin.email,
        } : null,
        activityLog,
      });
    } catch (error: any) {
      console.error("Error fetching quotation details:", error);
      res.status(500).json({ message: "Failed to fetch quotation details", error: error.message });
    }
  });

  // Create or update quote for a request
  app.post("/api/admin/quotations/:id/quote", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { quotedPrice, quotedInspections, billingPeriod, adminNotes, customerNotes } = req.body;
      const adminId = req.session.adminUser.id;

      const request = await storage.getQuotationRequest(id);
      if (!request) {
        return res.status(404).json({ message: "Quotation request not found" });
      }

      // Check if quote already exists
      let quotation = await storage.getQuotationByRequest(id);
      const isUpdate = !!quotation;
      
      if (quotation) {
        // Update existing quote
        quotation = await storage.updateQuotation(quotation.id, {
          quotedPrice: Number(quotedPrice),
          quotedInspections: Number(quotedInspections),
          billingPeriod: billingPeriod || request.preferredBillingPeriod,
          adminNotes: adminNotes || null,
          customerNotes: customerNotes || null,
          status: "sent",
        });
      } else {
        // Create new quote
        quotation = await storage.createQuotation({
          quotationRequestId: id,
          quotedPrice: Number(quotedPrice),
          quotedInspections: Number(quotedInspections),
          billingPeriod: billingPeriod || request.preferredBillingPeriod,
          currency: request.currency,
          adminNotes: adminNotes || null,
          customerNotes: customerNotes || null,
          createdBy: adminId,
          status: "sent",
        });
      }

      // Update request status
      await storage.updateQuotationRequest(id, { status: "quoted" });

      // Log activity
      await storage.createQuotationActivityLog({
        quotationRequestId: id,
        action: isUpdate ? "quoted" : "quoted", // Could differentiate "quote_updated" if needed
        performedBy: adminId,
        performedByType: "admin",
        details: { quotationId: quotation.id, quotedPrice, quotedInspections, isUpdate },
      });

      // Send email to customer
      try {
        const org = await storage.getOrganization(request.organizationId);
        const owner = org ? await storage.getUser(org.ownerId) : null;
        
        if (org && owner) {
          if (isUpdate) {
            // Send update email if quote was updated
            const { sendQuotationUpdatedEmail } = await import("./resend");
            await sendQuotationUpdatedEmail(
              owner.email,
              owner.firstName || "Customer",
              {
                requestId: request.id,
                organizationName: org.name,
                quotedPrice: Number(quotedPrice),
                quotedInspections: Number(quotedInspections),
                billingPeriod: billingPeriod || request.preferredBillingPeriod,
                currency: request.currency,
              }
            );
          } else {
            // Send ready email if new quote
            const { sendQuotationReadyEmail } = await import("./resend");
            await sendQuotationReadyEmail(
              owner.email,
              owner.firstName || "Customer",
              {
                requestId: request.id,
                organizationName: org.name,
                quotedPrice: Number(quotedPrice),
                quotedInspections: Number(quotedInspections),
                billingPeriod: billingPeriod || request.preferredBillingPeriod,
                currency: request.currency,
              }
            );
          }
        }
      } catch (emailError) {
        console.error("Failed to send quotation email:", emailError);
        // Don't fail the request if email fails
      }

      res.json({ success: true, quotation });
    } catch (error: any) {
      console.error("Error creating/updating quote:", error);
      res.status(500).json({ message: "Failed to create/update quote", error: error.message });
    }
  });

  // Assign quotation to admin
  app.post("/api/admin/quotations/:id/assign", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { adminId } = req.body;
      const currentAdminId = req.session.adminUser.id;

      const request = await storage.getQuotationRequest(id);
      if (!request) {
        return res.status(404).json({ message: "Quotation request not found" });
      }

      await storage.updateQuotationRequest(id, { 
        assignedAdminId: adminId || currentAdminId 
      });

      await storage.createQuotationActivityLog({
        quotationRequestId: id,
        action: "assigned",
        performedBy: currentAdminId,
        performedByType: "admin",
        details: { assignedTo: adminId || currentAdminId },
      });

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error assigning quotation:", error);
      res.status(500).json({ message: "Failed to assign quotation", error: error.message });
    }
  });

  // Mark as contacted
  app.post("/api/admin/quotations/:id/contacted", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const adminId = req.session.adminUser.id;

      await storage.createQuotationActivityLog({
        quotationRequestId: id,
        action: "contacted",
        performedBy: adminId,
        performedByType: "admin",
        details: {},
      });

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error marking as contacted:", error);
      res.status(500).json({ message: "Failed to mark as contacted", error: error.message });
    }
  });

  // Reject quotation request
  app.post("/api/admin/quotations/:id/reject", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { reason } = req.body;
      const adminId = req.session.adminUser.id;

      const request = await storage.getQuotationRequest(id);
      if (!request) {
        return res.status(404).json({ message: "Quotation request not found" });
      }

      await storage.updateQuotationRequest(id, { status: "rejected" });

      await storage.createQuotationActivityLog({
        quotationRequestId: id,
        action: "rejected",
        performedBy: adminId,
        performedByType: "admin",
        details: { reason },
      });

      // Send rejection email to customer
      try {
        const { sendQuotationRejectedEmail } = await import("./resend");
        const org = await storage.getOrganization(request.organizationId);
        const owner = org ? await storage.getUser(org.ownerId) : null;
        
        if (org && owner) {
          await sendQuotationRejectedEmail(
            owner.email,
            owner.firstName || "Customer",
            {
              requestId: request.id,
              organizationName: org.name,
              reason: reason || "No reason provided",
            }
          );
        }
      } catch (emailError) {
        console.error("Failed to send rejection email:", emailError);
      }

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error rejecting quotation:", error);
      res.status(500).json({ message: "Failed to reject quotation", error: error.message });
    }
  });

  // Add internal admin notes
  app.post("/api/admin/quotations/:id/notes", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { notes } = req.body;
      const adminId = req.session.adminUser.id;

      const quotation = await storage.getQuotationByRequest(id);
      if (quotation) {
        await storage.updateQuotation(quotation.id, { adminNotes: notes });
      }

      await storage.createQuotationActivityLog({
        quotationRequestId: id,
        action: "note_added",
        performedBy: adminId,
        performedByType: "admin",
        details: { notes },
      });

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error adding notes:", error);
      res.status(500).json({ message: "Failed to add notes", error: error.message });
    }
  });

  // Get activity log
  app.get("/api/admin/quotations/:id/activity", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const activityLog = await storage.getQuotationActivityLog(id);
      res.json(activityLog);
    } catch (error: any) {
      console.error("Error fetching activity log:", error);
      res.status(500).json({ message: "Failed to fetch activity log", error: error.message });
    }
  });

  // Export quotations to CSV
  app.get("/api/admin/quotations/export", isAdminAuthenticated, async (req: any, res) => {
    try {
      const requests = await storage.getQuotationRequests();
      
      // Enrich with organization names
      const enriched = await Promise.all(requests.map(async (req) => {
        const org = await storage.getOrganization(req.organizationId);
        return {
          ...req,
          organizationName: org?.name || "Unknown",
        };
      }));

      // Convert to CSV
      const headers = ["ID", "Organization", "Requested Inspections", "Currency", "Billing Period", "Status", "Created At"];
      const rows = enriched.map(r => [
        r.id,
        r.organizationName,
        r.requestedInspections,
        r.currency,
        r.preferredBillingPeriod,
        r.status,
        r.createdAt,
      ]);

      const csv = [
        headers.join(","),
        ...rows.map(row => row.map(cell => `"${cell}"`).join(","))
      ].join("\n");

      res.setHeader("Content-Type", "text/csv");
      res.setHeader("Content-Disposition", "attachment; filename=quotations.csv");
      res.send(csv);
    } catch (error: any) {
      console.error("Error exporting quotations:", error);
      res.status(500).json({ message: "Failed to export quotations", error: error.message });
    }
  });

  // ==================== FIXFLO INTEGRATION ROUTES ====================

  // Get Fixflo configuration for current organization
  app.get("/api/fixflo/config", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const config = await storage.getFixfloConfig(user.organizationId);
      if (!config) {
        // Return empty/default config if not configured yet
        return res.json({
          organizationId: user.organizationId,
          baseUrl: "",
          bearerToken: "",
          webhookVerifyToken: "",
          isEnabled: false,
          lastHealthCheck: null,
          healthCheckStatus: null,
          lastError: null
        });
      }

      // Don't send the bearer token to the frontend (mask it)
      const safeConfig = {
        ...config,
        bearerToken: config.bearerToken ? "********" : "",
      };
      res.json(safeConfig);
    } catch (error) {
      console.error("Error fetching Fixflo config:", error);
      res.status(500).json({ message: "Failed to fetch Fixflo configuration" });
    }
  });

  // Update Fixflo configuration
  app.post("/api/fixflo/config", isAuthenticated, requireRole("owner"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const { baseUrl, bearerToken, webhookVerifyToken, isEnabled } = req.body;

      if (!baseUrl || !bearerToken) {
        return res.status(400).json({ message: "Base URL and Bearer Token are required" });
      }

      const config = await storage.upsertFixfloConfig({
        organizationId: user.organizationId,
        baseUrl,
        bearerToken,
        webhookVerifyToken,
        isEnabled: isEnabled ?? false,
      });

      // Don't send the bearer token back
      const { bearerToken: _, ...safeConfig } = config;
      res.json(safeConfig);
    } catch (error) {
      console.error("Error updating Fixflo config:", error);
      res.status(500).json({ message: "Failed to update Fixflo configuration" });
    }
  });

  // Health check Fixflo API connection
  app.post("/api/fixflo/health-check", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const config = await storage.getFixfloConfig(user.organizationId);
      if (!config) {
        return res.status(404).json({ message: "Fixflo not configured" });
      }

      const { createFixfloClient, FixfloClientError } = await import("./services/fixflo-client");
      const client = await createFixfloClient(config);
      const isHealthy = await client.healthCheck();

      await storage.updateFixfloHealthCheck(user.organizationId, {
        lastHealthCheck: new Date(),
        healthCheckStatus: isHealthy ? "healthy" : "error",
        lastError: isHealthy ? null : "Health check failed",
      });

      res.json({ healthy: isHealthy });
    } catch (error: any) {
      console.error("Error performing Fixflo health check:", error);

      const user = await storage.getUser(req.user.id);
      if (user?.organizationId) {
        await storage.updateFixfloHealthCheck(user.organizationId, {
          lastHealthCheck: new Date(),
          healthCheckStatus: "error",
          lastError: error.message || "Unknown error",
        });
      }

      res.status(500).json({
        healthy: false,
        message: error.message || "Health check failed"
      });
    }
  });

  // Create issue in Fixflo from maintenance request
  app.post("/api/fixflo/issues", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const { maintenanceRequestId, propertyId, title, description, priority, category } = req.body;

      if (!maintenanceRequestId || !propertyId) {
        return res.status(400).json({ message: "Maintenance request ID and property ID are required" });
      }

      // Get Fixflo config
      const config = await storage.getFixfloConfig(user.organizationId);
      if (!config?.isEnabled) {
        return res.status(400).json({ message: "Fixflo integration is not enabled" });
      }

      // Get property to check for Fixflo property ID
      const property = await storage.getProperty(propertyId);
      if (!property || property.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Property not found" });
      }

      if (!property.fixfloPropertyId) {
        return res.status(400).json({
          message: "Property is not mapped to Fixflo. Please configure property mapping first."
        });
      }

      // Create issue in Fixflo
      const { createFixfloClient } = await import("./services/fixflo-client");
      const client = await createFixfloClient(config);

      const fixfloResponse = await client.createIssue({
        propertyId: property.fixfloPropertyId,
        title,
        description,
        priority: priority || "medium",
        category,
        externalRef: maintenanceRequestId,
      });

      // Update maintenance request with Fixflo IDs
      await storage.updateMaintenanceRequest(maintenanceRequestId, {
        fixfloIssueId: fixfloResponse.id,
        fixfloJobId: fixfloResponse.jobId,
        fixfloStatus: fixfloResponse.status,
        fixfloSyncedAt: new Date(),
      });

      res.json({
        success: true,
        fixfloIssueId: fixfloResponse.id,
        fixfloJobId: fixfloResponse.jobId,
        status: fixfloResponse.status,
      });
    } catch (error: any) {
      console.error("Error creating Fixflo issue:", error);
      res.status(500).json({
        message: "Failed to create issue in Fixflo",
        error: error.message
      });
    }
  });

  // Update issue in Fixflo
  app.patch("/api/fixflo/issues/:issueId", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const { issueId } = req.params;
      const { priority, status, assignedAgentId, notes } = req.body;

      // Get Fixflo config
      const config = await storage.getFixfloConfig(user.organizationId);
      if (!config?.isEnabled) {
        return res.status(400).json({ message: "Fixflo integration is not enabled" });
      }

      // Update issue in Fixflo
      const { createFixfloClient } = await import("./services/fixflo-client");
      const client = await createFixfloClient(config);

      const fixfloResponse = await client.updateIssue(issueId, {
        priority,
        status,
        notes,
      });

      // If contractor was assigned, do that separately
      if (assignedAgentId) {
        await client.assignContractor(issueId, assignedAgentId);
      }

      res.json({
        success: true,
        status: fixfloResponse.status,
      });
    } catch (error: any) {
      console.error("Error updating Fixflo issue:", error);
      res.status(500).json({
        message: "Failed to update issue in Fixflo",
        error: error.message
      });
    }
  });

  // Get Fixflo sync state for organization
  app.get("/api/fixflo/sync-state", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const syncStates = await storage.getFixfloSyncStates(user.organizationId);
      res.json(syncStates);
    } catch (error) {
      console.error("Error fetching Fixflo sync state:", error);
      res.status(500).json({ message: "Failed to fetch sync state" });
    }
  });

  // Get Fixflo webhook logs for debugging
  app.get("/api/fixflo/webhook-logs", isAuthenticated, requireRole("owner"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      const limit = parseInt(req.query.limit as string) || 50;
      const logs = await storage.getFixfloWebhookLogs(user.organizationId, limit);
      res.json(logs);
    } catch (error) {
      console.error("Error fetching Fixflo webhook logs:", error);
      res.status(500).json({ message: "Failed to fetch webhook logs" });
    }
  });

  // Inbound webhook endpoint from Fixflo
  app.post("/api/integrations/fixflo/webhook", async (req, res) => {
    const { processFixfloWebhook } = await import("./services/fixflo-webhook-processor");

    try {
      // Get the organization ID from webhook payload or headers
      const organizationId = req.body.organizationId || req.headers["x-organization-id"];

      if (!organizationId) {
        console.error("[Fixflo Webhook] No organization ID provided");
        return res.status(400).json({ message: "Organization ID required" });
      }

      // Get Fixflo config to verify webhook token
      const config = await storage.getFixfloConfig(organizationId as string);
      if (!config) {
        console.error("[Fixflo Webhook] No config found for organization:", organizationId);
        return res.status(404).json({ message: "Fixflo not configured for this organization" });
      }

      // Verify webhook token if configured
      const webhookToken = req.headers["x-fixflo-webhook-token"];
      if (config.webhookVerifyToken && webhookToken !== config.webhookVerifyToken) {
        console.error("[Fixflo Webhook] Invalid webhook token");
        return res.status(403).json({ message: "Invalid webhook token" });
      }

      const payload = req.body;
      const eventType = payload.eventType || payload.event || "Unknown";

      // Create webhook log for audit trail
      const webhookLog = await storage.createFixfloWebhookLog({
        organizationId: organizationId as string,
        eventType,
        fixfloIssueId: payload.issueId || payload.Issue?.Id,
        fixfloJobId: payload.jobId || payload.Job?.Id,
        payloadJson: payload,
        processingStatus: "pending",
        retryCount: 0,
      });

      // Return 200 immediately to acknowledge receipt
      res.status(200).json({ received: true, webhookLogId: webhookLog.id });

      // Process webhook asynchronously
      processFixfloWebhook(webhookLog.id, organizationId as string, payload, storage)
        .catch((error: any) => {
          console.error("[Fixflo Webhook] Processing error:", error);
        });

    } catch (error: any) {
      console.error("[Fixflo Webhook] Error receiving webhook:", error);
      res.status(500).json({
        message: "Failed to process webhook",
        error: error.message
      });
    }
  });

  // Legacy billing routes removed to avoid conflict with 2026 model

  // Create Stripe customer portal session
  app.post("/api/billing/portal", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const org = await storage.getOrganization(user.organizationId);
      let stripeCustomerId = org?.stripeCustomerId;

      // If org doesn't have a customer ID, try to find it from existing subscriptions
      if (!stripeCustomerId) {
        console.log(`[Portal] Organization ${user.organizationId} has no stripeCustomerId, checking subscriptions...`);
        
        // Check if there's a subscription with a customer ID
        const subscription = await storage.getSubscriptionByOrganization(user.organizationId);
        
        if (subscription?.stripeCustomerId) {
          console.log(`[Portal] Found customer ID from subscription: ${subscription.stripeCustomerId}`);
          stripeCustomerId = subscription.stripeCustomerId;
          // Update the organization with the customer ID
          await storage.updateOrganizationStripe(user.organizationId, stripeCustomerId, org?.subscriptionStatus || "inactive");
        } else {
          // Check instance_subscriptions for Stripe customer
          const instanceSub = await storage.getInstanceSubscription(user.organizationId);
          if (instanceSub) {
            // Try to find customer from Stripe subscriptions
            const stripe = await getUncachableStripeClient();
            try {
              // Search for subscriptions by organization metadata or email
              const subscriptions = await stripe.subscriptions.list({
                limit: 100,
                expand: ['data.customer'],
              });
              
              // Try to match by user email
              const matchingSub = subscriptions.data.find((sub: any) => {
                const customer = sub.customer;
                if (typeof customer === 'object' && customer?.email === user.email) {
                  return true;
                }
                return false;
              });
              
              if (matchingSub) {
                const customerId = typeof matchingSub.customer === 'string' 
                  ? matchingSub.customer 
                  : (matchingSub.customer as any)?.id;
                
                if (customerId) {
                  console.log(`[Portal] Found customer ID from Stripe: ${customerId}`);
                  stripeCustomerId = customerId;
                  if (stripeCustomerId) {
                    await storage.updateOrganizationStripe(user.organizationId, stripeCustomerId, "active");
                  }
                }
              }
            } catch (stripeError: any) {
              console.warn(`[Portal] Could not search Stripe for customer: ${stripeError.message}`);
            }
          }
        }
      }

      if (!stripeCustomerId) {
        return res.status(400).json({ 
          message: "No active Stripe customer found. Please complete a subscription purchase first." 
        });
      }

      const baseUrl = getBaseUrl(req);

      const stripe = await getUncachableStripeClient();
      const session = await stripe.billingPortal.sessions.create({
        customer: stripeCustomerId,
        return_url: `${baseUrl}/billing`,
      });

      res.json({ url: session.url });
    } catch (error: any) {
      console.error("Error creating portal session:", error);
      res.status(500).json({ message: "Failed to create portal session", error: error.message });
    }
  });

  // Process completed checkout session (fallback for when webhooks don't fire)
  app.post("/api/billing/process-session", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { sessionId } = req.body;
      if (!sessionId) {
        return res.status(400).json({ message: "Session ID is required" });
      }

      console.log(`[Process Session] Retrieving session ${sessionId} for org ${user.organizationId}`);

      // Retrieve the session from Stripe
      const stripe = await getUncachableStripeClient();
      const session = await stripe.checkout.sessions.retrieve(sessionId);

      // Check if we're in test mode (test keys start with sk_test_)
      const secretKey = await getStripeSecretKey();
      const isTestMode = secretKey.startsWith('sk_test_');

      console.log(`[Process Session] Test mode: ${isTestMode}, Payment status: ${session.payment_status}, Subscription: ${session.subscription || 'none'}`);

      // Verify the session belongs to this organization
      if (session.metadata?.organizationId !== user.organizationId) {
        console.error(`[Process Session] SECURITY: Session org mismatch - Session org: ${session.metadata?.organizationId}, User org: ${user.organizationId}`);
        return res.status(403).json({ message: "Session does not belong to your organization" });
      }

      // In test mode, allow processing even if payment_status isn't "paid"
      // In production, require payment_status to be "paid"
      if (!isTestMode && session.payment_status !== "paid") {
        console.log(`[Process Session] Payment not completed (non-test mode). Status: ${session.payment_status}`);
        return res.status(400).json({ message: "Payment not completed", status: session.payment_status });
      }

      if (isTestMode && session.payment_status !== "paid") {
        console.log(`[Process Session] TEST MODE: Processing despite payment_status: ${session.payment_status}`);
      }

      console.log(`[Process Session] Metadata received:`, session.metadata);

      const {
        organizationId, planId, includedCredits, topupOrderId, packSize,
        billingPeriod, tierId, planCode, currency, requestedInspections
      } = session.metadata || {};

      // Parse counts safely
      const parsedRequested = requestedInspections ? parseInt(requestedInspections) : NaN;
      const parsedIncluded = includedCredits ? parseInt(includedCredits) : NaN;
      const parsedPackSize = packSize ? parseInt(packSize) : NaN;

      // Handle quotation subscription processing
      if (session.metadata?.type === "quotation_subscription") {
        const { quotationId, quotedInspections, billingPeriod, currency } = session.metadata;
        console.log(`[Process Session] Processing quotation subscription for org ${user.organizationId}: quotationId=${quotationId}`);

        if (!quotationId) {
          return res.status(400).json({ message: "Quotation ID is required" });
        }

        const quotation = await storage.getQuotation(quotationId);
        if (!quotation) {
          return res.status(404).json({ message: "Quotation not found" });
        }

        // Verify quotation belongs to this organization
        const request = await storage.getQuotationRequest(quotation.quotationRequestId);
        if (!request || request.organizationId !== user.organizationId) {
          return res.status(403).json({ message: "Quotation does not belong to your organization" });
        }

        // Get tier for custom quotations (prefer Enterprise Plus, fallback to Enterprise)
        const tiers = await storage.getSubscriptionTiers();
        let selectedTier = tiers.find(t => t.code === "enterprise_plus");
        
        // If Enterprise Plus not found, use Enterprise tier as fallback
        if (!selectedTier) {
          selectedTier = tiers.find(t => t.code === "enterprise");
          console.log(`[Process Session] Enterprise Plus not found, using Enterprise tier as fallback`);
        }
        
        // If Enterprise not found, use the highest tier available (by tierOrder)
        if (!selectedTier) {
          selectedTier = tiers.sort((a, b) => b.tierOrder - a.tierOrder)[0];
          console.log(`[Process Session] Enterprise not found, using highest tier: ${selectedTier?.name}`);
        }
        
        if (!selectedTier) {
          console.error(`[Process Session] No tier found for quotation subscription. Available tiers: ${tiers.map(t => t.code).join(', ')}`);
          return res.status(500).json({ message: "No suitable tier found for quotation subscription" });
        }
        
        console.log(`[Process Session] Using tier ${selectedTier.name} (${selectedTier.code}) for quotation subscription`);

        // Use quotation.quotedInspections as the source of truth (it's the authoritative value)
        // The metadata quotedInspections is just for reference/logging
        const inspectionsToGrant = quotation.quotedInspections;
        
        console.log(`[Process Session] Quotation credit calculation: quotationId=${quotationId}, metadata.quotedInspections=${quotedInspections}, quotation.quotedInspections=${quotation.quotedInspections}, final=${inspectionsToGrant}`);
        
        if (!inspectionsToGrant || inspectionsToGrant <= 0) {
          console.error(`[Process Session] Invalid inspections to grant from quotation ${quotationId}: ${inspectionsToGrant}`);
          return res.status(400).json({ message: `Invalid quotation inspections count: ${inspectionsToGrant}. Please contact support.` });
        }
        
        // Warn if metadata doesn't match quotation (but don't fail - use quotation as source of truth)
        const metadataValue = quotedInspections ? parseInt(quotedInspections.toString()) : null;
        if (metadataValue && metadataValue !== inspectionsToGrant) {
          console.warn(`[Process Session] WARNING: Metadata quotedInspections (${metadataValue}) doesn't match quotation.quotedInspections (${inspectionsToGrant}). Using quotation value.`);
        }
        
        const billingCycle = (billingPeriod === "annual" ? "annual" : "monthly") as any;
        const registrationCurrency = (currency || quotation.currency || "GBP").toUpperCase() as any;

        // Get renewal date from Stripe subscription if available
        let renewalDate: Date;
        if (session.subscription) {
          try {
            const stripeSubscription = await stripe.subscriptions.retrieve(session.subscription as string);
            renewalDate = new Date(((stripeSubscription as any).current_period_end as number) * 1000);
            console.log(`[Process Session] Using Stripe subscription period_end for renewal date: ${renewalDate.toISOString()}`);
          } catch (subscriptionError: any) {
            console.warn(`[Process Session] Could not retrieve subscription for renewal date, using calculated fallback:`, subscriptionError.message);
            renewalDate = new Date(Date.now() + (billingCycle === "annual" ? 365 : 30) * 24 * 60 * 60 * 1000);
          }
        } else {
          renewalDate = new Date(Date.now() + (billingCycle === "annual" ? 365 : 30) * 24 * 60 * 60 * 1000);
        }

        // IMPORTANT: Cancel all existing active Stripe subscriptions for this organization
        // This ensures only the latest plan is active, preventing double billing on renewal
        const quotationOrg = await storage.getOrganization(user.organizationId);
        if (quotationOrg?.stripeCustomerId) {
          try {
            const allSubscriptions = await stripe.subscriptions.list({
              customer: quotationOrg.stripeCustomerId,
              status: "active",
              limit: 100
            });

            // Only cancel tier subscriptions, NOT module subscriptions
            // Modules are separate subscriptions and should coexist with tier subscriptions
            // Get all tier names to help identify tier subscriptions by product name
            const tiers = await storage.getSubscriptionTiers();
            const tierNames = tiers.map(t => t.name);
            
            for (const sub of allSubscriptions.data) {
              if (sub.status === "active" && sub.id !== (session.subscription as string)) {
                // Check if this is a tier subscription (not a module subscription)
                // Check both metadata AND product names for reliable identification
                const subMetadata = sub.metadata || {};
                
                // Check metadata first
                const hasTierMetadata = subMetadata.tierId || subMetadata.planCode || 
                                       (subMetadata.type === "tier_subscription");
                
                // Check product names to identify tier subscriptions (for older subscriptions without metadata)
                let hasTierProductName = false;
                const items = sub.items?.data || [];
                for (const item of items) {
                  const product = item.price?.product;
                  const productName = (typeof product === 'object' && product && 'name' in product) 
                    ? (product.name || '') 
                    : (item.price?.nickname || '');
                  
                  // Check if product name contains tier name or "Plan" (tier subscriptions have names like "Inspect360 [Tier] Plan")
                  if (productName) {
                    const nameLower = productName.toLowerCase();
                    if (nameLower.includes('plan') && nameLower.includes('inspect360')) {
                      // Check if it contains any tier name
                      for (const tierName of tierNames) {
                        if (nameLower.includes(tierName.toLowerCase())) {
                          hasTierProductName = true;
                          break;
                        }
                      }
                      // Also check for "Starter", "Growth", "Professional", "Enterprise" keywords
                      if (nameLower.includes('starter') || nameLower.includes('growth') || 
                          nameLower.includes('professional') || nameLower.includes('enterprise')) {
                        hasTierProductName = true;
                      }
                    }
                  }
                }
                
                const isTierSubscription = hasTierMetadata || hasTierProductName;
                const isModuleSubscription = subMetadata.type === "module_purchase" ||
                                           subMetadata.moduleId;
                
                // Only cancel tier subscriptions, preserve module subscriptions
                if (isTierSubscription && !isModuleSubscription) {
                  console.log(`[Process Session] Cancelling existing tier subscription ${sub.id} for org ${user.organizationId} before processing quotation subscription (identified by ${hasTierMetadata ? 'metadata' : 'product name'})`);
                  try {
                    await stripe.subscriptions.cancel(sub.id);
                    console.log(`[Process Session] Successfully cancelled tier subscription ${sub.id}`);
                  } catch (cancelError: any) {
                    console.error(`[Process Session] Failed to cancel subscription ${sub.id}:`, cancelError.message);
                    // Continue with new subscription creation even if cancellation fails
                  }
                } else {
                  console.log(`[Process Session] Preserving ${isModuleSubscription ? 'module' : 'other'} subscription ${sub.id} (not a tier subscription - metadata: ${hasTierMetadata}, productName: ${hasTierProductName})`);
                }
              }
            }
          } catch (listError: any) {
            console.error(`[Process Session] Error listing subscriptions:`, listError.message);
            // Continue with new subscription creation even if listing fails
          }
        }

        // Update or create instance subscription
        const existingInstanceSub = await storage.getInstanceSubscription(user.organizationId);
        if (existingInstanceSub) {
          await storage.updateInstanceSubscription(existingInstanceSub.id, {
            currentTierId: selectedTier.id,
            inspectionQuotaIncluded: inspectionsToGrant,
            billingCycle: billingCycle,
            registrationCurrency: registrationCurrency,
            subscriptionStatus: "active",
            subscriptionRenewalDate: renewalDate
          });
        } else {
          await storage.createInstanceSubscription({
            organizationId: user.organizationId,
            registrationCurrency: registrationCurrency,
            currentTierId: selectedTier.id,
            inspectionQuotaIncluded: inspectionsToGrant,
            billingCycle: billingCycle,
            subscriptionStatus: "active",
            subscriptionRenewalDate: renewalDate,
            subscriptionStartDate: new Date()
          });
        }

        // For quotation subscriptions, APPEND credits (don't expire existing ones)
        // This allows customers to keep their existing credits when upgrading via quotation
        console.log(`[Process Session] Appending ${inspectionsToGrant} credits for quotation subscription (not expiring existing credits)`);

        // Grant credits for the quotation subscription (append to existing)
        const { subscriptionService: subService } = await import("./subscriptionService");
        await subService.grantCredits(
          user.organizationId,
          inspectionsToGrant,
          "plan_inclusion",
          renewalDate,
          { 
            subscriptionId: session.subscription as string,
            adminNotes: `Quotation subscription: ${quotationId} - ${inspectionsToGrant} inspections`,
            createdBy: user.id
          }
        );

        console.log(`[Process Session] Quotation subscription activated: ${inspectionsToGrant} credits APPENDED to org ${user.organizationId} (existing credits preserved)`);
        return res.json({ message: "Quotation subscription activated successfully", processed: true });
      }

      // Handle module purchase processing
      if (session.metadata?.type === "module_purchase") {
        const { moduleId, isProrated, fullPrice, proratedPrice, remainingDays, billingCycle } = session.metadata;
        console.log(`[Process Session] Processing module purchase for org ${user.organizationId}: ${moduleId}`);

        const instanceSub = await storage.getInstanceSubscription(user.organizationId);
        if (!instanceSub) {
          return res.status(404).json({ message: "Instance subscription not found" });
        }

        // IMPORTANT: Wrap module activation in transaction to ensure atomicity with payment
        try {
          const { db } = await import("./db");
          const { instanceModules: instanceModulesTable } = await import("@shared/schema");
          const { eq, and } = await import("drizzle-orm");
          
          await db.transaction(async (tx) => {
            // Enable the module
          await storage.toggleInstanceModule(instanceSub.id, moduleId, true);
            
            // Update module pricing if needed
            const orgForPricing = await storage.getOrganization(user.organizationId!);
            const currency = instanceSub.registrationCurrency || orgForPricing?.preferredCurrency || "GBP";
            const modulePricing = await storage.getModulePricing(moduleId, currency);
            
            if (modulePricing) {
              // Update instance module with pricing info
              const updatedInstanceModulesList = await storage.getInstanceModules(instanceSub.id);
              const instanceModule = updatedInstanceModulesList.find(im => im.moduleId === moduleId);
              if (instanceModule) {
                await tx.update(instanceModulesTable)
                  .set({
                    monthlyPrice: modulePricing.priceMonthly,
                    annualPrice: modulePricing.priceAnnual,
                    currencyCode: currency,
                    billingStartDate: new Date()
                  })
                  .where(eq(instanceModulesTable.id, instanceModule.id));
              }
            }
          });
          
          // CRITICAL: Update subscription metadata and align billing cycle with tier subscription
          // Stripe doesn't automatically transfer checkout session metadata to subscription metadata
          if (session.subscription) {
            try {
              console.log(`[Process Session] Updating module subscription ${session.subscription} metadata and aligning billing cycle`);
              const stripe = await getUncachableStripeClient();
              
              // Get tier subscription renewal date from metadata or instance subscription
              let tierRenewalDate: Date | null = null;
              if (session.metadata?.tierRenewalDate) {
                tierRenewalDate = new Date(session.metadata.tierRenewalDate);
              } else {
                // Fallback: get from instance subscription
                if (instanceSub?.subscriptionRenewalDate && instanceSub?.billingCycle === billingCycle) {
                  tierRenewalDate = typeof instanceSub.subscriptionRenewalDate === 'string'
                    ? new Date(instanceSub.subscriptionRenewalDate)
                    : instanceSub.subscriptionRenewalDate;
                }
              }
              
              // Prepare update data
              const updateData: any = {
                metadata: {
                  ...session.metadata,
                  // Ensure type and moduleId are set for identification
                  type: "module_purchase",
                  moduleId: moduleId,
                }
              };
              
              // Try to align billing cycle anchor with tier subscription if renewal date is available
              // Note: Stripe allows billing_cycle_anchor update only if it's within the next billing period
              if (tierRenewalDate) {
                const now = new Date();
                const anchorTimestamp = Math.floor(tierRenewalDate.getTime() / 1000);
                const nowTimestamp = Math.floor(now.getTime() / 1000);
                const daysUntilRenewal = Math.ceil((tierRenewalDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
                
                // Stripe allows billing_cycle_anchor if it's:
                // 1. In the future (after now)
                // 2. Within the next billing period (for monthly: within 30 days, for annual: within 365 days)
                const maxDays = billingCycle === "annual" ? 365 : 30;
                
                if (anchorTimestamp > nowTimestamp && daysUntilRenewal <= maxDays) {
                  updateData.billing_cycle_anchor = anchorTimestamp;
                  console.log(`[Process Session] Aligning module subscription billing cycle with tier subscription renewal date: ${tierRenewalDate.toISOString()} (${daysUntilRenewal} days away)`);
                } else {
                  console.log(`[Process Session] Tier renewal date ${tierRenewalDate.toISOString()} (${daysUntilRenewal} days away) is outside allowed range for billing_cycle_anchor, skipping alignment`);
                  console.log(`[Process Session] Module subscription will renew on its natural date, but proration was calculated correctly`);
                }
              }
              
              await stripe.subscriptions.update(session.subscription as string, updateData);
              console.log(`[Process Session] âœ… Successfully updated module subscription metadata and billing cycle`);
            } catch (metadataError: any) {
              console.error(`[Process Session] âš ï¸  Failed to update module subscription:`, metadataError.message);
              // Continue even if update fails - proration was already charged correctly
            }
          }
          
          // Log proration information
          if (isProrated === "true" && fullPrice && proratedPrice && remainingDays) {
            // Get currency from subscription or organization, fallback to GBP
            const org = await storage.getOrganization(user.organizationId);
            const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
            console.log(`[Process Session] Module ${moduleId} enabled for org ${user.organizationId} (PRO-RATED)`);
            console.log(`[Process Session] Full price: ${parseInt(fullPrice)/100} ${currency}, Prorated: ${parseInt(proratedPrice)/100} ${currency}, Remaining days: ${remainingDays}`);
          } else {
            console.log(`[Process Session] Module ${moduleId} enabled for org ${user.organizationId} (full price)`);
          }
          
          return res.json({ message: "Module activated successfully", processed: true });
        } catch (moduleError: any) {
          console.error(`[Process Session] Error activating module:`, moduleError);
          return res.status(500).json({ 
            message: "Failed to activate module", 
            error: moduleError?.message || "Unknown error",
            processed: false
          });
        }
      }

      // Handle bundle purchase processing
      if (session.metadata?.type === "bundle_purchase") {
        try {
          console.log(`[Process Session] BUNDLE PURCHASE DETECTED - Processing bundle purchase`);
          const { bundleId, billingCycle, isProrated, fullPrice, proratedPrice, remainingDays } = session.metadata;
          console.log(`[Process Session] Processing bundle purchase for org ${user.organizationId}: bundleId=${bundleId}`);

          if (!bundleId) {
            console.error(`[Process Session] Bundle ID missing in metadata`);
            return res.status(400).json({ message: "Bundle ID is required" });
          }

          const instanceSub = await storage.getInstanceSubscription(user.organizationId);
          if (!instanceSub) {
            console.error(`[Process Session] Instance subscription not found for org ${user.organizationId}`);
          return res.status(404).json({ message: "Instance subscription not found" });
          }

          // Check if bundle already exists
          const existingBundles = await storage.getInstanceBundles(instanceSub.id);
          const existingBundle = existingBundles.find(ib => ib.bundleId === bundleId && ib.isActive);
          if (existingBundle) {
            console.log(`[Process Session] Bundle ${bundleId} already active for org ${user.organizationId}`);
            return res.json({ message: "Bundle already activated", processed: true });
          }

          // Get bundle details
          const bundles = await storage.getModuleBundles();
          const bundle = bundles.find(b => b.id === bundleId);
          if (!bundle) {
            console.error(`[Process Session] Bundle ${bundleId} not found in database`);
            return res.status(404).json({ message: "Bundle not found" });
          }

          // Get currency from subscription or organization, fallback to GBP
          const org = await storage.getOrganization(user.organizationId);
          const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
          const bundlePricing = await storage.getBundlePricing(bundleId, currency);
          if (!bundlePricing) {
            console.error(`[Process Session] Bundle pricing not configured for bundle ${bundleId} in currency ${currency}`);
            return res.status(404).json({ message: `Bundle pricing not configured for bundle ${bundleId} in currency ${currency}` });
          }

          // Import required tables and db
          const { instanceBundles, instanceModules: instanceModulesTable } = await import("@shared/schema");
          const { db } = await import("./db");
          const { eq, and } = await import("drizzle-orm");

          // Use transaction to ensure atomicity: bundle creation + all module enables succeed or all fail
          await db.transaction(async (tx) => {
            // Create instance bundle record with pricing
            await tx.insert(instanceBundles).values({
              instanceId: instanceSub.id,
              bundleId: bundleId,
              isActive: true,
              startDate: new Date(),
              purchaseDate: new Date(),
              bundlePriceMonthly: bundlePricing.priceMonthly,
              bundlePriceAnnual: bundlePricing.priceAnnual,
              currencyCode: currency
            });

            // Enable all modules in the bundle and set their prices to 0 (bundle covers the cost)
            const bundleModules = await storage.getBundleModules(bundleId);
            const enabledModuleIds: string[] = [];
            
            for (const bm of bundleModules) {
              // Check if module instance already exists (using transaction context)
              const existingModules = await tx.select()
                .from(instanceModulesTable)
                .where(and(
                  eq(instanceModulesTable.instanceId, instanceSub.id),
                  eq(instanceModulesTable.moduleId, bm.moduleId)
                ))
                .limit(1);
              
              const existingModule = existingModules[0];
              
              if (existingModule) {
                // Update existing module: enable it and set price to 0 (bundle covers the cost)
                await tx.update(instanceModulesTable)
                  .set({
                    isEnabled: true,
                    enabledDate: new Date(),
                    disabledDate: null,
                    monthlyPrice: 0, // Bundle covers the cost
                    annualPrice: 0,
                    currencyCode: currency,
                    billingStartDate: new Date()
                  })
                  .where(eq(instanceModulesTable.id, existingModule.id));
              } else {
                // Insert new module instance: enabled with price 0 (bundle covers the cost)
                await tx.insert(instanceModulesTable)
                  .values({
                    instanceId: instanceSub.id,
                    moduleId: bm.moduleId,
                    isEnabled: true,
                    enabledDate: new Date(),
                    monthlyPrice: 0, // Bundle covers the cost
                    annualPrice: 0,
                    currencyCode: currency,
                    billingStartDate: new Date()
                  });
              }
              
              enabledModuleIds.push(bm.moduleId);
            }
            
            console.log(`[Process Session] Successfully enabled ${enabledModuleIds.length} modules for bundle ${bundleId}`);
          });

          // Log proration information
          if (isProrated === "true" && fullPrice && proratedPrice && remainingDays) {
            console.log(`[Process Session] Bundle ${bundle.name} enabled for org ${user.organizationId} (PRO-RATED)`);
            console.log(`[Process Session] Full price: ${parseInt(fullPrice)/100} ${currency}, Prorated: ${parseInt(proratedPrice)/100} ${currency}, Remaining days: ${remainingDays}`);
          } else {
            console.log(`[Process Session] Bundle ${bundle.name} enabled for org ${user.organizationId} (full price)`);
          }

          // Send bundle purchased notification
          try {
            const { notificationService } = await import("./notificationService");
            await notificationService.sendBundlePurchasedNotification(
              user.organizationId,
              bundle.name || "Bundle",
              parseInt(proratedPrice || fullPrice || "0") / 100,
              currency,
              (billingCycle || "monthly") as "monthly" | "annual"
            );
          } catch (notifError) {
            console.error(`[Process Session] Failed to send bundle purchased notification:`, notifError);
          }

          console.log(`[Process Session] Bundle purchase completed successfully for org ${user.organizationId}`);
          return res.json({ message: "Bundle activated successfully", processed: true });
        } catch (error: any) {
          console.error(`[Process Session] Error processing bundle purchase:`, error);
          return res.status(500).json({ 
            message: "Failed to process bundle purchase", 
            error: error?.message || "Unknown error",
            processed: false
          });
        }
      }

      // Handle addon pack purchase processing
      if (session.metadata?.type === "addon_pack_purchase") {
        const packId = session.metadata?.packId;
        const tierIdAtPurchase = session.metadata?.tierIdAtPurchase;
        let quantity = parseInt(session.metadata?.quantity || "0");
        const pricePerInspection = parseInt(session.metadata?.pricePerInspection || "0");
        const totalPrice = parseInt(session.metadata?.totalPrice || "0");
        const currency = session.metadata?.currency || "GBP";

        console.log(`[Process Session] Processing addon pack purchase for org ${user.organizationId}: packId=${packId}, quantity=${quantity}, packName=${session.metadata?.packName || 'N/A'}`);
        
        // Double-check quantity is valid and matches pack
        const packs = await storage.getAddonPacks();
        const pack = packs.find(p => p.id === packId);
        if (pack && pack.inspectionQuantity !== quantity) {
          console.error(`[Process Session] QUANTITY MISMATCH: Pack ${packId} has inspectionQuantity=${pack.inspectionQuantity}, but metadata says quantity=${quantity}. Using pack.inspectionQuantity.`);
          // Use the actual pack quantity instead of metadata
          quantity = pack.inspectionQuantity;
        }

        if (!packId || !tierIdAtPurchase || quantity <= 0) {
          console.error(`[Process Session] Missing required fields for addon pack purchase - PackId: ${packId}, TierId: ${tierIdAtPurchase}, Quantity: ${quantity}`);
          return res.status(400).json({ message: "Missing required fields for addon pack purchase" });
        }

        // Get or create instance subscription
        let instanceSub = await storage.getInstanceSubscription(user.organizationId);
        if (!instanceSub) {
          instanceSub = await storage.createInstanceSubscription({
            organizationId: user.organizationId,
            registrationCurrency: currency,
            inspectionQuotaIncluded: 0,
            billingCycle: "monthly",
            subscriptionStatus: "active"
          });
        }

        // Check if purchase already exists (prevent duplicate processing)
        // But also check if credits were already granted
        const existingPurchases = await storage.getInstanceAddonPurchases(instanceSub.id);
        const existingPurchase = existingPurchases.find(
          p => p.packId === packId && 
               p.status === "active" && 
               Math.abs(new Date(p.purchaseDate || new Date()).getTime() - new Date().getTime()) < 60000 // Within 1 minute
        );

        if (existingPurchase) {
          // Check if credits were already granted for this purchase
          const { subscriptionService: subService } = await import("./subscriptionService");
          const creditBatches = await storage.getCreditBatchesByOrganization(user.organizationId);
          const creditsGranted = creditBatches.some(
            batch => batch.grantSource === "addon_pack" && 
                     batch.metadataJson && 
                     (batch.metadataJson as any).addonPurchaseId === existingPurchase.id
          );

          if (creditsGranted) {
            console.log(`[Process Session] Addon pack purchase already processed and credits granted: ${existingPurchase.id}`);
            return res.json({ message: "Already processed", processed: true, creditsGranted: true });
          } else {
            // Purchase exists but credits weren't granted - grant them now
            console.log(`[Process Session] Purchase record exists but credits not granted. Granting credits now for purchase ${existingPurchase.id}`);
            try {
              // Calculate expiration date based on subscription renewal date
              let expiresAt: Date | undefined = undefined;
              if (instanceSub.subscriptionRenewalDate) {
                expiresAt = new Date(instanceSub.subscriptionRenewalDate);
              } else {
                // If no renewal date set, calculate based on billing cycle
                const renewalDate = new Date();
                if (instanceSub.billingCycle === "annual") {
                  renewalDate.setFullYear(renewalDate.getFullYear() + 1);
                } else {
                  renewalDate.setMonth(renewalDate.getMonth() + 1);
                }
                expiresAt = renewalDate;
              }
              
              await subService.grantCredits(
                user.organizationId,
                existingPurchase.quantity,
                "addon_pack",
                expiresAt, // Expire with subscription plan
                {
                  addonPurchaseId: existingPurchase.id,
                  adminNotes: `Addon pack purchase via Stripe session: ${sessionId} (retry)`,
                  createdBy: user.id
                },
                existingPurchase.pricePerInspection
              );
              console.log(`[Process Session] Successfully granted ${existingPurchase.quantity} credits to organization ${user.organizationId} for pack ${packId} (retry)`);
              return res.json({ message: "Credits granted successfully", processed: true, creditsGranted: existingPurchase.quantity });
            } catch (creditError: any) {
              console.error(`[Process Session] ERROR granting credits (retry) to organization ${user.organizationId}:`, creditError);
              return res.status(500).json({ 
                message: "Purchase exists but credits grant failed", 
                error: creditError.message,
                processed: true
              });
            }
          }
        }

        // Create add-on purchase record
        const addonPurchase = await storage.createInstanceAddonPurchase({
          instanceId: instanceSub.id,
          packId,
          tierIdAtPurchase,
          quantity,
          pricePerInspection,
          totalPrice,
          currencyCode: currency,
          inspectionsRemaining: quantity,
          status: "active"
        });

        console.log(`[Process Session] Created addon purchase record: ${addonPurchase.id} with quantity: ${quantity}`);

        // Grant credits to the organization
        try {
          const { subscriptionService: subService } = await import("./subscriptionService");
          
          // Calculate expiration date based on subscription renewal date
          // Addon pack credits should expire with the subscription plan
          let expiresAt: Date | undefined = undefined;
          if (instanceSub.subscriptionRenewalDate) {
            expiresAt = new Date(instanceSub.subscriptionRenewalDate);
            console.log(`[Process Session] Setting addon pack credits expiration to subscription renewal date: ${expiresAt.toISOString()}`);
          } else {
            // If no renewal date set, calculate based on billing cycle
            const renewalDate = new Date();
            if (instanceSub.billingCycle === "annual") {
              renewalDate.setFullYear(renewalDate.getFullYear() + 1);
            } else {
              renewalDate.setMonth(renewalDate.getMonth() + 1);
            }
            expiresAt = renewalDate;
            console.log(`[Process Session] Calculated addon pack credits expiration based on ${instanceSub.billingCycle} billing cycle: ${expiresAt.toISOString()}`);
          }
          
          console.log(`[Process Session] Granting ${quantity} credits to organization ${user.organizationId} for addon pack ${packId} (expires: ${expiresAt.toISOString()})`);
          
          const creditBatch = await subService.grantCredits(
            user.organizationId,
            quantity,
            "addon_pack",
            expiresAt, // Expire with subscription plan
            {
              addonPurchaseId: addonPurchase.id,
              adminNotes: `Addon pack purchase via Stripe session: ${sessionId}`,
              createdBy: user.id
            },
            pricePerInspection
          );

          console.log(`[Process Session] Successfully granted ${quantity} credits to organization ${user.organizationId} for pack ${packId}. Credit batch ID: ${creditBatch.id}`);
          
          // Verify credits were granted by checking credit balance
          const creditBalance = await storage.getCreditBalance(user.organizationId);
          console.log(`[Process Session] Credit balance after grant: total=${creditBalance.total}, current=${creditBalance.current}`);
          
          return res.json({ 
            message: "Addon pack purchased and credits granted successfully", 
            processed: true, 
            creditsGranted: quantity,
            creditBalance: creditBalance.total
          });
        } catch (creditError: any) {
          console.error(`[Process Session] ERROR granting credits to organization ${user.organizationId}:`, creditError);
          console.error(`[Process Session] Error details:`, {
            message: creditError.message,
            stack: creditError.stack,
            name: creditError.name
          });
          // Still return error status but include purchase ID for manual credit grant if needed
          return res.status(500).json({ 
            message: "Purchase recorded but credits grant failed", 
            error: creditError.message,
            processed: true,
            purchaseId: addonPurchase.id,
            quantity: quantity
          });
        }
      }

      console.log(`[Process Session] Extracted data:`, {
        organizationId, planId, tierId, planCode, billingPeriod,
        requestedInspections: parsedRequested,
        includedCredits: parsedIncluded,
        isTestMode
      });

      // CRITICAL SECURITY CHECK: Double-verify the organizationId in metadata matches the user's org
      if (organizationId !== user.organizationId) {
        console.error(`[Process Session] SECURITY: Metadata org mismatch - Metadata org: ${organizationId}, User org: ${user.organizationId}`);
        return res.status(403).json({ message: "Session metadata does not match your organization" });
      }

      // Validate metadata (allow quotation subscriptions, module purchases, addon pack purchases, and bundle purchases to pass)
      if (!planId && !topupOrderId && !tierId && 
          session.metadata?.type !== "quotation_subscription" && 
          session.metadata?.type !== "module_purchase" && 
          session.metadata?.type !== "addon_pack_purchase" &&
          session.metadata?.type !== "bundle_purchase") {
        console.error(`[Process Session] Missing required metadata: planId=${planId}, topupOrderId=${topupOrderId}, tierId=${tierId}, type=${session.metadata?.type}`);
        return res.status(400).json({ message: "Session metadata is incomplete. Missing planId, topupOrderId or tierId." });
      }

      // Check if this is a top-up payment (one-time) vs subscription
      if (topupOrderId && packSize) {
        // Check if already processed
        const existingOrder = await storage.getTopupOrder(topupOrderId);
        if (existingOrder && existingOrder.status === "paid") {
          console.log(`[Process Session] Top-up already processed: ${topupOrderId}`);
          return res.json({ message: "Already processed", processed: true });
        }

        // CRITICAL SECURITY CHECK: Verify the top-up order belongs to this organization
        if (existingOrder && existingOrder.organizationId !== user.organizationId) {
          console.error(`[Process Session] SECURITY: Top-up order org mismatch - Order org: ${existingOrder.organizationId}, User org: ${user.organizationId}`);
          return res.status(403).json({ message: "Top-up order does not belong to your organization" });
        }

        if (!existingOrder) {
          console.error(`[Process Session] Top-up order not found: ${topupOrderId}`);
          return res.status(404).json({ message: "Top-up order not found" });
        }

        // Handle top-up payment
        console.log(`[Process Session] Processing top-up of ${packSize} credits for verified org ${user.organizationId}`);

        await storage.updateTopupOrder(topupOrderId, {
          status: "paid" as any,
        });

        // Grant credits to the VERIFIED organization (user.organizationId) not the metadata
        const { subscriptionService: subService } = await import("./subscriptionService");
        await subService.grantCredits(
          user.organizationId,
          parseInt(packSize),
          "topup",
          undefined,
          { topupOrderId, adminNotes: `Stripe session: ${sessionId}`, createdBy: user.id }
        );

        console.log(`[Process Session] Granted ${packSize} credits to verified org ${user.organizationId}`);
        return res.json({ message: "Credits granted successfully", processed: true });
      }

      // Handle the new 2026 Subscription Model (Tier based)
      if (tierId) {
        try {
          console.log(`[Process Session] ========================================`);
          console.log(`[Process Session] Processing 2026 Model Tier: ${tierId} for org ${user.organizationId}`);
          console.log(`[Process Session] Session ID: ${sessionId}`);
          console.log(`[Process Session] Session subscription ID: ${session.subscription}`);
          console.log(`[Process Session] ========================================`);

          const tiers = await storage.getSubscriptionTiers();
          const tier = tiers.find(t => t.id === tierId);
          if (!tier) {
            throw new Error(`Tier not found: ${tierId}`);
          }

          // IMPORTANT: Cancel all existing active Stripe subscriptions for this organization
          // This ensures only the latest plan is active, preventing double billing on renewal
          const tierOrg = await storage.getOrganization(user.organizationId);
          if (!tierOrg?.stripeCustomerId) {
            console.warn(`[Process Session] âš ï¸  Organization ${user.organizationId} has no stripeCustomerId - cannot cancel old subscriptions`);
          } else {
            try {
              console.log(`[Process Session] Looking for subscriptions for customer: ${tierOrg.stripeCustomerId}`);
              console.log(`[Process Session] New subscription ID from session: ${session.subscription}`);
              
              // Get ALL subscriptions (not just active) to catch edge cases
              // Note: Cannot expand more than 4 levels, so we'll fetch product data separately if needed
              const allSubscriptions = await stripe.subscriptions.list({
                customer: tierOrg.stripeCustomerId,
                limit: 100,
                expand: ['data.items.data.price'] // Only expand to price level, fetch product separately
              });
              
              console.log(`[Process Session] Found ${allSubscriptions.data.length} total subscriptions for customer ${tierOrg.stripeCustomerId}`);
              
              // Filter to only active subscriptions for cancellation
              const activeSubscriptions = allSubscriptions.data.filter(sub => sub.status === "active");
              console.log(`[Process Session] Found ${activeSubscriptions.length} active subscriptions to check`);

              // Only cancel tier subscriptions, NOT module subscriptions
              // Modules are separate subscriptions and should coexist with tier subscriptions
              // Get all tier names to help identify tier subscriptions by product name
              const tiers = await storage.getSubscriptionTiers();
              const tierNames = tiers.map(t => t.name);
              
              console.log(`[Process Session] Checking ${activeSubscriptions.length} active subscriptions for tier cancellation`);
              
              for (const sub of activeSubscriptions) {
                // Skip the new subscription being created
                if (sub.id === (session.subscription as string)) {
                  console.log(`[Process Session] Skipping new subscription ${sub.id}`);
                  continue;
                }
                
                // Only process active subscriptions (skip canceled, incomplete, etc.)
                if (sub.status !== "active") {
                  console.log(`[Process Session] Skipping subscription ${sub.id} with status: ${sub.status}`);
                  continue;
                }
                
                // Check if this is a tier subscription (not a module subscription)
                // Check both metadata AND product names for reliable identification
                const subMetadata = sub.metadata || {};
                
                // Check metadata first
                const hasTierMetadata = subMetadata.tierId || subMetadata.planCode || 
                                       (subMetadata.type === "tier_subscription");
                
                // Check product names to identify tier subscriptions (for older subscriptions without metadata)
                let hasTierProductName = false;
                let foundProductNames: string[] = [];
                const items = sub.items?.data || [];
                
                // AGGRESSIVE DETECTION: Check ALL line items in the subscription
                for (const item of items) {
                  // Try multiple ways to get the product name
                  let productName = '';
                  
                  // Method 1: Get from product object (if expanded)
                  const product = item.price?.product;
                  if (typeof product === 'object' && product && 'name' in product) {
                    productName = product.name || '';
                  } else if (typeof product === 'string') {
                    // Product is just an ID, need to fetch it separately
                    try {
                      const productObj = await stripe.products.retrieve(product);
                      productName = productObj.name || '';
                    } catch (e) {
                      // If fetch fails, continue with other methods
                      console.log(`[Process Session] Could not fetch product ${product}, trying other methods`);
                    }
                  }
                  
                  // Method 2: Get from price nickname
                  if (!productName && item.price?.nickname) {
                    productName = item.price.nickname;
                  }
                  
                  // Method 3: Get from price description
                  if (!productName && item.price?.product && typeof item.price.product === 'object') {
                    const prod = item.price.product as any;
                    if (prod.description) {
                      productName = prod.description;
                    }
                  }
                  
                  if (productName) {
                    foundProductNames.push(productName);
                    const nameLower = productName.toLowerCase();
                    
                    // AGGRESSIVE MATCHING: Any subscription with "Inspect360" and "Plan" is a tier subscription
                    // This catches: "Inspect360 Growth Plan", "Inspect360 Starter Plan", etc.
                    if (nameLower.includes('inspect360') && nameLower.includes('plan')) {
                      hasTierProductName = true;
                      console.log(`[Process Session] âœ… MATCHED tier subscription by product name: "${productName}"`);
                      break; // Found it, no need to check other items
                    }
                    
                    // Also match "Additional Inspections" as these are part of tier subscriptions
                    if (nameLower.includes('additional') && nameLower.includes('inspection')) {
                      hasTierProductName = true;
                      console.log(`[Process Session] âœ… MATCHED tier subscription with additional inspections: "${productName}"`);
                      break;
                    }
                    
                    // Match tier keywords even without "Plan" (for edge cases)
                    if (nameLower.includes('inspect360') && 
                        (nameLower.includes('starter') || nameLower.includes('growth') || 
                         nameLower.includes('professional') || nameLower.includes('enterprise'))) {
                      hasTierProductName = true;
                      console.log(`[Process Session] âœ… MATCHED tier subscription by keyword: "${productName}"`);
                      break;
                    }
                  }
                }
                
                // FINAL CHECK: If subscription has ANY product with "Inspect360" and "Plan", it's a tier subscription
                // This is a catch-all for edge cases
                let hasInspect360Plan = false;
                for (const productName of foundProductNames) {
                  const nameLower = productName.toLowerCase();
                  if (nameLower.includes('inspect360') && nameLower.includes('plan')) {
                    hasInspect360Plan = true;
                    break;
                  }
                }
                
                // If we found "Inspect360" and "Plan" but didn't match earlier, still consider it a tier
                if (hasInspect360Plan && !hasTierProductName) {
                  hasTierProductName = true;
                  console.log(`[Process Session] âœ… FALLBACK: Matched tier subscription by "Inspect360" + "Plan" pattern`);
                }
                
                const isTierSubscription = hasTierMetadata || hasTierProductName || hasInspect360Plan;
                const isModuleSubscription = subMetadata.type === "module_purchase" ||
                                           subMetadata.moduleId;
                
                // Log what we found for debugging
                console.log(`[Process Session] ðŸ“‹ Subscription ${sub.id}:`);
                console.log(`   - Status: ${sub.status}`);
                console.log(`   - Customer: ${sub.customer}`);
                console.log(`   - Metadata: ${JSON.stringify(subMetadata)}`);
                console.log(`   - Products: [${foundProductNames.join(', ')}]`);
                console.log(`   - Has tier metadata: ${hasTierMetadata}`);
                console.log(`   - Has tier product name: ${hasTierProductName}`);
                console.log(`   - Has Inspect360+Plan pattern: ${hasInspect360Plan}`);
                console.log(`   - Is tier subscription: ${isTierSubscription}`);
                console.log(`   - Is module subscription: ${isModuleSubscription}`);
                
                // Only cancel tier subscriptions, preserve module subscriptions
                if (isTierSubscription && !isModuleSubscription) {
                  console.log(`[Process Session] ðŸš« CANCELLING tier subscription ${sub.id} for org ${user.organizationId}`);
                  console.log(`[Process Session]    Reason: ${hasTierMetadata ? 'metadata' : hasTierProductName ? 'product name' : 'Inspect360+Plan pattern'}`);
                  console.log(`[Process Session]    Subscription details:`, {
                    id: sub.id,
                    status: sub.status,
                    cancel_at_period_end: (sub as any).cancel_at_period_end,
                    current_period_end: sub.current_period_end,
                    items: sub.items.data.map((item: any) => ({
                      product: typeof item.price?.product === 'object' ? (item.price.product as any)?.name : item.price?.product,
                      price: item.price?.id
                    }))
                  });
                  
                  try {
                    // Check if already scheduled to cancel
                    if ((sub as any).cancel_at_period_end === true) {
                      console.log(`[Process Session] âš ï¸  Subscription ${sub.id} is already scheduled to cancel at period end`);
                      // Force immediate cancellation instead
                      console.log(`[Process Session]    Forcing immediate cancellation...`);
                    }
                    
                    // Cancel immediately (not at period end) since this is a replacement subscription
                    const cancelResult = await stripe.subscriptions.cancel(sub.id);
                    console.log(`[Process Session] âœ… Successfully cancelled tier subscription ${sub.id}`);
                    console.log(`[Process Session]    Cancel result:`, {
                      id: cancelResult.id,
                      status: cancelResult.status,
                      canceled_at: cancelResult.canceled_at,
                      cancel_at_period_end: cancelResult.cancel_at_period_end
                    });
                  } catch (cancelError: any) {
                    console.error(`[Process Session] âŒ Failed to cancel subscription ${sub.id}:`, cancelError.message);
                    console.error(`[Process Session]    Error type: ${cancelError.type}`);
                    console.error(`[Process Session]    Error code: ${cancelError.code}`);
                    console.error(`[Process Session]    Error message: ${cancelError.message}`);
                    console.error(`[Process Session]    Full error:`, JSON.stringify(cancelError, null, 2));
                    
                    // Try alternative: schedule cancellation at period end if immediate cancel fails
                    if (cancelError.code !== 'resource_missing') {
                      try {
                        console.log(`[Process Session]    Attempting to schedule cancellation at period end instead...`);
                        await stripe.subscriptions.update(sub.id, {
                          cancel_at_period_end: true
                        });
                        console.log(`[Process Session]    âœ… Scheduled cancellation at period end as fallback`);
                      } catch (updateError: any) {
                        console.error(`[Process Session]    âŒ Fallback cancellation also failed:`, updateError.message);
                      }
                    }
                    // Continue with new subscription creation even if cancellation fails
                  }
                } else if (isModuleSubscription) {
                  console.log(`[Process Session] âœ… Preserving module subscription ${sub.id}`);
                } else {
                  console.log(`[Process Session] âš ï¸  Preserving unknown subscription ${sub.id} (not identified as tier or module)`);
                  console.log(`[Process Session]    This subscription will NOT be cancelled. If this is a tier subscription, please check the logs above.`);
                  console.log(`[Process Session]    To help debug, here's what we found:`, {
                    metadata: subMetadata,
                    productNames: foundProductNames,
                    hasTierMetadata,
                    hasTierProductName,
                    hasInspect360Plan
                  });
                }
              }
              
              // Final summary
              console.log(`[Process Session] ========================================`);
              console.log(`[Process Session] Cancellation check complete for org ${user.organizationId}`);
              console.log(`[Process Session] ========================================`);
            } catch (listError: any) {
              console.error(`[Process Session] âŒ Error listing subscriptions:`, listError.message);
              console.error(`[Process Session]    Full error:`, JSON.stringify(listError, null, 2));
              // Continue with new subscription creation even if listing fails
            }
          }

          // Update Instance Subscriptions table
          const existingInstanceSub = await storage.getInstanceSubscription(user.organizationId);
          
          // CRITICAL: Update subscription metadata from checkout session metadata
          // Stripe doesn't automatically transfer checkout session metadata to subscription metadata
          if (session.subscription) {
            try {
              console.log(`[Process Session] Updating subscription ${session.subscription} metadata from checkout session`);
              await stripe.subscriptions.update(session.subscription as string, {
                metadata: {
                  ...session.metadata,
                  // Ensure type is set for identification
                  type: "tier_subscription",
                  tierId: tierId,
                  planCode: tier.code, // Use tier variable that's already defined in scope
                }
              });
              console.log(`[Process Session] âœ… Successfully updated subscription metadata`);
            } catch (metadataError: any) {
              console.error(`[Process Session] âš ï¸  Failed to update subscription metadata:`, metadataError.message);
              // Continue even if metadata update fails
            }
          }
          
          // Get renewal date from Stripe subscription if available (source of truth)
          // Use Stripe's current_period_end to ensure accuracy (matches actual billing cycle)
          let renewalDate: Date;
          if (session.subscription) {
            try {
              const stripeSubscription = await stripe.subscriptions.retrieve(session.subscription as string);
              renewalDate = new Date(((stripeSubscription as any).current_period_end as number) * 1000);
              console.log(`[Process Session] Using Stripe subscription period_end for renewal date: ${renewalDate.toISOString()} (billing period: ${billingPeriod})`);
            } catch (subscriptionError: any) {
              console.warn(`[Process Session] Could not retrieve subscription ${session.subscription} for renewal date, using calculated fallback:`, subscriptionError.message);
              // Fallback to calculated date if subscription retrieval fails
              renewalDate = new Date(Date.now() + (billingPeriod === "annual" ? 365 : 30) * 24 * 60 * 60 * 1000);
              console.log(`[Process Session] Using calculated fallback renewal date: ${renewalDate.toISOString()}`);
            }
          } else {
            // Fallback to calculated date if no subscription ID in session (test mode or edge case)
            renewalDate = new Date(Date.now() + (billingPeriod === "annual" ? 365 : 30) * 24 * 60 * 60 * 1000);
            console.log(`[Process Session] No subscription ID in session, using calculated renewal date: ${renewalDate.toISOString()} (billing period: ${billingPeriod})`);
          }

          // Determine inspections to grant (use requested amount if present, otherwise tier default)
          // requestedInspections should be the TOTAL count (tier included + additional)
          const actualInspections = (!isNaN(parsedRequested)) ? parsedRequested : (tier.includedInspections || 0);
          console.log(`[Process Session] Granting total inspections: ${actualInspections} (Requested: ${parsedRequested}, Tier default: ${tier.includedInspections})`);

          if (existingInstanceSub) {
            await storage.updateInstanceSubscription(existingInstanceSub.id, {
              currentTierId: tier.id,
              inspectionQuotaIncluded: actualInspections,
              billingCycle: billingPeriod as any,
              registrationCurrency: currency as any,
              subscriptionStatus: "active",
              subscriptionRenewalDate: renewalDate
            });
          } else {
            await storage.createInstanceSubscription({
              organizationId: user.organizationId,
              registrationCurrency: currency as any,
              currentTierId: tier.id,
              inspectionQuotaIncluded: actualInspections,
              billingCycle: billingPeriod as any,
              subscriptionStatus: "active",
              subscriptionRenewalDate: renewalDate,
              subscriptionStartDate: new Date()
            });
          }


          console.log(`[Process Session] 2026 Tier ${tier.name} activated for org ${user.organizationId}`);

          // Update subscription metadata to include module information (if modules were included in checkout)
          // This helps the renewal webhook identify which modules are already in the subscription
          if (session.subscription && session.metadata?.moduleNames) {
            try {
              const stripeSubscriptionForMetadata = await stripe.subscriptions.retrieve(session.subscription as string);
              await stripe.subscriptions.update(session.subscription as string, {
                metadata: {
                  ...stripeSubscriptionForMetadata.metadata,
                  moduleNames: session.metadata.moduleNames,
                  moduleCount: session.metadata.moduleCount || "0"
                }
              });
              console.log(`[Process Session] Updated subscription metadata with module information: ${session.metadata.moduleNames}`);
            } catch (metadataError: any) {
              console.warn(`[Process Session] Failed to update subscription metadata:`, metadataError.message);
              // Don't fail the process if metadata update fails
            }
          }

          // IMPORTANT: Grant initial credits within transaction to ensure atomicity with subscription creation/update
          // Logic: 
          // - If subscription renewal date has passed (expired) â†’ RESET credits (expire old, grant new)
          // - If subscription renewal date has NOT passed (still active) â†’ APPEND credits (keep old, add new)
          try {
            const { subscriptionService: subService } = await import("./subscriptionService");
            const { db } = await import("./db");
            
            // Wrap credit granting in transaction to ensure atomicity with subscription
            await db.transaction(async (tx) => {
            const now = new Date();
            const shouldReset = existingInstanceSub 
              ? (!existingInstanceSub.subscriptionRenewalDate || existingInstanceSub.subscriptionRenewalDate <= now)
              : false; // New subscription, no reset needed

            if (shouldReset) {
              // Subscription has expired - RESET credits (expire old, grant new)
              console.log(`[Process Session] Subscription expired (renewal date: ${existingInstanceSub?.subscriptionRenewalDate?.toISOString()}), resetting credits for org ${user.organizationId}`);
              
                const existingBatches = await storage.getCreditBatchesByOrganization(user.organizationId!);
              const planBatches = existingBatches.filter(b => 
                b.grantSource === 'plan_inclusion' && 
                b.remainingQuantity > 0
              );

              if (planBatches.length > 0) {
                console.log(`[Process Session] Expiring ${planBatches.length} existing plan_inclusion batches for org ${user.organizationId} (subscription expired)`);
                for (const batch of planBatches) {
                  await storage.expireCreditBatch(batch.id);
                  await storage.createCreditLedgerEntry({
                      organizationId: user.organizationId!,
                    source: "expiry" as any,
                    quantity: -batch.remainingQuantity,
                      batchId: (batch.id ?? undefined) as string | undefined,
                    notes: `Expired ${batch.remainingQuantity} credits due to subscription expiry (renewal date passed)`
                  });
                }
              }
            } else if (existingInstanceSub) {
              // Subscription still active - APPEND credits (keep old, add new)
              console.log(`[Process Session] Subscription still active (renewal date: ${existingInstanceSub.subscriptionRenewalDate?.toISOString()}), appending credits for org ${user.organizationId}`);
            }

            console.log(`[Process Session] Granting ${actualInspections} credits to org ${user.organizationId} (${shouldReset ? 'RESET mode' : 'APPEND mode'})`);

              // Grant credits within transaction
            await subService.grantCredits(
                user.organizationId!,
              actualInspections,
              "plan_inclusion",
              renewalDate,
                { createdBy: user.id, adminNotes: `Stripe session: ${sessionId ?? 'unknown'} (Requested: ${parsedRequested || 'tier default'})` }
            );
            console.log(`[Process Session] Granted ${actualInspections} credits successfully for tier ${tier.name} (${shouldReset ? 'after reset' : 'appended to existing'})`);
            });
          } catch (creditError: any) {
            console.error(`[Process Session] Error granting credits for tier:`, creditError);
            // Transaction will rollback automatically, but we should still throw to prevent subscription activation without credits
            throw new Error(`Failed to grant credits: ${creditError.message}`);
          }

          return res.json({ message: "Tier subscription activated successfully", processed: true });
        } catch (tierError: any) {
          console.error(`[Process Session] Error in tier processing:`, tierError);
          throw tierError;
        }
      }

      // Handle legacy subscription payment
      if (planId) {
        try {
          // Check if subscription already exists by organization (prevent duplicates)
          const existingOrgSubscription = await storage.getSubscriptionByOrganization(user.organizationId);
          if (existingOrgSubscription) {
            console.log(`[Process Session] Organization already has subscription, skipping duplicate`);
            return res.json({ message: "Organization already has active subscription", processed: true, alreadyProcessed: true });
          }

          // IMPORTANT: Cancel all existing active Stripe subscriptions for this organization
          // This ensures only the latest plan is active, preventing double billing on renewal
          const legacyOrg = await storage.getOrganization(user.organizationId);
          if (legacyOrg?.stripeCustomerId) {
            try {
              const allSubscriptions = await stripe.subscriptions.list({
                customer: legacyOrg.stripeCustomerId,
                status: "active",
                limit: 100
              });

              // Cancel all active subscriptions before creating the new one
              for (const sub of allSubscriptions.data) {
                if (sub.status === "active") {
                  console.log(`[Process Session] Cancelling existing subscription ${sub.id} for org ${user.organizationId} before creating new subscription`);
                  try {
                    await stripe.subscriptions.cancel(sub.id);
                    console.log(`[Process Session] Successfully cancelled existing subscription ${sub.id}`);
                  } catch (cancelError: any) {
                    console.error(`[Process Session] Failed to cancel subscription ${sub.id}:`, cancelError.message);
                    // Continue with new subscription creation even if cancellation fails
                  }
                }
              }
            } catch (listError: any) {
              console.error(`[Process Session] Error listing subscriptions:`, listError.message);
              // Continue with new subscription creation even if listing fails
            }
          }

          // Handle subscription ID - might not exist in test mode
          let subscriptionId = session.subscription as string | null;
          let subscription: any = null;

          if (subscriptionId) {
            // Check if subscription already exists by Stripe subscription ID
            const existingSubscription = await storage.getSubscriptionByStripeId(subscriptionId);
            if (existingSubscription) {
              console.log(`[Process Session] Subscription already exists: ${subscriptionId}`);
              return res.json({ message: "Subscription already activated", processed: true, alreadyProcessed: true });
            }

            // Try to retrieve subscription from Stripe
            try {
              subscription = await stripe.subscriptions.retrieve(subscriptionId);
              console.log(`[Process Session] Retrieved subscription from Stripe: ${subscriptionId}`);
            } catch (error: any) {
              console.warn(`[Process Session] Could not retrieve subscription ${subscriptionId}: ${error.message}`);
              if (!isTestMode) {
                throw new Error(`Failed to retrieve subscription: ${error.message}`);
              }
              // In test mode, continue without subscription object
              console.log(`[Process Session] TEST MODE: Continuing without Stripe subscription object`);
            }
          } else if (isTestMode) {
            // In test mode, create a mock subscription ID if none exists
            subscriptionId = `sub_test_${Date.now()}_${user.organizationId}`;
            console.log(`[Process Session] TEST MODE: Using mock subscription ID: ${subscriptionId}`);
          } else {
            return res.status(400).json({ message: "No subscription found in session" });
          }

          console.log(`[Process Session] Creating subscription from session for verified org ${user.organizationId}${isTestMode ? " (TEST MODE)" : ""}`);

          // Update organization with Stripe customer ID (use VERIFIED org)
          if (session.customer) {
            try {
              await storage.updateOrganizationStripe(user.organizationId, session.customer as string, "active");
            } catch (error: any) {
              console.warn(`[Process Session] Could not update organization Stripe: ${error.message}`);
            }
          }

          // Get plan details
          const plan = await storage.getPlan(planId);
          if (!plan) {
            throw new Error(`Plan not found: ${planId}`);
          }

          // Get organization for pricing
          const orgForPricing = await storage.getOrganization(user.organizationId);
          let pricing: any = null;
          if (orgForPricing) {
            try {
              const { subscriptionService: subService } = await import("./subscriptionService");
              pricing = await subService.getEffectivePricing(plan.id, orgForPricing.countryCode || "GB");
            } catch (error: any) {
              console.warn(`[Process Session] Could not get pricing: ${error.message}, using plan defaults`);
            }
          }

          // Calculate period dates
          const now = new Date();
          const interval = billingPeriod || "month";

          // Helper function to safely create Date from Stripe timestamp
          const safeDateFromTimestamp = (timestamp: any, fallback: Date): Date => {
            if (!timestamp || typeof timestamp !== 'number' || isNaN(timestamp)) {
              return fallback;
            }
            const date = new Date(timestamp * 1000);
            return isNaN(date.getTime()) ? fallback : date;
          };

          const periodStart = subscription
            ? safeDateFromTimestamp((subscription as any).current_period_start, now)
            : now;
          const periodEnd = subscription
            ? safeDateFromTimestamp((subscription as any).current_period_end,
              new Date(now.getTime() + (interval === "year" ? 365 : 30) * 24 * 60 * 60 * 1000))
            : new Date(now.getTime() + (interval === "year" ? 365 : 30) * 24 * 60 * 60 * 1000);
          const billingCycleAnchor = subscription
            ? safeDateFromTimestamp((subscription as any).billing_cycle_anchor, now)
            : now;

          // Get price from subscription or plan
          const monthlyPrice = subscription?.items?.data?.[0]?.price?.unit_amount
            || (pricing?.monthlyPrice)
            || plan.monthlyPriceGbp;

          // Validate includedCredits
          const creditsToGrant = parseInt(includedCredits || "0");
          if (!creditsToGrant || isNaN(creditsToGrant)) {
            throw new Error(`Invalid includedCredits: ${includedCredits}`);
          }

          // Create subscription record (use VERIFIED org)
          console.log(`[Process Session] Creating subscription with data:`, {
            organizationId: user.organizationId,
            planId: plan.id,
            planCode: plan.code,
            planName: plan.name,
            monthlyPrice: monthlyPrice,
            includedCredits: creditsToGrant,
            stripeSubscriptionId: subscriptionId,
            status: (subscription?.status || "active")
          });

          const createdSubscription = await storage.createSubscription({
            organizationId: user.organizationId,
            planSnapshotJson: {
              planId: plan.id,
              planCode: plan.code,
              planName: plan.name,
              monthlyPrice: monthlyPrice,
              includedCredits: creditsToGrant,
              includedInspections: plan.includedCredits, // Use includedCredits as includedInspections
              currency: (subscription?.currency || pricing?.currency || "GBP").toUpperCase(),
            },
            stripeSubscriptionId: subscriptionId,
            billingCycleAnchor: billingCycleAnchor,
            currentPeriodStart: periodStart,
            currentPeriodEnd: periodEnd,
            status: (subscription?.status || "active") as any,
            cancelAtPeriodEnd: subscription?.cancel_at_period_end || false,
          });

          console.log(`[Process Session] Subscription created successfully:`, {
            id: createdSubscription.id,
            organizationId: createdSubscription.organizationId,
            planName: createdSubscription.planSnapshotJson?.planName,
            status: createdSubscription.status
          });

          // Small delay to ensure database transaction is committed
          await new Promise(resolve => setTimeout(resolve, 100));

          // Verify subscription was saved by fetching it back
          const verifySubscription = await storage.getSubscriptionByOrganization(user.organizationId);
          if (!verifySubscription) {
            console.error(`[Process Session] ERROR: Subscription was created but cannot be retrieved!`);
            console.error(`[Process Session] Created subscription ID: ${createdSubscription.id}`);
            console.error(`[Process Session] Organization ID: ${user.organizationId}`);
            throw new Error("Subscription was created but cannot be retrieved");
          }
          console.log(`[Process Session] Verified subscription exists in database:`, {
            id: verifySubscription.id,
            organizationId: verifySubscription.organizationId,
            planName: verifySubscription.planSnapshotJson?.planName,
            status: verifySubscription.status
          });

          // Grant initial credits (use VERIFIED org)
          try {
            const { subscriptionService: subService } = await import("./subscriptionService");
            await subService.grantCredits(
              user.organizationId,
              creditsToGrant,
              "plan_inclusion",
              periodEnd,
              { subscriptionId: subscriptionId, createdBy: user.id, adminNotes: isTestMode ? "TEST MODE - No payment charged" : undefined }
            );
            console.log(`[Process Session] Granted ${creditsToGrant} credits successfully`);
          } catch (creditError: any) {
            console.error(`[Process Session] Error granting credits:`, creditError);
            // Don't fail the whole request if credits fail - subscription is already created
            console.warn(`[Process Session] Continuing despite credit grant error`);
          }

          console.log(`[Process Session] Created subscription and granted ${creditsToGrant} credits to verified org ${user.organizationId}${isTestMode ? " (TEST MODE)" : ""}`);
          return res.json({ message: "Subscription activated successfully", processed: true });
        } catch (subscriptionError: any) {
          console.error(`[Process Session] Error in subscription processing:`, subscriptionError);
          console.error(`[Process Session] Subscription error stack:`, subscriptionError.stack);
          throw subscriptionError; // Re-throw to be caught by outer catch
        }
      }

      res.json({ message: "Session processed", processed: false });
    } catch (error: any) {
      console.error("[Process Session] Error processing session:", error);
      console.error("[Process Session] Error stack:", error.stack);
      console.error("[Process Session] Error details:", {
        message: error.message,
        type: error.type,
        code: error.code,
        statusCode: error.statusCode
      });
      res.status(500).json({
        message: "Failed to process session",
        error: error.message,
        details: process.env.NODE_ENV === "development" ? error.stack : undefined
      });
    }
  });

  // Stripe webhook handler
  app.post("/api/billing/webhook", async (req, res) => {
    const sig = req.headers["stripe-signature"] as string;

    let event: any;
    try {
      // Verify webhook signature if secret is configured
      const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
      if (webhookSecret && sig) {
        const stripe = await getUncachableStripeClient();
        try {
          event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
          console.log(`[Stripe Webhook] Signature verified for event: ${event.type}`);
        } catch (err: any) {
          console.error(`[Stripe Webhook] Signature verification failed:`, err.message);
          return res.status(400).json({ message: "Webhook signature verification failed" });
        }
      } else {
        // In development without webhook secret, accept raw body
        event = typeof req.body === 'string' ? JSON.parse(req.body) : req.body;
        console.log(`[Stripe Webhook] Received event (unverified): ${event.type}`);
      }

      console.log(`[Stripe Webhook] Processing event: ${event.type}`);

      switch (event.type) {
        case "checkout.session.completed": {
          const session = event.data.object;
          const { organizationId, planId, includedCredits, topupOrderId, packSize } = session.metadata;

          console.log(`[Stripe Webhook] Checkout completed:`, {
            organizationId,
            planId,
            topupOrderId,
            packSize,
            sessionId: session.id,
            mode: session.mode
          });

          // CRITICAL SECURITY CHECK: Verify organization exists
          const org = await storage.getOrganization(organizationId);
          if (!org) {
            console.error(`[Stripe Webhook] SECURITY: Organization not found: ${organizationId}`);
            break;
          }

          // Check if this is a top-up payment (one-time) vs subscription
          if (topupOrderId && packSize) {
            // CRITICAL SECURITY CHECK: Verify top-up order belongs to this organization
            const topupOrder = await storage.getTopupOrder(topupOrderId);
            if (!topupOrder) {
              console.error(`[Stripe Webhook] SECURITY: Top-up order not found: ${topupOrderId}`);
              break;
            }
            if (topupOrder.organizationId !== organizationId) {
              console.error(`[Stripe Webhook] SECURITY: Top-up order org mismatch - Order org: ${topupOrder.organizationId}, Session org: ${organizationId}`);
              break;
            }

            // Check if already processed
            if (topupOrder.status === "paid") {
              console.log(`[Stripe Webhook] Top-up already processed: ${topupOrderId}`);
              break;
            }

            // Handle top-up payment
            console.log(`[Stripe Webhook] Processing top-up of ${packSize} credits for verified org: ${organizationId}`);

            // Update top-up order status
            await storage.updateTopupOrder(topupOrderId, {
              status: "paid" as any,
            });

            // Grant credits to VERIFIED organization
            const { subscriptionService: subService } = await import("./subscriptionService");
            await subService.grantCredits(
              organizationId,
              parseInt(packSize),
              "topup",
              undefined,
              { topupOrderId, adminNotes: `Stripe webhook session: ${session.id}` }
            );

            // Send credit top-up notification
            try {
              const org = await storage.getOrganization(organizationId);
              const instanceSub = await storage.getInstanceSubscription(organizationId);
              const currency = instanceSub?.registrationCurrency || org?.preferredCurrency || "GBP";
              const amount = session.amount_total || 0;
              
              const { notificationService } = await import("./notificationService");
              await notificationService.sendCreditTopUpNotification(
                organizationId,
                parseInt(packSize),
                amount,
                currency
              );
            } catch (notifError) {
              console.error(`[Stripe Webhook] Failed to send credit top-up notification:`, notifError);
            }

            console.log(`[Stripe Webhook] Granted ${packSize} credits to verified org ${organizationId} via top-up`);
            break;
          }

          // Handle module purchase
          if (session.metadata.type === "module_purchase") {
            const { organizationId, moduleId, billingCycle, isProrated, fullPrice, proratedPrice, remainingDays } = session.metadata;
            console.log(`[Stripe Webhook] Processing module purchase for org ${organizationId}: ${moduleId}`);

            if (!moduleId || !organizationId) {
              console.error(`[Stripe Webhook] Missing moduleId or organizationId in webhook metadata`);
              break;
            }

            // Get or create instance subscription
            let instanceSub = await storage.getInstanceSubscription(organizationId);
            if (!instanceSub) {
              const org = await storage.getOrganization(organizationId);
              if (!org) {
                console.error(`[Stripe Webhook] Organization ${organizationId} not found`);
                break;
              }
              instanceSub = await storage.createInstanceSubscription({
                organizationId,
                registrationCurrency: org?.preferredCurrency || "GBP",
                inspectionQuotaIncluded: 0,
                billingCycle: "monthly",
                subscriptionStatus: "active"
              });
            }

            // Get currency from subscription or organization, fallback to GBP
            const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
            const modulePricing = await storage.getModulePricing(moduleId, currency);

            if (modulePricing) {
              // Idempotency check: Verify module is not already enabled (prevents duplicate webhook processing)
              const instanceModulesList = await storage.getInstanceModules(instanceSub.id);
              const existingModule = instanceModulesList.find(im => im.moduleId === moduleId && im.isEnabled);
              
              if (existingModule) {
                // Check if this is a duplicate webhook call
                console.log(`[Stripe Webhook] Module ${moduleId} already enabled for org ${organizationId} - skipping duplicate webhook`);
                break;
              }

              // Enable the module for this instance
              await storage.toggleInstanceModule(instanceSub.id, moduleId, true);

              // Update instance module with pricing info
              const { instanceModules: instanceModulesTable } = await import("@shared/schema");
              const { db } = await import("./db");
              const { eq } = await import("drizzle-orm");
              // Re-fetch to get the updated module after toggle
              const updatedInstanceModulesList = await storage.getInstanceModules(instanceSub.id);
              const instanceModule = updatedInstanceModulesList.find(im => im.moduleId === moduleId);
              if (instanceModule) {
                await db.update(instanceModulesTable)
                  .set({
                    monthlyPrice: modulePricing.priceMonthly,
                    annualPrice: modulePricing.priceAnnual,
                    currencyCode: currency,
                    billingStartDate: new Date()
                  })
                  .where(eq(instanceModulesTable.id, instanceModule.id));
              }
              
              // Log proration information
              if (isProrated === "true" && fullPrice && proratedPrice && remainingDays) {
                console.log(`[Stripe Webhook] Module ${moduleId} enabled for org ${organizationId} (PRO-RATED)`);
                console.log(`[Stripe Webhook] Full price: ${parseInt(fullPrice)/100} ${currency}, Prorated: ${parseInt(proratedPrice)/100} ${currency}, Remaining days: ${remainingDays}`);
                console.log(`[Stripe Webhook] Savings: ${(parseInt(fullPrice) - parseInt(proratedPrice))/100} ${currency}`);
              } else {
                console.log(`[Stripe Webhook] Module ${moduleId} enabled for org ${organizationId} (full price)`);
              }

              // Send module purchased notification
              try {
                const modules = await storage.getMarketplaceModules();
                const module = modules.find(m => m.id === moduleId);
                const moduleName = module?.name || moduleId;
                const billingCycle = instanceSub.billingCycle || "monthly";
                const modulePrice = billingCycle === "annual" ? modulePricing.priceAnnual : modulePricing.priceMonthly;
                
                const { notificationService } = await import("./notificationService");
                await notificationService.sendModulePurchasedNotification(
                  organizationId,
                  moduleName,
                  modulePrice,
                  currency,
                  billingCycle
                );
              } catch (notifError) {
                console.error(`[Stripe Webhook] Failed to send module purchased notification:`, notifError);
              }
            } else {
              console.error(`[Stripe Webhook] Module pricing not found for module ${moduleId} in currency ${currency}`);
            }
            break;
          }

          // Handle bundle purchase
          if (session.metadata.type === "bundle_purchase") {
            const { organizationId, bundleId, billingCycle, isProrated, fullPrice, proratedPrice, remainingDays } = session.metadata;
            console.log(`[Stripe Webhook] Processing bundle purchase for org ${organizationId}: ${bundleId}`);

            if (!bundleId || !organizationId) {
              console.error(`[Stripe Webhook] Missing bundleId or organizationId in webhook metadata`);
              break;
            }

            const instanceSub = await storage.getInstanceSubscription(organizationId);
            if (!instanceSub) {
              console.error(`[Stripe Webhook] Instance subscription not found for org ${organizationId}`);
              break;
            }

            // Check if bundle already exists
            const existingBundles = await storage.getInstanceBundles(instanceSub.id);
            const existingBundle = existingBundles.find(ib => ib.bundleId === bundleId && ib.isActive);
            if (existingBundle) {
              console.log(`[Stripe Webhook] Bundle ${bundleId} already active for org ${organizationId}`);
              break;
            }

            // Get bundle details
            const bundles = await storage.getModuleBundles();
            const bundle = bundles.find(b => b.id === bundleId);
            if (!bundle) {
              console.error(`[Stripe Webhook] Bundle ${bundleId} not found`);
              break;
            }

            // Get currency from subscription or organization, fallback to GBP
            const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
            const bundlePricing = await storage.getBundlePricing(bundleId, currency);
            if (!bundlePricing) {
              console.error(`[Stripe Webhook] Bundle pricing not configured for bundle ${bundleId} in currency ${currency}`);
              break;
            }

            // Import required tables and db
            const { instanceBundles, instanceModules: instanceModulesTable } = await import("@shared/schema");
            const { db } = await import("./db");
            const { eq, and } = await import("drizzle-orm");

            // Use transaction to ensure atomicity: bundle creation + all module enables succeed or all fail
            await db.transaction(async (tx) => {
            // Create instance bundle record with pricing
              await tx.insert(instanceBundles).values({
              instanceId: instanceSub.id,
              bundleId: bundleId,
              isActive: true,
              startDate: new Date(),
              purchaseDate: new Date(),
              bundlePriceMonthly: bundlePricing.priceMonthly,
              bundlePriceAnnual: bundlePricing.priceAnnual,
              currencyCode: currency
            });

            // Enable all modules in the bundle and set their prices to 0 (bundle covers the cost)
              // All operations are done within the transaction to ensure atomicity
            const bundleModules = await storage.getBundleModules(bundleId);
              const enabledModuleIds: string[] = [];
              
            for (const bm of bundleModules) {
                try {
                  // Check if module instance already exists (using transaction context)
                  const existingModules = await tx.select()
                    .from(instanceModulesTable)
                    .where(and(
                      eq(instanceModulesTable.instanceId, instanceSub.id),
                      eq(instanceModulesTable.moduleId, bm.moduleId)
                    ))
                    .limit(1);
                  
                  const existingModule = existingModules[0];
                  
                  if (existingModule) {
                    // Update existing module: enable it and set price to 0 (bundle covers the cost)
                    await tx.update(instanceModulesTable)
                  .set({
                        isEnabled: true,
                        enabledDate: new Date(),
                        disabledDate: null,
                    monthlyPrice: 0, // Bundle covers the cost
                    annualPrice: 0,
                    currencyCode: currency,
                    billingStartDate: new Date()
                  })
                      .where(eq(instanceModulesTable.id, existingModule.id));
                  } else {
                    // Insert new module instance: enabled with price 0 (bundle covers the cost)
                    await tx.insert(instanceModulesTable)
                      .values({
                        instanceId: instanceSub.id,
                        moduleId: bm.moduleId,
                        isEnabled: true,
                        enabledDate: new Date(),
                        monthlyPrice: 0, // Bundle covers the cost
                        annualPrice: 0,
                        currencyCode: currency,
                        billingStartDate: new Date()
                      });
              }
                  
                  enabledModuleIds.push(bm.moduleId);
                } catch (moduleError: any) {
                  console.error(`[Stripe Webhook] Failed to enable module ${bm.moduleId} in bundle ${bundleId}:`, moduleError);
                  // Transaction will rollback automatically on error
                  throw new Error(`Failed to enable module ${bm.moduleId}: ${moduleError.message}`);
                }
              }
              
              console.log(`[Stripe Webhook] Successfully enabled ${enabledModuleIds.length} modules for bundle ${bundleId}`);
            });

            // Log proration information
            if (isProrated === "true" && fullPrice && proratedPrice && remainingDays) {
              console.log(`[Stripe Webhook] Bundle ${bundle.name} enabled for org ${organizationId} (PRO-RATED)`);
              console.log(`[Stripe Webhook] Full price: ${parseInt(fullPrice)/100} ${currency}, Prorated: ${parseInt(proratedPrice)/100} ${currency}, Remaining days: ${remainingDays}`);
            } else {
              console.log(`[Stripe Webhook] Bundle ${bundle.name} enabled for org ${organizationId} (full price)`);
            }

            break;
          }

          // Handle add-on pack purchase
          if (session.metadata.type === "addon_pack_purchase") {
            const organizationId = session.metadata?.organizationId;
            console.log(`[Stripe Webhook] Processing addon pack purchase for organization ${organizationId}`);
            
            const packId = session.metadata?.packId;
            const tierIdAtPurchase = session.metadata?.tierIdAtPurchase;
            let quantity = parseInt(session.metadata?.quantity || "0");
            const pricePerInspection = parseInt(session.metadata?.pricePerInspection || "0");
            const totalPrice = parseInt(session.metadata?.totalPrice || "0");
            const currency = session.metadata?.currency || "GBP";

            // Verify quantity matches the actual pack inspectionQuantity
            const packs = await storage.getAddonPacks();
            const pack = packs.find(p => p.id === packId);
            if (pack && pack.inspectionQuantity !== quantity) {
              console.error(`[Stripe Webhook] QUANTITY MISMATCH: Pack ${packId} has inspectionQuantity=${pack.inspectionQuantity}, but metadata says quantity=${quantity}. Using pack.inspectionQuantity.`);
              quantity = pack.inspectionQuantity;
            }

            console.log(`[Stripe Webhook] Addon pack purchase details - PackId: ${packId}, Quantity: ${quantity}, OrganizationId: ${organizationId}, TierId: ${tierIdAtPurchase}, PackName: ${pack?.name || 'N/A'}`);

            if (!packId || !organizationId || !tierIdAtPurchase) {
              console.error(`[Stripe Webhook] Missing required fields - PackId: ${packId}, OrganizationId: ${organizationId}, TierId: ${tierIdAtPurchase}`);
              break;
            }

            if (quantity <= 0) {
              console.error(`[Stripe Webhook] Invalid quantity: ${quantity}`);
              break;
            }

            // Get or create instance subscription
            let instanceSub = await storage.getInstanceSubscription(organizationId);
            if (!instanceSub) {
              const org = await storage.getOrganization(organizationId);
              if (!org) {
                console.error(`[Stripe Webhook] Organization ${organizationId} not found`);
                break;
              }
              instanceSub = await storage.createInstanceSubscription({
                organizationId,
                registrationCurrency: currency,
                inspectionQuotaIncluded: 0,
                billingCycle: "monthly",
                subscriptionStatus: "active"
              });
            }

            // Create add-on purchase record
            const addonPurchase = await storage.createInstanceAddonPurchase({
              instanceId: instanceSub.id,
              packId,
              tierIdAtPurchase,
              quantity,
              pricePerInspection,
              totalPrice,
              currencyCode: currency,
              inspectionsRemaining: quantity,
              status: "active"
            });

            // Grant credits to the organization
            try {
              const { subscriptionService } = await import("./subscriptionService");
              await subscriptionService.grantCredits(
                organizationId,
                quantity,
                "addon_pack",
                undefined, // No expiration date for addon packs
                {
                  addonPurchaseId: addonPurchase.id,
                },
                pricePerInspection
              );

              console.log(`[Stripe Webhook] Successfully granted ${quantity} credits to organization ${organizationId} for pack ${packId}`);
            } catch (creditError: any) {
              console.error(`[Stripe Webhook] ERROR granting credits to organization ${organizationId}:`, creditError);
              // Don't throw - log the error but still mark purchase as successful
              // The purchase record is already created, so we can retry credit granting later if needed
            }
            break;
          }

          // Handle legacy credit purchase (if credits metadata exists but no type specified)
          if (session.metadata.credits && !session.metadata.type) {
            const organizationId = session.metadata.organizationId;
            const credits = parseInt(session.metadata.credits);

            if (organizationId && credits > 0) {
              // Grant credits using credit batch system
              const { subscriptionService } = await import("./subscriptionService");
              await subscriptionService.grantCredits(
                organizationId,
                credits,
                "topup",
                undefined, // No expiration for topup credits
                {
                  topupOrderId: session.metadata.topupOrderId || undefined,
                  adminNotes: `Purchased ${credits} credits via Stripe`,
                }
              );
              console.log(`[Stripe Webhook] Granted ${credits} legacy credits to organization ${organizationId}`);
            }
            break;
          }

          // Handle subscription payment
          if (session.subscription && planId) {
            // CRITICAL SECURITY CHECK: Verify customer matches organization
            if (session.customer !== org.stripeCustomerId) {
              console.error(`[Stripe Webhook] SECURITY: Customer mismatch - Session customer: ${session.customer}, Org customer: ${org.stripeCustomerId}`);
              // Update org with new customer ID if it's empty
              if (!org.stripeCustomerId) {
                console.log(`[Stripe Webhook] Updating org ${organizationId} with customer ${session.customer}`);
                await storage.updateOrganizationStripe(organizationId, session.customer, "active");
              } else {
                break; // Reject if customer mismatch and org already has a customer
              }
            }

            // Check if subscription already exists
            const existingSubscription = await storage.getSubscriptionByStripeId(session.subscription);
            if (existingSubscription) {
              console.log(`[Stripe Webhook] Subscription already exists: ${session.subscription}`);
              break;
            }

            const stripe = await getUncachableStripeClient();
            const subscription = await stripe.subscriptions.retrieve(session.subscription);
            const plan = await storage.getPlan(planId);

            if (plan) {
              console.log(`[Stripe Webhook] Creating subscription for verified org ${organizationId}`);

              // Helper function to safely create Date from Stripe timestamp
              const safeDateFromTimestamp = (timestamp: any, fallback: Date): Date => {
                if (!timestamp || typeof timestamp !== 'number' || isNaN(timestamp)) {
                  return fallback;
                }
                const date = new Date(timestamp * 1000);
                return isNaN(date.getTime()) ? fallback : date;
              };

              const now = new Date();
              const defaultPeriodEnd = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // 30 days default

              await storage.createSubscription({
                organizationId,
                planSnapshotJson: {
                  planId: plan.id,
                  planCode: plan.code,
                  planName: plan.name,
                  monthlyPrice: plan.monthlyPriceGbp,
                  includedCredits: parseInt(includedCredits),
                  includedInspections: parseInt(includedCredits), // Use includedCredits as includedInspections
                  currency: (subscription as any).currency.toUpperCase(),
                },
                stripeSubscriptionId: (subscription as any).id,
                billingCycleAnchor: safeDateFromTimestamp((subscription as any).billing_cycle_anchor, now),
                currentPeriodStart: safeDateFromTimestamp((subscription as any).current_period_start, now),
                currentPeriodEnd: safeDateFromTimestamp((subscription as any).current_period_end, defaultPeriodEnd),
                status: (subscription as any).status as any,
                cancelAtPeriodEnd: (subscription as any).cancel_at_period_end || false,
              });

              // Grant initial credits to VERIFIED organization
              const { subscriptionService: subService } = await import("./subscriptionService");
              await subService.grantCredits(
                organizationId,
                parseInt(includedCredits),
                "plan_inclusion",
                new Date((subscription as any).current_period_end * 1000),
                { subscriptionId: (subscription as any).id }
              );

              console.log(`[Stripe Webhook] Granted ${includedCredits} credits to verified org ${organizationId}`);
            }
          }
          break;
        }

        case "invoice.paid": {
          const invoice = event.data.object;

          if (invoice.subscription) {
            const stripe = await getUncachableStripeClient();
            const subscription = await stripe.subscriptions.retrieve(invoice.subscription);
            
            // Check if subscription is cancelled at period end - if so, don't grant new credits
            if (subscription.cancel_at_period_end) {
              console.log(`[Stripe Webhook] Subscription cancelled at period end - processing final invoice without granting new credits`);
              
              // Still process rollover to preserve unused credits until deletion
              const tierId = subscription.metadata?.tierId;
              const organizationId = subscription.metadata?.organizationId;
              
              if (tierId && organizationId) {
                const instanceSub = await storage.getInstanceSubscription(organizationId);
                if (instanceSub) {
                  const periodEnd = new Date((subscription as any).current_period_end * 1000);
                  const { subscriptionService: subService } = await import("./subscriptionService");
                  await subService.processCreditExpiry(organizationId, periodEnd);
                  console.log(`[Stripe Webhook] Processed credit expiry for cancelled subscription (final invoice) for org ${organizationId}`);
                }
              } else {
                // Legacy subscription
                const dbSubscription = await storage.getSubscriptionByStripeId(subscription.id);
                if (dbSubscription) {
                  const periodEnd = new Date((subscription as any).current_period_end * 1000);
                  const { subscriptionService: subService } = await import("./subscriptionService");
                  await subService.processCreditExpiry(dbSubscription.organizationId, periodEnd);
                  console.log(`[Stripe Webhook] Processed credit expiry for cancelled legacy subscription (final invoice) for org ${dbSubscription.organizationId}`);
                }
              }
              
              break; // Don't grant new credits or update renewal date - subscription is ending
            }
            
            // Check if this is a tier-based subscription (2026 model) or legacy subscription
            const tierId = subscription.metadata?.tierId;
            const organizationId = subscription.metadata?.organizationId;
            
            // Handle tier-based subscription renewal
            if (tierId && organizationId) {
              console.log(`[Stripe Webhook] Processing tier-based subscription renewal for org ${organizationId}, tier ${tierId}`);
              
              const instanceSub = await storage.getInstanceSubscription(organizationId);
              
              // IMPORTANT: Check if subscription is cancelled - if so, don't grant credits or renew modules
              if (subscription.cancel_at_period_end || subscription.status === "canceled") {
                console.log(`[Stripe Webhook] Subscription is cancelled - skipping credit grant and module renewal for org ${organizationId}`);
                
                if (instanceSub) {
                  // Update subscription status to inactive if not already
                  if (instanceSub.subscriptionStatus === "active") {
                    await storage.updateInstanceSubscription(instanceSub.id, {
                      subscriptionStatus: "inactive" as any,
                    });
                    console.log(`[Stripe Webhook] Updated instance subscription status to inactive for cancelled subscription (org ${organizationId})`);
                  }
                  
                  // IMPORTANT: Deactivate all modules when subscription is cancelled
                  const instanceModules = await storage.getInstanceModules(instanceSub.id);
                  const enabledModules = instanceModules.filter(m => m.isEnabled);
                  
                  if (enabledModules.length > 0) {
                    console.log(`[Stripe Webhook] Deactivating ${enabledModules.length} modules for cancelled subscription (org ${organizationId})`);
                    for (const instanceModule of enabledModules) {
                      await storage.toggleInstanceModule(instanceSub.id, instanceModule.moduleId, false);
                      console.log(`[Stripe Webhook] Deactivated module ${instanceModule.moduleId} for cancelled subscription (org ${organizationId})`);
                    }
                  }
                }
                
                break; // Don't process renewal - subscription is cancelled
              }
              
              if (instanceSub && instanceSub.subscriptionStatus === "active") {
                // IMPORTANT: Clear payment failure date if payment succeeded (recovered from failure)
                if (instanceSub.firstPaymentFailureDate) {
                  console.log(`[Stripe Webhook] Payment succeeded for org ${organizationId} - clearing payment failure date (recovered from grace period)`);
                  await storage.updateInstanceSubscription(instanceSub.id, {
                    firstPaymentFailureDate: null,
                  });
                  // Update local reference
                  instanceSub.firstPaymentFailureDate = null;
                }
                
                // Helper function to safely create Date from Stripe timestamp
                const safeDateFromTimestamp = (timestamp: any, fallback: Date): Date => {
                  if (!timestamp || typeof timestamp !== 'number' || isNaN(timestamp)) {
                    return fallback;
                  }
                  const date = new Date(timestamp * 1000);
                  return isNaN(date.getTime()) ? fallback : date;
                };

                const now = new Date();
                const periodEnd = safeDateFromTimestamp((subscription as any).current_period_end, instanceSub.subscriptionRenewalDate || now);
                
                // Update renewal date
                const nextRenewalDate = new Date(periodEnd);
                if (instanceSub.billingCycle === "monthly") {
                  nextRenewalDate.setMonth(nextRenewalDate.getMonth() + 1);
                } else {
                  nextRenewalDate.setFullYear(nextRenewalDate.getFullYear() + 1);
                }
                
                await storage.updateInstanceSubscription(instanceSub.id, {
                  subscriptionRenewalDate: nextRenewalDate
                });

                // Process rollover and reset quota
                const { subscriptionService: subService } = await import("./subscriptionService");
                const quotaToGrant = instanceSub.inspectionQuotaIncluded || 0;
                
                console.log(`[Stripe Webhook] Processing tier renewal for org ${organizationId}, quota: ${quotaToGrant}`);

                // Process credit expiry first
                await subService.processCreditExpiry(organizationId, periodEnd);

                // Expire all existing plan_inclusion batches to reset quota (including any that weren't expired by processCreditExpiry)
                const existingBatches = await storage.getCreditBatchesByOrganization(organizationId);
                const planBatches = existingBatches.filter(b => 
                  b.grantSource === 'plan_inclusion' && 
                  b.remainingQuantity > 0
                );

                if (planBatches.length > 0) {
                  console.log(`[Stripe Webhook] Resetting ${planBatches.length} existing plan_inclusion batches for org ${organizationId} (no rollover)`);
                  for (const batch of planBatches) {
                    await storage.expireCreditBatch(batch.id);
                    await storage.createCreditLedgerEntry({
                      organizationId,
                      source: "expiry" as any,
                      quantity: -batch.remainingQuantity,
                      batchId: batch.id,
                      notes: `Expired ${batch.remainingQuantity} credits due to tier subscription renewal (no rollover)`
                    });
                  }
                }

                // Grant new cycle credits
                await subService.grantCredits(
                  organizationId,
                  quotaToGrant,
                  "plan_inclusion",
                  periodEnd,
                  { subscriptionId: (subscription as any).id }
                );

                // Add invoice items for enabled modules for NEXT billing cycle
                // IMPORTANT: Only add invoice items for modules that are NOT already part of the subscription
                // If modules were added as line items during checkout, Stripe will automatically charge for them on renewal
                try {
                  const org = await storage.getOrganization(organizationId);
                  if (org?.stripeCustomerId) {
                    const instanceModules = await storage.getInstanceModules(instanceSub.id);
                    const enabledModules = instanceModules.filter(m => m.isEnabled);
                    const modules = await storage.getMarketplaceModules();
                    const { pricingService } = await import("./pricingService");
                    // Get currency from subscription or organization, fallback to GBP
      const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
                    
                    // Get active bundles to exclude modules covered by bundles
                    const coveredModuleIds = await pricingService.getBundledModuleIds(instanceSub.id);

                    // Check which modules are already part of the subscription
                    // Modules can be included in two ways:
                    // 1. As line items in the subscription (Stripe charges automatically on renewal)
                    // 2. As invoice items (we need to add them manually each cycle)
                    // 
                    // IMPORTANT: Also check if modules in subscription are disabled - if so, remove them
                    // We check subscription metadata first (if modules were added during checkout, their names are stored there)
                    // Then we check subscription line items by matching product names
                    const modulesInSubscription = new Set<string>();
                    const modulesToRemoveFromSubscription: Array<{ itemId: string; moduleId: string; moduleName: string }> = [];
                    
                    // Method 1: Check subscription metadata for module names
                    const subscriptionModuleNames = subscription.metadata?.moduleNames;
                    if (subscriptionModuleNames) {
                      const moduleNameList = subscriptionModuleNames.split(',').filter(Boolean);
                      console.log(`[Stripe Webhook] Found ${moduleNameList.length} modules in subscription metadata: ${moduleNameList.join(', ')}`);
                      
                      // Match module names to module IDs and check if they're still enabled
                      for (const moduleName of moduleNameList) {
                        const matchedModule = modules.find(m => m.name === moduleName.trim());
                        if (matchedModule) {
                          // Check if module is still enabled
                          const instanceModule = enabledModules.find(im => im.moduleId === matchedModule.id);
                          if (instanceModule && instanceModule.isEnabled) {
                            modulesInSubscription.add(matchedModule.id);
                            console.log(`[Stripe Webhook] Module ${matchedModule.name} (${matchedModule.id}) is in subscription metadata and still enabled - will be charged automatically on renewal`);
                          } else {
                            console.log(`[Stripe Webhook] Module ${matchedModule.name} (${matchedModule.id}) is in subscription metadata but disabled - will be removed from subscription`);
                            // Mark for removal - we'll find the subscription item below
                          }
                        }
                      }
                    }
                    
                    // Method 2: Check subscription line items by matching product names
                    // IMPORTANT: Also check if modules are disabled and remove them from subscription
                    const subscriptionLineItems = subscription.items?.data || [];
                    for (const item of subscriptionLineItems) {
                      const product = item.price?.product;
                      const productName = (typeof product === 'object' && product && 'name' in product) 
                        ? (product.name || '') 
                        : (item.price?.nickname || '');
                      
                      // Skip if this is the tier subscription (not a module)
                      // Check if product name contains "Plan" or "Inspect360" to identify tier subscription
                      if (productName && (productName.includes('Plan') || productName.includes('Inspect360'))) {
                        continue;
                      }
                      
                      if (productName) {
                        // Try to match product name to module name
                        const matchedModule = modules.find(m => 
                          m.name === productName.trim() || 
                          productName.includes(m.name)
                        );
                        
                        if (matchedModule) {
                          // Check if module is still enabled
                          const instanceModule = enabledModules.find(im => im.moduleId === matchedModule.id);
                          
                          if (instanceModule && instanceModule.isEnabled) {
                            // Module is enabled - add to set and will be charged automatically
                            if (!modulesInSubscription.has(matchedModule.id)) {
                              modulesInSubscription.add(matchedModule.id);
                              console.log(`[Stripe Webhook] Module ${matchedModule.name} (${matchedModule.id}) found in subscription line items and enabled - will be charged automatically on renewal`);
                            }
                          } else {
                            // Module is disabled but still in subscription - mark for removal
                            modulesToRemoveFromSubscription.push({
                              itemId: item.id,
                              moduleId: matchedModule.id,
                              moduleName: matchedModule.name
                            });
                            console.log(`[Stripe Webhook] Module ${matchedModule.name} (${matchedModule.id}) is in subscription but disabled - will be removed from subscription`);
                          }
                        }
                      }
                    }
                    
                    // Remove disabled modules from subscription
                    if (modulesToRemoveFromSubscription.length > 0 && org.stripeCustomerId) {
                      try {
                        for (const moduleToRemove of modulesToRemoveFromSubscription) {
                          console.log(`[Stripe Webhook] Removing disabled module ${moduleToRemove.moduleName} (${moduleToRemove.moduleId}) from subscription ${subscription.id}`);
                          await stripe.subscriptionItems.del(moduleToRemove.itemId);
                          console.log(`[Stripe Webhook] Successfully removed disabled module ${moduleToRemove.moduleName} from subscription`);
                        }
                        
                        // Update subscription metadata to remove disabled module names
                        if (subscriptionModuleNames) {
                          const moduleNameList = subscriptionModuleNames.split(',').filter(Boolean);
                          const removedModuleNames = modulesToRemoveFromSubscription.map(m => m.moduleName);
                          const updatedModuleNames = moduleNameList
                            .filter(name => !removedModuleNames.includes(name.trim()))
                            .join(',');
                          
                          await stripe.subscriptions.update(subscription.id, {
                            metadata: {
                              ...subscription.metadata,
                              moduleNames: updatedModuleNames,
                              moduleCount: updatedModuleNames ? updatedModuleNames.split(',').length.toString() : "0"
                            }
                          });
                          console.log(`[Stripe Webhook] Updated subscription metadata - removed ${removedModuleNames.length} disabled modules`);
                        }
                      } catch (removeError: any) {
                        console.error(`[Stripe Webhook] Failed to remove disabled modules from subscription:`, removeError.message);
                        // Don't fail renewal if module removal fails
                      }
                    }

                    if (enabledModules.length > 0) {
                      const stripe = await getUncachableStripeClient();
                      
                      for (const instanceModule of enabledModules) {
                        // Skip if module is covered by a bundle
                        if (coveredModuleIds.has(instanceModule.moduleId)) {
                          continue;
                        }

                        // Skip if module is already part of subscription (Stripe will charge automatically)
                        if (modulesInSubscription.has(instanceModule.moduleId)) {
                          console.log(`[Stripe Webhook] Skipping invoice item for ${instanceModule.moduleId} - already in subscription line items`);
                          continue;
                        }

                        const module = modules.find(m => m.id === instanceModule.moduleId);
                        if (!module) continue;

                        // Calculate full cycle price (not prorated) for next billing cycle
                        // Only add invoice items for modules NOT in subscription
                        const modulePrice = await pricingService.calculateModulePrice(
                          organizationId,
                          instanceModule.moduleId,
                          instanceSub.billingCycle
                        );

                        if (modulePrice > 0) {
                          try {
                            await stripe.invoiceItems.create({
                              customer: org.stripeCustomerId,
                              amount: modulePrice, // Full cycle price in minor units
                              currency: currency.toLowerCase(),
                              description: `${module.name} (${instanceSub.billingCycle} billing)`,
                              metadata: {
                                organizationId: organizationId,
                                moduleId: instanceModule.moduleId,
                                moduleName: module.name,
                                type: "module_renewal",
                                billingCycle: instanceSub.billingCycle || "monthly"
                              }
                            });
                            console.log(`[Stripe Webhook] Added module charge for ${module.name} (${modulePrice/100} ${currency}) to next renewal invoice for org ${organizationId}`);
                          } catch (moduleError: any) {
                            console.error(`[Stripe Webhook] Failed to add module charge for ${module.name}:`, moduleError.message);
                            // Don't fail renewal if module invoice item creation fails
                          }
                        }
                      }
                    }
                    
                    // Log summary of module handling
                    const modulesInSubCount = modulesInSubscription.size;
                    const modulesAsInvoiceItems = enabledModules.filter(m => 
                      !coveredModuleIds.has(m.moduleId) && !modulesInSubscription.has(m.moduleId)
                    ).length;
                    console.log(`[Stripe Webhook] Renewal module summary: ${modulesInSubCount} in subscription (auto-charged), ${modulesAsInvoiceItems} as invoice items, ${enabledModules.length} total enabled`);

                    // IMPORTANT: Check if bundles in subscription are deactivated and remove them
                    // Bundles can be in subscription as line items
                    const bundlesToRemoveFromSubscription: Array<{ itemId: string; bundleId: string; bundleName: string }> = [];
                    const subscriptionLineItemsForBundles = subscription.items?.data || [];
                    const bundles = await storage.getModuleBundles();
                    const activeBundles = await storage.getInstanceBundles(instanceSub.id);
                    
                    for (const item of subscriptionLineItemsForBundles) {
                      const product = item.price?.product;
                      const productName = (typeof product === 'object' && product && 'name' in product) 
                        ? (product.name || '') 
                        : (item.price?.nickname || '');
                      
                      // Skip if this is the tier subscription (not a bundle)
                      // Check if product name contains "Plan" or "Inspect360" to identify tier subscription
                      if (productName && (productName.includes('Plan') || productName.includes('Inspect360'))) {
                        continue;
                      }
                      
                      // Check if this might be a bundle (contains "Bundle" in name)
                      if (productName && productName.includes('Bundle')) {
                        const matchedBundle = bundles.find(b => 
                          productName.includes(b.name) || b.name === productName.trim()
                        );
                        
                        if (matchedBundle) {
                          // Check if bundle is still active
                          const instanceBundle = activeBundles.find(ib => 
                            ib.bundleId === matchedBundle.id && ib.isActive
                          );
                          
                          if (!instanceBundle || !instanceBundle.isActive) {
                            // Bundle is deactivated but still in subscription - mark for removal
                            bundlesToRemoveFromSubscription.push({
                              itemId: item.id,
                              bundleId: matchedBundle.id,
                              bundleName: matchedBundle.name
                            });
                            console.log(`[Stripe Webhook] Bundle ${matchedBundle.name} (${matchedBundle.id}) is in subscription but deactivated - will be removed from subscription`);
                          }
                        }
                      }
                    }
                    
                    // Remove deactivated bundles from subscription
                    if (bundlesToRemoveFromSubscription.length > 0 && org.stripeCustomerId) {
                      try {
                        const stripe = await getUncachableStripeClient();
                        for (const bundleToRemove of bundlesToRemoveFromSubscription) {
                          console.log(`[Stripe Webhook] Removing deactivated bundle ${bundleToRemove.bundleName} (${bundleToRemove.bundleId}) from subscription ${subscription.id}`);
                          await stripe.subscriptionItems.del(bundleToRemove.itemId);
                          console.log(`[Stripe Webhook] Successfully removed deactivated bundle ${bundleToRemove.bundleName} from subscription`);
                        }
                        
                        // Update subscription metadata to remove bundle names if present
                        const bundleNames = subscription.metadata?.bundleNames?.split(',').filter(Boolean) || [];
                        if (bundleNames.length > 0) {
                          const removedBundleNames = bundlesToRemoveFromSubscription.map(b => b.bundleName);
                          const updatedBundleNames = bundleNames
                            .filter(name => !removedBundleNames.includes(name.trim()))
                            .join(',');
                          
                          await stripe.subscriptions.update(subscription.id, {
                            metadata: {
                              ...subscription.metadata,
                              bundleNames: updatedBundleNames,
                              bundleCount: updatedBundleNames ? updatedBundleNames.split(',').length.toString() : "0"
                            }
                          });
                          console.log(`[Stripe Webhook] Updated subscription metadata - removed ${removedBundleNames.length} deactivated bundles`);
                        }
                      } catch (removeError: any) {
                        console.error(`[Stripe Webhook] Failed to remove deactivated bundles from subscription:`, removeError.message);
                        // Don't fail renewal if bundle removal fails
                      }
                    }

                    // IMPORTANT: Check which bundles are already in subscription to prevent duplicate charges
                    // Bundles can be in subscription as line items (Stripe charges automatically) or as invoice items (we add manually)
                    const bundlesInSubscription = new Set<string>();
                    const subscriptionBundleNames = subscription.metadata?.bundleNames;
                    if (subscriptionBundleNames) {
                      const bundleNameList = subscriptionBundleNames.split(',').filter(Boolean);
                      for (const bundleName of bundleNameList) {
                        const matchedBundle = bundles.find(b => b.name === bundleName.trim());
                        if (matchedBundle) {
                          bundlesInSubscription.add(matchedBundle.id);
                          console.log(`[Stripe Webhook] Bundle ${matchedBundle.name} (${matchedBundle.id}) is in subscription metadata - will be charged automatically on renewal`);
                        }
                      }
                    }
                    
                    // Also check subscription line items for bundles
                    for (const item of subscriptionLineItemsForBundles) {
                      const product = item.price?.product;
                      const productName = (typeof product === 'object' && product && 'name' in product) 
                        ? (product.name || '') 
                        : (item.price?.nickname || '');
                      
                      if (productName && productName.includes('Bundle')) {
                        const matchedBundle = bundles.find(b => 
                          productName.includes(b.name) || b.name === productName.trim()
                        );
                        
                        if (matchedBundle) {
                          const instanceBundle = activeBundles.find(ib => 
                            ib.bundleId === matchedBundle.id && ib.isActive
                          );
                          
                          // If bundle is active and in subscription, it will be charged automatically
                          if (instanceBundle && instanceBundle.isActive) {
                            bundlesInSubscription.add(matchedBundle.id);
                            console.log(`[Stripe Webhook] Bundle ${matchedBundle.name} (${matchedBundle.id}) found in subscription line items and active - will be charged automatically on renewal`);
                          }
                        }
                      }
                    }

                    // Add invoice items for active bundles for NEXT billing cycle
                    // IMPORTANT: Only add invoice items for bundles NOT already in subscription
                    // Validate bundle availability and pricing before adding charges
                    try {
                      const stripe = await getUncachableStripeClient();
                      
                      for (const activeBundle of activeBundles.filter(b => b.isActive)) {
                        // Skip if bundle is already in subscription (Stripe will charge automatically)
                        if (bundlesInSubscription.has(activeBundle.bundleId)) {
                          console.log(`[Stripe Webhook] Skipping invoice item for bundle ${activeBundle.bundleId} - already in subscription line items`);
                          continue;
                        }
                        // Validation: Check if bundle still exists and is available
                        const bundle = bundles.find(b => b.id === activeBundle.bundleId);
                        
                        if (!bundle) {
                          console.warn(`[Stripe Webhook] Bundle ${activeBundle.bundleId} not found in bundle configuration - deactivating for org ${organizationId}`);
                          // Deactivate bundle that no longer exists
                          const { instanceBundles: instanceBundlesTable } = await import("@shared/schema");
                          const { eq, and } = await import("drizzle-orm");
                          const { db } = await import("./db");
                          await db.update(instanceBundlesTable)
                            .set({ isActive: false, endDate: new Date() })
                            .where(and(
                              eq(instanceBundlesTable.id, activeBundle.id),
                              eq(instanceBundlesTable.isActive, true)
                            ));
                          continue;
                        }
                        
                        if (!bundle.isActive) {
                          console.warn(`[Stripe Webhook] Bundle ${bundle.name} (${activeBundle.bundleId}) is no longer active - deactivating for org ${organizationId}`);
                          // Deactivate bundle that has been discontinued
                          const { instanceBundles: instanceBundlesTable } = await import("@shared/schema");
                          const { eq, and } = await import("drizzle-orm");
                          const { db } = await import("./db");
                          await db.update(instanceBundlesTable)
                            .set({ isActive: false, endDate: new Date() })
                            .where(and(
                              eq(instanceBundlesTable.id, activeBundle.id),
                              eq(instanceBundlesTable.isActive, true)
                            ));
                          continue;
                        }
                        
                          // Edge Case 5: Validate modules are still in bundle configuration
                          const currentBundleModules = await storage.getBundleModules(activeBundle.bundleId);
                          const instanceModules = await storage.getInstanceModules(instanceSub.id);
                          const enabledBundleModules = instanceModules.filter(im => 
                            im.isEnabled && currentBundleModules.some(bm => bm.moduleId === im.moduleId)
                          );
                          
                          if (currentBundleModules.length === 0) {
                            console.warn(`[Stripe Webhook] Bundle ${bundle.name} (${activeBundle.bundleId}) has no modules - deactivating for org ${instanceSub ? instanceSub.organizationId : 'unknown'}`);
                            // Deactivate bundle that has no modules
                            const { instanceBundles: instanceBundlesTable } = await import("@shared/schema");
                            const { eq, and } = await import("drizzle-orm");
                            const { db } = await import("./db");
                            await db.update(instanceBundlesTable)
                              .set({ isActive: false, endDate: new Date() })
                              .where(and(
                                eq(instanceBundlesTable.id, activeBundle.id),
                                eq(instanceBundlesTable.isActive, true)
                              ));
                            continue;
                          }
                          
                          // Edge Case 4: Validate currency hasn't changed
                          if (activeBundle.currencyCode && activeBundle.currencyCode !== currency) {
                            console.warn(`[Stripe Webhook] Currency mismatch for bundle ${bundle.name}: stored ${activeBundle.currencyCode} vs current ${currency}. Using stored currency ${activeBundle.currencyCode}.`);
                            // Use stored currency for pricing calculation
                            const storedCurrency = activeBundle.currencyCode;
                            const bundlePricing = await storage.getBundlePricing(activeBundle.bundleId, storedCurrency);
                            if (!bundlePricing) {
                              console.error(`[Stripe Webhook] Bundle ${bundle.name} has no pricing in stored currency ${storedCurrency} - skipping renewal charge`);
                              continue;
                            }
                          }
                          
                          // IMPORTANT: Use current pricing on renewal (pricing updates apply on next renewal)
                          // Fetch current bundle pricing for renewal
                          let bundlePrice = 0;
                          let pricingChanged = false;
                          const bundleCurrency = activeBundle.currencyCode || currency;
                          
                          const currentBundlePricing = await storage.getBundlePricing(activeBundle.bundleId, bundleCurrency);
                          if (currentBundlePricing) {
                            // Use current pricing for renewal
                            bundlePrice = instanceSub.billingCycle === "annual"
                              ? currentBundlePricing.priceAnnual
                              : currentBundlePricing.priceMonthly;
                            
                            // Check if pricing has changed from stored pricing (for logging and updating stored price)
                            if (activeBundle.bundlePriceMonthly && activeBundle.bundlePriceAnnual) {
                              const storedPrice = instanceSub.billingCycle === "annual" 
                                ? activeBundle.bundlePriceAnnual 
                                : activeBundle.bundlePriceMonthly;
                              
                              if (storedPrice !== bundlePrice) {
                                pricingChanged = true;
                                console.log(`[Stripe Webhook] Bundle ${bundle.name} pricing updated: stored ${storedPrice/100} ${bundleCurrency} â†’ current ${bundlePrice/100} ${bundleCurrency}. Using current price for renewal.`);
                                
                                // Update stored pricing in instance bundle to reflect new price
                                const { instanceBundles: instanceBundlesTable } = await import("@shared/schema");
                                const { eq } = await import("drizzle-orm");
                                const { db } = await import("./db");
                                await db.update(instanceBundlesTable)
                                  .set({
                                    bundlePriceMonthly: currentBundlePricing.priceMonthly,
                                    bundlePriceAnnual: currentBundlePricing.priceAnnual,
                                    currencyCode: bundleCurrency
                                  })
                                  .where(eq(instanceBundlesTable.id, activeBundle.id));
                                console.log(`[Stripe Webhook] Updated stored bundle pricing for instance bundle ${activeBundle.id} to reflect new pricing`);
                              }
                            }
                          } else {
                            // Fallback: use stored pricing if current pricing not available
                            if (activeBundle.bundlePriceMonthly && activeBundle.bundlePriceAnnual) {
                              bundlePrice = instanceSub.billingCycle === "annual" 
                                ? activeBundle.bundlePriceAnnual 
                                : activeBundle.bundlePriceMonthly;
                              console.warn(`[Stripe Webhook] Bundle ${bundle.name} has no current pricing in currency ${bundleCurrency}, using stored pricing: ${bundlePrice/100} ${bundleCurrency}`);
                            } else {
                              console.error(`[Stripe Webhook] Bundle ${bundle.name} (${activeBundle.bundleId}) has no pricing configured in currency ${bundleCurrency} - skipping renewal charge`);
                              continue;
                            }
                          }
                        
                        if (bundlePrice > 0) {
                          try {
                            await stripe.invoiceItems.create({
                              customer: org.stripeCustomerId,
                              amount: bundlePrice, // Full cycle price in minor units
                              currency: currency.toLowerCase(),
                              description: `${bundle.name} Bundle (${instanceSub.billingCycle} billing)${pricingChanged ? ' [Price updated on renewal]' : ''}`,
                              metadata: {
                                organizationId: organizationId,
                                bundleId: activeBundle.bundleId,
                                bundleName: bundle.name,
                                type: "bundle_renewal",
                                billingCycle: instanceSub.billingCycle || "monthly",
                                pricingChanged: pricingChanged.toString()
                              }
                            });
                            console.log(`[Stripe Webhook] Added bundle charge for ${bundle.name} (${bundlePrice/100} ${currency}) to next renewal invoice for org ${organizationId}`);
                          } catch (bundleError: any) {
                            console.error(`[Stripe Webhook] Failed to add bundle charge for ${bundle.name}:`, bundleError.message);
                            // Don't fail renewal if bundle invoice item creation fails
                          }
                        }
                      }
                    } catch (bundleBillingError: any) {
                      console.error(`[Stripe Webhook] Error adding bundle charges for renewal:`, bundleBillingError);
                      // Don't fail renewal if bundle billing fails
                    }
                  }
                } catch (moduleBillingError: any) {
                  console.error(`[Stripe Webhook] Error adding module charges for renewal:`, moduleBillingError);
                  // Don't fail renewal if module billing fails
                }

                console.log(`[Stripe Webhook] Tier renewal complete for org ${organizationId}, granted ${quotaToGrant} credits`);

                // Send subscription renewed notification
                try {
                  const org = await storage.getOrganization(organizationId);
                  const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
                  const invoiceAmount = invoice.amount_paid || 0;
                  
                  const { notificationService } = await import("./notificationService");
                  await notificationService.sendSubscriptionRenewedNotification(
                    organizationId,
                    nextRenewalDate,
                    invoiceAmount,
                    currency,
                    instanceSub.billingCycle || "monthly"
                  );
                } catch (notifError) {
                  console.error(`[Stripe Webhook] Failed to send subscription renewed notification:`, notifError);
                }

                // Send invoice paid notification
                try {
                  const org = await storage.getOrganization(organizationId);
                  const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
                  const invoiceAmount = invoice.amount_paid || 0;
                  
                  const { notificationService } = await import("./notificationService");
                  await notificationService.sendInvoicePaidNotification(
                    organizationId,
                    invoice.id,
                    invoiceAmount,
                    currency,
                    invoice.number || undefined
                  );
                } catch (notifError) {
                  console.error(`[Stripe Webhook] Failed to send invoice paid notification:`, notifError);
                }
              }
              break; // Exit early if handled as tier-based
            }

            // Handle legacy subscription renewal
            const dbSubscription = await storage.getSubscriptionByStripeId(subscription.id);
            if (dbSubscription) {
              // IMPORTANT: Clear payment failure date if payment succeeded (recovered from failure)
              const instanceSubForLegacy = await storage.getInstanceSubscription(dbSubscription.organizationId);
              if (instanceSubForLegacy?.firstPaymentFailureDate) {
                console.log(`[Stripe Webhook] Payment succeeded for org ${dbSubscription.organizationId} (legacy) - clearing payment failure date (recovered from grace period)`);
                await storage.updateInstanceSubscription(instanceSubForLegacy.id, {
                  firstPaymentFailureDate: null,
                });
              }
              
              // IMPORTANT: Check if subscription is cancelled - if so, don't grant credits or renew modules
              if (subscription.cancel_at_period_end || subscription.status === "canceled") {
                console.log(`[Stripe Webhook] Legacy subscription is cancelled - skipping credit grant and module renewal for org ${dbSubscription.organizationId}`);
                
                const instanceSub = await storage.getInstanceSubscription(dbSubscription.organizationId);
                if (instanceSub) {
                  // Update subscription status to inactive if not already
                  if (instanceSub.subscriptionStatus === "active") {
                    await storage.updateInstanceSubscription(instanceSub.id, {
                      subscriptionStatus: "inactive" as any,
                    });
                    console.log(`[Stripe Webhook] Updated instance subscription status to inactive for cancelled legacy subscription (org ${dbSubscription.organizationId})`);
                  }
                  
                  // IMPORTANT: Deactivate all modules when subscription is cancelled
                  const instanceModules = await storage.getInstanceModules(instanceSub.id);
                  const enabledModules = instanceModules.filter(m => m.isEnabled);
                  
                  if (enabledModules.length > 0) {
                    console.log(`[Stripe Webhook] Deactivating ${enabledModules.length} modules for cancelled legacy subscription (org ${dbSubscription.organizationId})`);
                    for (const instanceModule of enabledModules) {
                      await storage.toggleInstanceModule(instanceSub.id, instanceModule.moduleId, false);
                      console.log(`[Stripe Webhook] Deactivated module ${instanceModule.moduleId} for cancelled legacy subscription (org ${dbSubscription.organizationId})`);
                    }
                  }
                }
                
                break; // Don't process renewal - subscription is cancelled
              }
              
              // Helper function to safely create Date from Stripe timestamp
              const safeDateFromTimestamp = (timestamp: any, fallback: Date): Date => {
                if (!timestamp || typeof timestamp !== 'number' || isNaN(timestamp)) {
                  return fallback;
                }
                const date = new Date(timestamp * 1000);
                return isNaN(date.getTime()) ? fallback : date;
              };

              const now = new Date();
              const defaultPeriodEnd = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // 30 days default

              // Update subscription period
              await storage.updateSubscription(dbSubscription.id, {
                currentPeriodStart: safeDateFromTimestamp((subscription as any).current_period_start, dbSubscription.currentPeriodStart || now),
                currentPeriodEnd: safeDateFromTimestamp((subscription as any).current_period_end, dbSubscription.currentPeriodEnd || defaultPeriodEnd),
                status: (subscription as any).status as any,
              });

              // Process rollover and grant new cycle credits
              const { subscriptionService: subService } = await import("./subscriptionService");
              
              // Get current quota from instanceSubscriptions (not old planSnapshotJson)
              const instanceSub = await storage.getInstanceSubscription(dbSubscription.organizationId);
              const quotaToGrant = instanceSub?.inspectionQuotaIncluded || dbSubscription.planSnapshotJson.includedCredits || 0;
              
              console.log(`[Stripe Webhook] Processing renewal for org ${dbSubscription.organizationId}, quota: ${quotaToGrant}`);

              // Process credit expiry first (expires unused credits - no rollover)
              await subService.processCreditExpiry(
                dbSubscription.organizationId,
                new Date((subscription as any).current_period_end * 1000)
              );

              // Expire all existing plan_inclusion batches to reset quota (including any that weren't expired by processCreditExpiry)
              const existingBatches = await storage.getCreditBatchesByOrganization(dbSubscription.organizationId);
              const planBatches = existingBatches.filter(b => 
                b.grantSource === 'plan_inclusion' && 
                b.remainingQuantity > 0
              );

              if (planBatches.length > 0) {
                console.log(`[Stripe Webhook] Resetting ${planBatches.length} existing plan_inclusion batches for org ${dbSubscription.organizationId} (no rollover)`);
                for (const batch of planBatches) {
                  await storage.expireCreditBatch(batch.id);
                  await storage.createCreditLedgerEntry({
                    organizationId: dbSubscription.organizationId,
                    source: "expiry" as any,
                    quantity: -batch.remainingQuantity,
                    batchId: batch.id,
                    notes: `Expired ${batch.remainingQuantity} credits due to subscription renewal (no rollover)`
                  });
                }
              }

              // Grant new cycle credits with current quota
              await subService.grantCredits(
                dbSubscription.organizationId,
                quotaToGrant,
                "plan_inclusion",
                new Date((subscription as any).current_period_end * 1000),
                { subscriptionId: (subscription as any).id }
              );

              // Add invoice items for enabled modules for NEXT billing cycle (legacy subscription)
              // IMPORTANT: Check which modules are already in subscription to prevent duplicate charges
              try {
                const instanceSub = await storage.getInstanceSubscription(dbSubscription.organizationId);
                if (instanceSub) {
                  const org = await storage.getOrganization(dbSubscription.organizationId);
                  if (org?.stripeCustomerId) {
                    const instanceModules = await storage.getInstanceModules(instanceSub.id);
                    const enabledModules = instanceModules.filter(m => m.isEnabled);
                    const modules = await storage.getMarketplaceModules();
                    const { pricingService } = await import("./pricingService");
                    // Get currency from subscription or organization, fallback to GBP
      const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
                    
                    // Get active bundles to exclude modules covered by bundles
                    const coveredModuleIds = await pricingService.getBundledModuleIds(instanceSub.id);

                    // Check which modules are already part of the subscription (legacy)
                    // Modules can be included in two ways:
                    // 1. As line items in the subscription (Stripe charges automatically on renewal)
                    // 2. As invoice items (we need to add them manually each cycle)
                    const modulesInSubscriptionLegacy = new Set<string>();
                    const modulesToRemoveFromSubscriptionLegacy: Array<{ itemId: string; moduleId: string; moduleName: string }> = [];
                    
                    // Method 1: Check subscription metadata for module names
                    const subscriptionModuleNames = subscription.metadata?.moduleNames;
                    if (subscriptionModuleNames) {
                      const moduleNameList = subscriptionModuleNames.split(',').filter(Boolean);
                      console.log(`[Stripe Webhook] Found ${moduleNameList.length} modules in subscription metadata (legacy): ${moduleNameList.join(', ')}`);
                      
                      // Match module names to module IDs and check if they're still enabled
                      for (const moduleName of moduleNameList) {
                        const matchedModule = modules.find(m => m.name === moduleName.trim());
                        if (matchedModule) {
                          // Check if module is still enabled
                          const instanceModule = enabledModules.find(im => im.moduleId === matchedModule.id);
                          if (instanceModule && instanceModule.isEnabled) {
                            modulesInSubscriptionLegacy.add(matchedModule.id);
                            console.log(`[Stripe Webhook] Module ${matchedModule.name} (${matchedModule.id}) is in subscription metadata and still enabled (legacy) - will be charged automatically on renewal`);
                          } else {
                            console.log(`[Stripe Webhook] Module ${matchedModule.name} (${matchedModule.id}) is in subscription metadata but disabled (legacy) - will be removed from subscription`);
                            // Mark for removal - we'll find the subscription item below
                          }
                        }
                      }
                    }
                    
                    // Method 2: Check subscription line items by matching product names (legacy)
                    // IMPORTANT: Also check if modules are disabled and remove them from subscription
                    const subscriptionLineItems = subscription.items?.data || [];
                    for (const item of subscriptionLineItems) {
                      const product = item.price?.product;
                      const productName = (typeof product === 'object' && product && 'name' in product) 
                        ? (product.name || '') 
                        : (item.price?.nickname || '');
                      
                      // Skip if this is the tier subscription (not a module)
                      // Check if product name contains "Plan" or "Inspect360" to identify tier subscription
                      if (productName && (productName.includes('Plan') || productName.includes('Inspect360'))) {
                        continue;
                      }
                      
                      if (productName) {
                        // Try to match product name to module name
                        const matchedModule = modules.find(m => 
                          m.name === productName.trim() || 
                          productName.includes(m.name)
                        );
                        
                        if (matchedModule) {
                          // Check if module is still enabled
                          const instanceModule = enabledModules.find(im => im.moduleId === matchedModule.id);
                          
                          if (instanceModule && instanceModule.isEnabled) {
                            // Module is enabled - add to set and will be charged automatically
                            if (!modulesInSubscriptionLegacy.has(matchedModule.id)) {
                              modulesInSubscriptionLegacy.add(matchedModule.id);
                              console.log(`[Stripe Webhook] Module ${matchedModule.name} (${matchedModule.id}) found in subscription line items and enabled (legacy) - will be charged automatically on renewal`);
                            }
                          } else {
                            // Module is disabled but still in subscription - mark for removal
                            modulesToRemoveFromSubscriptionLegacy.push({
                              itemId: item.id,
                              moduleId: matchedModule.id,
                              moduleName: matchedModule.name
                            });
                            console.log(`[Stripe Webhook] Module ${matchedModule.name} (${matchedModule.id}) is in subscription but disabled (legacy) - will be removed from subscription`);
                          }
                        }
                      }
                    }
                    
                    // Remove disabled modules from subscription (legacy)
                    if (modulesToRemoveFromSubscriptionLegacy.length > 0 && org.stripeCustomerId) {
                      try {
                        const stripe = await getUncachableStripeClient();
                        for (const moduleToRemove of modulesToRemoveFromSubscriptionLegacy) {
                          console.log(`[Stripe Webhook] Removing disabled module ${moduleToRemove.moduleName} (${moduleToRemove.moduleId}) from subscription ${subscription.id} (legacy)`);
                          await stripe.subscriptionItems.del(moduleToRemove.itemId);
                          console.log(`[Stripe Webhook] Successfully removed disabled module ${moduleToRemove.moduleName} from subscription (legacy)`);
                        }
                        
                        // Update subscription metadata to remove disabled module names
                        if (subscriptionModuleNames) {
                          const moduleNameList = subscriptionModuleNames.split(',').filter(Boolean);
                          const removedModuleNames = modulesToRemoveFromSubscriptionLegacy.map(m => m.moduleName);
                          const updatedModuleNames = moduleNameList
                            .filter(name => !removedModuleNames.includes(name.trim()))
                            .join(',');
                          
                          await stripe.subscriptions.update(subscription.id, {
                            metadata: {
                              ...subscription.metadata,
                              moduleNames: updatedModuleNames,
                              moduleCount: updatedModuleNames ? updatedModuleNames.split(',').length.toString() : "0"
                            }
                          });
                          console.log(`[Stripe Webhook] Updated subscription metadata - removed ${removedModuleNames.length} disabled modules (legacy)`);
                        }
                      } catch (removeError: any) {
                        console.error(`[Stripe Webhook] Failed to remove disabled modules from subscription (legacy):`, removeError.message);
                        // Don't fail renewal if module removal fails
                      }
                    }

                    if (enabledModules.length > 0) {
                      const stripe = await getUncachableStripeClient();
                      
                      for (const instanceModule of enabledModules) {
                        // Skip if module is covered by a bundle
                        if (coveredModuleIds.has(instanceModule.moduleId)) {
                          continue;
                        }

                        // Skip if module is already part of subscription (Stripe will charge automatically)
                        if (modulesInSubscriptionLegacy.has(instanceModule.moduleId)) {
                          console.log(`[Stripe Webhook] Skipping invoice item for ${instanceModule.moduleId} (legacy) - already in subscription line items`);
                          continue;
                        }

                        const module = modules.find(m => m.id === instanceModule.moduleId);
                        if (!module) continue;

                        // Calculate full cycle price (not prorated) for next billing cycle
                        // Only add invoice items for modules NOT in subscription
                        const modulePrice = await pricingService.calculateModulePrice(
                          dbSubscription.organizationId,
                          instanceModule.moduleId,
                          instanceSub.billingCycle
                        );

                        if (modulePrice > 0) {
                          try {
                            await stripe.invoiceItems.create({
                              customer: org.stripeCustomerId,
                              amount: modulePrice, // Full cycle price in minor units
                              currency: currency.toLowerCase(),
                              description: `${module.name} (${instanceSub.billingCycle} billing)`,
                              metadata: {
                                organizationId: dbSubscription.organizationId,
                                moduleId: instanceModule.moduleId,
                                moduleName: module.name,
                                type: "module_renewal",
                                billingCycle: instanceSub.billingCycle || "monthly"
                              }
                            });
                            console.log(`[Stripe Webhook] Added module charge for ${module.name} (${modulePrice/100} ${currency}) to next renewal invoice for org ${dbSubscription.organizationId} (legacy)`);
                          } catch (moduleError: any) {
                            console.error(`[Stripe Webhook] Failed to add module charge for ${module.name} (legacy):`, moduleError.message);
                            // Don't fail renewal if module invoice item creation fails
                          }
                        }
                      }
                      
                      // Log summary of module handling (legacy)
                      const modulesInSubCount = modulesInSubscriptionLegacy.size;
                      const modulesAsInvoiceItems = enabledModules.filter(m => 
                        !coveredModuleIds.has(m.moduleId) && !modulesInSubscriptionLegacy.has(m.moduleId)
                      ).length;
                      console.log(`[Stripe Webhook] Renewal module summary (legacy): ${modulesInSubCount} in subscription (auto-charged), ${modulesAsInvoiceItems} as invoice items, ${enabledModules.length} total enabled`);
                    }

                      // Add invoice items for active bundles for NEXT billing cycle (legacy subscription)
                      // IMPORTANT: Check which bundles are already in subscription to prevent duplicate charges
                      // Validate bundle availability and pricing before adding charges
                      try {
                        const activeBundles = await storage.getInstanceBundles(instanceSub.id);
                        const bundles = await storage.getModuleBundles();
                        const stripe = await getUncachableStripeClient();
                        
                        // IMPORTANT: Check which bundles are already in subscription to prevent duplicate charges (legacy)
                        // Bundles can be in subscription as line items (Stripe charges automatically) or as invoice items (we add manually)
                        const bundlesInSubscriptionLegacy = new Set<string>();
                        const subscriptionBundleNamesLegacy = subscription.metadata?.bundleNames;
                        if (subscriptionBundleNamesLegacy) {
                          const bundleNameList = subscriptionBundleNamesLegacy.split(',').filter(Boolean);
                          for (const bundleName of bundleNameList) {
                            const matchedBundle = bundles.find(b => b.name === bundleName.trim());
                            if (matchedBundle) {
                              bundlesInSubscriptionLegacy.add(matchedBundle.id);
                              console.log(`[Stripe Webhook] Bundle ${matchedBundle.name} (${matchedBundle.id}) is in subscription metadata (legacy) - will be charged automatically on renewal`);
                            }
                          }
                        }
                        
                        // Also check subscription line items for bundles (legacy)
                        for (const item of subscription.items?.data || []) {
                          const product = item.price?.product;
                          const productName = (typeof product === 'object' && product && 'name' in product) 
                            ? (product.name || '') 
                            : (item.price?.nickname || '');
                          
                          if (productName && productName.includes('Bundle')) {
                            const matchedBundle = bundles.find(b => 
                              productName.includes(b.name) || b.name === productName.trim()
                            );
                            
                            if (matchedBundle) {
                              const instanceBundle = activeBundles.find(ib => 
                                ib.bundleId === matchedBundle.id && ib.isActive
                              );
                              
                              // If bundle is active and in subscription, it will be charged automatically
                              if (instanceBundle && instanceBundle.isActive) {
                                bundlesInSubscriptionLegacy.add(matchedBundle.id);
                                console.log(`[Stripe Webhook] Bundle ${matchedBundle.name} (${matchedBundle.id}) found in subscription line items and active (legacy) - will be charged automatically on renewal`);
                              }
                            }
                          }
                        }
                        
                        for (const activeBundle of activeBundles.filter(b => b.isActive)) {
                          // Skip if bundle is already in subscription (Stripe will charge automatically)
                          if (bundlesInSubscriptionLegacy.has(activeBundle.bundleId)) {
                            console.log(`[Stripe Webhook] Skipping invoice item for bundle ${activeBundle.bundleId} (legacy) - already in subscription line items`);
                            continue;
                          }
                          // Validation: Check if bundle still exists and is available
                          const bundle = bundles.find(b => b.id === activeBundle.bundleId);
                          
                          if (!bundle) {
                            console.warn(`[Stripe Webhook] Bundle ${activeBundle.bundleId} not found in bundle configuration - deactivating for org ${dbSubscription.organizationId}`);
                            // Deactivate bundle that no longer exists
                            const { instanceBundles: instanceBundlesTable } = await import("@shared/schema");
                            const { eq, and } = await import("drizzle-orm");
                            const { db } = await import("./db");
                            await db.update(instanceBundlesTable)
                              .set({ isActive: false, endDate: new Date() })
                              .where(and(
                                eq(instanceBundlesTable.id, activeBundle.id),
                                eq(instanceBundlesTable.isActive, true)
                              ));
                            continue;
                          }
                          
                          if (!bundle.isActive) {
                            console.warn(`[Stripe Webhook] Bundle ${bundle.name} (${activeBundle.bundleId}) is no longer active - deactivating for org ${dbSubscription.organizationId}`);
                            // Deactivate bundle that has been discontinued
                            const { instanceBundles: instanceBundlesTable } = await import("@shared/schema");
                            const { eq, and } = await import("drizzle-orm");
                            const { db } = await import("./db");
                            await db.update(instanceBundlesTable)
                              .set({ isActive: false, endDate: new Date() })
                              .where(and(
                                eq(instanceBundlesTable.id, activeBundle.id),
                                eq(instanceBundlesTable.isActive, true)
                              ));
                            continue;
                          }
                          
                          // Edge Case 5: Validate modules are still in bundle configuration
                          const currentBundleModules = await storage.getBundleModules(activeBundle.bundleId);
                          const instanceModules = await storage.getInstanceModules(instanceSub.id);
                          const enabledBundleModules = instanceModules.filter(im => 
                            im.isEnabled && currentBundleModules.some(bm => bm.moduleId === im.moduleId)
                          );
                          
                          if (currentBundleModules.length === 0) {
                            console.warn(`[Stripe Webhook] Bundle ${bundle.name} (${activeBundle.bundleId}) has no modules - deactivating for org ${organizationId}`);
                            // Deactivate bundle that has no modules
                            const { instanceBundles: instanceBundlesTable } = await import("@shared/schema");
                            const { eq, and } = await import("drizzle-orm");
                            const { db } = await import("./db");
                            await db.update(instanceBundlesTable)
                              .set({ isActive: false, endDate: new Date() })
                              .where(and(
                                eq(instanceBundlesTable.id, activeBundle.id),
                                eq(instanceBundlesTable.isActive, true)
                              ));
                            continue;
                          }
                          
                          // Edge Case 4: Validate currency hasn't changed
                          if (activeBundle.currencyCode && activeBundle.currencyCode !== currency) {
                            console.warn(`[Stripe Webhook] Currency mismatch for bundle ${bundle.name}: stored ${activeBundle.currencyCode} vs current ${currency}. Using stored currency ${activeBundle.currencyCode}.`);
                            // Use stored currency for pricing calculation
                            const storedCurrency = activeBundle.currencyCode;
                            const bundlePricing = await storage.getBundlePricing(activeBundle.bundleId, storedCurrency);
                            if (!bundlePricing) {
                              console.error(`[Stripe Webhook] Bundle ${bundle.name} has no pricing in stored currency ${storedCurrency} - skipping renewal charge`);
                              continue;
                            }
                          }
                          
                          // IMPORTANT: Use current pricing on renewal (pricing updates apply on next renewal)
                          // Fetch current bundle pricing for renewal
                          let bundlePrice = 0;
                          let pricingChanged = false;
                          const bundleCurrency = activeBundle.currencyCode || currency;
                          
                          const currentBundlePricing = await storage.getBundlePricing(activeBundle.bundleId, bundleCurrency);
                          if (currentBundlePricing) {
                            // Use current pricing for renewal
                            bundlePrice = instanceSub.billingCycle === "annual"
                              ? currentBundlePricing.priceAnnual
                              : currentBundlePricing.priceMonthly;
                            
                            // Check if pricing has changed from stored pricing (for logging and updating stored price)
                            if (activeBundle.bundlePriceMonthly && activeBundle.bundlePriceAnnual) {
                              const storedPrice = instanceSub.billingCycle === "annual" 
                                ? activeBundle.bundlePriceAnnual 
                                : activeBundle.bundlePriceMonthly;
                              
                              if (storedPrice !== bundlePrice) {
                                pricingChanged = true;
                                console.log(`[Stripe Webhook] Bundle ${bundle.name} pricing updated: stored ${storedPrice/100} ${bundleCurrency} â†’ current ${bundlePrice/100} ${bundleCurrency}. Using current price for renewal (legacy).`);
                                
                                // Update stored pricing in instance bundle to reflect new price
                                const { instanceBundles: instanceBundlesTable } = await import("@shared/schema");
                                const { eq } = await import("drizzle-orm");
                                const { db } = await import("./db");
                                await db.update(instanceBundlesTable)
                                  .set({
                                    bundlePriceMonthly: currentBundlePricing.priceMonthly,
                                    bundlePriceAnnual: currentBundlePricing.priceAnnual,
                                    currencyCode: bundleCurrency
                                  })
                                  .where(eq(instanceBundlesTable.id, activeBundle.id));
                                console.log(`[Stripe Webhook] Updated stored bundle pricing for instance bundle ${activeBundle.id} to reflect new pricing (legacy)`);
                              }
                            }
                          } else {
                            // Fallback: use stored pricing if current pricing not available
                            if (activeBundle.bundlePriceMonthly && activeBundle.bundlePriceAnnual) {
                              bundlePrice = instanceSub.billingCycle === "annual" 
                                ? activeBundle.bundlePriceAnnual 
                                : activeBundle.bundlePriceMonthly;
                              console.warn(`[Stripe Webhook] Bundle ${bundle.name} has no current pricing in currency ${bundleCurrency}, using stored pricing: ${bundlePrice/100} ${bundleCurrency} (legacy)`);
                            } else {
                              console.error(`[Stripe Webhook] Bundle ${bundle.name} (${activeBundle.bundleId}) has no pricing configured in currency ${bundleCurrency} - skipping renewal charge (legacy)`);
                              continue;
                            }
                          }
                        
                        if (bundlePrice > 0) {
                          try {
                            await stripe.invoiceItems.create({
                              customer: org.stripeCustomerId,
                              amount: bundlePrice, // Full cycle price in minor units
                              currency: currency.toLowerCase(),
                              description: `${bundle.name} Bundle (${instanceSub.billingCycle} billing)${pricingChanged ? ' [Price updated on renewal]' : ''}`,
                              metadata: {
                                organizationId: dbSubscription.organizationId,
                                  bundleId: activeBundle.bundleId,
                                  bundleName: bundle.name,
                                  type: "bundle_renewal",
                                  billingCycle: instanceSub.billingCycle || "monthly",
                                  pricingChanged: pricingChanged.toString()
                                }
                              });
                              console.log(`[Stripe Webhook] Added bundle charge for ${bundle.name} (${bundlePrice/100} ${currency}) to next renewal invoice for org ${dbSubscription.organizationId}`);
                            } catch (bundleError: any) {
                              console.error(`[Stripe Webhook] Failed to add bundle charge for ${bundle.name}:`, bundleError.message);
                              // Don't fail renewal if bundle invoice item creation fails
                            }
                          }
                        }
                      } catch (bundleBillingError: any) {
                        console.error(`[Stripe Webhook] Error adding bundle charges for renewal (legacy):`, bundleBillingError);
                        // Don't fail renewal if bundle billing fails
                    }
                  }
                }
              } catch (moduleBillingError: any) {
                console.error(`[Stripe Webhook] Error adding module charges for renewal (legacy):`, moduleBillingError);
                // Don't fail renewal if module billing fails
              }

              console.log(`[Stripe Webhook] New billing cycle for org ${dbSubscription.organizationId}, granted ${quotaToGrant} credits`);
            }
          }
          break;
        }

        case "invoice.payment_failed": {
          const invoice = event.data.object;

          if (invoice.subscription) {
            const stripe = await getUncachableStripeClient();
            const subscription = await stripe.subscriptions.retrieve(invoice.subscription);
            
            // Check if this is a tier-based subscription (2026 model) or legacy subscription
            const tierId = subscription.metadata?.tierId;
            const organizationId = subscription.metadata?.organizationId || (await storage.getSubscriptionByStripeId(subscription.id))?.organizationId;
            
            if (!organizationId) {
              console.error(`[Stripe Webhook] Payment failed but organizationId not found for subscription ${subscription.id}`);
              break;
            }

            // Handle tier-based subscription (instanceSubscriptions)
            const instanceSub = await storage.getInstanceSubscription(organizationId);
            
            if (instanceSub) {
              const now = new Date();
              const GRACE_PERIOD_DAYS = 3;
              
              // Check if this is the first payment failure or if grace period has expired
              const firstFailureDate = instanceSub.firstPaymentFailureDate;
              const isFirstFailure = !firstFailureDate;
              
              if (isFirstFailure) {
                // First payment failure - set the failure date and enter grace period
                console.log(`[Stripe Webhook] First payment failure for org ${organizationId} - entering ${GRACE_PERIOD_DAYS}-day grace period`);
                
                await storage.updateInstanceSubscription(instanceSub.id, {
                  firstPaymentFailureDate: now,
                });
                
                // Send payment failed notification
                try {
                  const org = await storage.getOrganization(organizationId);
                  const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
                  const amount = invoice.amount_due || 0;
                  const retryDate = invoice.next_payment_attempt ? new Date(invoice.next_payment_attempt * 1000) : undefined;
                  const gracePeriodEndDate = new Date(now.getTime() + GRACE_PERIOD_DAYS * 24 * 60 * 60 * 1000);
                  
                  const { notificationService } = await import("./notificationService");
                  await notificationService.sendPaymentFailedAlert(organizationId, amount, currency, retryDate);
                  
                  console.log(`[Stripe Webhook] Grace period started for org ${organizationId}. Deactivation will occur on ${gracePeriodEndDate.toISOString()} if payment is not successful.`);
                } catch (notifError) {
                  console.error(`[Stripe Webhook] Failed to send payment failed notification:`, notifError);
                }
                
                // During grace period: Keep subscription active, modules enabled, credits available
                console.log(`[Stripe Webhook] Grace period active for org ${organizationId} - subscription, modules, and credits remain active`);
              } else {
                // Check if grace period has expired
                const gracePeriodEndDate = new Date(firstFailureDate.getTime() + GRACE_PERIOD_DAYS * 24 * 60 * 60 * 1000);
                const gracePeriodExpired = now >= gracePeriodEndDate;
                
                if (gracePeriodExpired) {
                  // Grace period expired - deactivate everything
                  console.log(`[Stripe Webhook] Grace period expired for org ${organizationId} (failed on ${firstFailureDate.toISOString()}, grace period ended on ${gracePeriodEndDate.toISOString()}) - deactivating subscription and modules`);

            // Handle legacy subscription if exists
            const dbSubscription = await storage.getSubscriptionByStripeId(subscription.id);
            if (dbSubscription) {
              await storage.updateSubscription(dbSubscription.id, {
                status: "inactive" as any,
              });
            }

              // 1. Update instance subscription status to inactive
              await storage.updateInstanceSubscription(instanceSub.id, {
                subscriptionStatus: "inactive" as any,
              });

              // 2. Deactivate all enabled modules
              const instanceModules = await storage.getInstanceModules(instanceSub.id);
              const enabledModules = instanceModules.filter(m => m.isEnabled);
              
              for (const module of enabledModules) {
                await storage.toggleInstanceModule(instanceSub.id, module.moduleId, false);
                    console.log(`[Stripe Webhook] Deactivated module ${module.moduleId} for org ${organizationId} (grace period expired)`);
              }

              // 3. Expire all credit batches (zero out credits)
              const { subscriptionService: subService } = await import("./subscriptionService");
              const allBatches = await storage.getCreditBatchesByOrganization(organizationId);
              const activeBatches = allBatches.filter(b => b.remainingQuantity > 0);
              
              for (const batch of activeBatches) {
                await storage.expireCreditBatch(batch.id);
                await storage.createCreditLedgerEntry({
                  organizationId,
                  source: "expiry" as any,
                  quantity: -batch.remainingQuantity,
                  batchId: batch.id,
                      notes: `Expired ${batch.remainingQuantity} credits due to payment failure (grace period expired)`
                    });
                  }

                  console.log(`[Stripe Webhook] Payment failure handled after grace period: subscription inactive, ${enabledModules.length} modules deactivated, ${activeBatches.length} credit batches expired for org ${organizationId}`);
                } else {
                  // Still in grace period - log but don't deactivate
                  const daysRemaining = Math.ceil((gracePeriodEndDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
                  console.log(`[Stripe Webhook] Payment failed again for org ${organizationId}, but still in grace period (${daysRemaining} day(s) remaining). Subscription, modules, and credits remain active.`);
                  
                  // Send payment failed notification (reminder)
                  try {
                    const org = await storage.getOrganization(organizationId);
                    const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
                    const amount = invoice.amount_due || 0;
                    const retryDate = invoice.next_payment_attempt ? new Date(invoice.next_payment_attempt * 1000) : undefined;
                    
                    const { notificationService } = await import("./notificationService");
                    await notificationService.sendPaymentFailedAlert(organizationId, amount, currency, retryDate);
                  } catch (notifError) {
                    console.error(`[Stripe Webhook] Failed to send payment failed notification:`, notifError);
                  }
                }
              }
            } else {
              // No instance subscription - handle legacy subscription
              const dbSubscription = await storage.getSubscriptionByStripeId(subscription.id);
              if (dbSubscription) {
                await storage.updateSubscription(dbSubscription.id, {
                  status: "inactive" as any,
                });
                console.log(`[Stripe Webhook] Legacy subscription payment failed for org ${dbSubscription.organizationId} - status set to inactive`);
              }
            }
          }
          break;
        }

        case "customer.subscription.updated": {
          const subscription = event.data.object;
          const dbSubscription = await storage.getSubscriptionByStripeId(subscription.id);

          if (dbSubscription) {
            // Helper function to safely create Date from Stripe timestamp
            const safeDateFromTimestamp = (timestamp: any, fallback: Date): Date => {
              if (!timestamp || typeof timestamp !== 'number' || isNaN(timestamp)) {
                return fallback;
              }
              const date = new Date(timestamp * 1000);
              return isNaN(date.getTime()) ? fallback : date;
            };

            const now = new Date();
            const defaultPeriodEnd = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);

            // IMPORTANT: Check if subscription is cancelled
            const isCancelled = subscription.cancel_at_period_end || 
                               subscription.status === "canceled" ||
                               subscription.status === "incomplete_expired";

            // Update subscription status and period
            await storage.updateSubscription(dbSubscription.id, {
              status: subscription.status as any,
              cancelAtPeriodEnd: subscription.cancel_at_period_end || false,
              currentPeriodStart: safeDateFromTimestamp(subscription.current_period_start, dbSubscription.currentPeriodStart || now),
              currentPeriodEnd: safeDateFromTimestamp(subscription.current_period_end, dbSubscription.currentPeriodEnd || defaultPeriodEnd),
            });

            // Check for renewal reminder (7 days before renewal)
            if (subscription.current_period_end) {
              const renewalDate = new Date(subscription.current_period_end * 1000);
              const daysUntilRenewal = Math.ceil((renewalDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24));
              
              // Send reminder if within 7 days
              if (daysUntilRenewal >= 0 && daysUntilRenewal <= 7) {
                const { notificationService } = await import("./notificationService");
                await notificationService.sendRenewalReminder(dbSubscription.organizationId, renewalDate, daysUntilRenewal);
              }
            }

            // Check if this is a tier-based subscription
            const tierId = subscription.metadata?.tierId;
            const organizationId = subscription.metadata?.organizationId || dbSubscription.organizationId;

            if (tierId && organizationId) {
              // Handle tier-based subscription update
              const instanceSub = await storage.getInstanceSubscription(organizationId);
              if (instanceSub) {
                // Sync renewal date from Stripe (source of truth for billing cycle)
                // This ensures module proration calculations are accurate
                const stripeRenewalDate = safeDateFromTimestamp(subscription.current_period_end, instanceSub.subscriptionRenewalDate || defaultPeriodEnd);
                if (instanceSub.subscriptionRenewalDate?.getTime() !== stripeRenewalDate.getTime()) {
                  console.log(`[Subscription Update] Syncing renewal date from Stripe: ${instanceSub.subscriptionRenewalDate?.toISOString()} â†’ ${stripeRenewalDate.toISOString()}`);
                  await storage.updateInstanceSubscription(instanceSub.id, {
                    subscriptionRenewalDate: stripeRenewalDate
                  });
                  // Update local instanceSub reference for subsequent checks
                  instanceSub.subscriptionRenewalDate = stripeRenewalDate;
                }
                
                // Check if tier changed
                if (instanceSub.currentTierId !== tierId) {
                  const tiers = await storage.getSubscriptionTiers();
                  const tier = tiers.find(t => t.id === tierId);
                  if (tier) {
                    // Calculate additional inspections from old tier to preserve them
                    const oldTier = instanceSub.currentTierId 
                      ? tiers.find(t => t.id === instanceSub.currentTierId)
                      : null;
                    
                    let additionalInspections = 0;
                    let newQuota = tier.includedInspections;
                    
                    if (oldTier) {
                      // Calculate additional inspections from current quota
                      // currentQuota = oldTier.included + additional, so:
                      // additional = currentQuota - oldTier.included
                      additionalInspections = Math.max(0, instanceSub.inspectionQuotaIncluded - oldTier.includedInspections);
                      newQuota = tier.includedInspections + additionalInspections;
                      
                      console.log(`[Subscription Update] Tier change for org ${organizationId}: ${oldTier.name} â†’ ${tier.name}`);
                      console.log(`[Subscription Update] Preserving ${additionalInspections} additional inspections (old quota: ${instanceSub.inspectionQuotaIncluded}, old tier included: ${oldTier.includedInspections})`);
                      console.log(`[Subscription Update] New quota: ${newQuota} (${tier.includedInspections} tier + ${additionalInspections} additional)`);
                    } else {
                      // No old tier found, use tier base only (fallback)
                      console.log(`[Subscription Update] No old tier found for org ${organizationId}, using tier base only`);
                    }

                    // Update tier and quota (preserving additional inspections)
                    await storage.updateInstanceSubscription(instanceSub.id, {
                      currentTierId: tierId,
                      inspectionQuotaIncluded: newQuota,
                    });

                    // If quota changed, reset credits (expire old, grant new)
                    if (instanceSub.inspectionQuotaIncluded !== newQuota) {
                      const { subscriptionService: subService } = await import("./subscriptionService");
                      const existingBatches = await storage.getCreditBatchesByOrganization(organizationId);
                      const planBatches = existingBatches.filter(b => 
                        b.grantSource === 'plan_inclusion' && 
                        b.remainingQuantity > 0 &&
                        !b.rolled
                      );

                      if (planBatches.length > 0) {
                        console.log(`[Subscription Update] Resetting ${planBatches.length} existing plan_inclusion batches for org ${organizationId} due to tier change`);
                        for (const batch of planBatches) {
                          await storage.expireCreditBatch(batch.id);
                          await storage.createCreditLedgerEntry({
                            organizationId,
                            source: "expiry" as any,
                            quantity: -batch.remainingQuantity,
                            batchId: batch.id,
                            notes: `Expired ${batch.remainingQuantity} credits due to tier change to ${tier.name} (preserving ${additionalInspections} additional inspections)`
                          });
                        }
                      }

                      // Grant new quota (tier + preserved additional)
                      const renewalDate = instanceSub.subscriptionRenewalDate || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
                      await subService.grantCredits(
                        organizationId,
                        newQuota,
                        "plan_inclusion",
                        renewalDate,
                        { adminNotes: `Tier changed to ${tier.name} via subscription update (preserved ${additionalInspections} additional inspections)` }
                      );
                      
                      console.log(`[Subscription Update] Updated tier to ${tier.name} and granted ${newQuota} credits to org ${organizationId} (${tier.includedInspections} tier + ${additionalInspections} additional)`);
                    }
                  }
                }
              }
            } else {
              // Handle legacy subscription update
              // If plan changed, update the organization's included inspections
              if (subscription.items?.data?.[0]?.price) {
                const priceItem = subscription.items.data[0];
                // Extract credits from product metadata if available
                const productMetadata = priceItem.price?.product?.metadata || {};
                if (productMetadata.includedInspections) {
                  const org = await storage.getOrganization(dbSubscription.organizationId);
                  if (org) {
                    await storage.updateOrganization(dbSubscription.organizationId, {
                      includedInspectionsPerMonth: parseInt(productMetadata.includedInspections),
                    });
                  }
                }
              }
            }

            console.log(`[Stripe Webhook] Subscription updated for org ${dbSubscription.organizationId}: status=${subscription.status}, cancel_at_period_end=${subscription.cancel_at_period_end}`);
          }
          break;
        }

        case "customer.subscription.deleted": {
          const subscription = event.data.object;
          const dbSubscription = await storage.getSubscriptionByStripeId(subscription.id);

          if (dbSubscription) {
            // Update subscription status
            await storage.cancelSubscription(dbSubscription.id);
            
            // Handle credits and modules (same as payment failure)
            const instanceSub = await storage.getInstanceSubscription(dbSubscription.organizationId);
            if (instanceSub) {
              // Deactivate all enabled modules
              const instanceModules = await storage.getInstanceModules(instanceSub.id);
              const enabledModules = instanceModules.filter(m => m.isEnabled);
              for (const module of enabledModules) {
                await storage.toggleInstanceModule(instanceSub.id, module.moduleId, false);
              }

              // Expire all credit batches
              const { subscriptionService: subService } = await import("./subscriptionService");
              const allBatches = await storage.getCreditBatchesByOrganization(dbSubscription.organizationId);
              const activeBatches = allBatches.filter(b => b.remainingQuantity > 0);
              for (const batch of activeBatches) {
                await storage.expireCreditBatch(batch.id);
                await storage.createCreditLedgerEntry({
                  organizationId: dbSubscription.organizationId,
                  source: "expiry" as any,
                  quantity: -batch.remainingQuantity,
                  batchId: batch.id,
                  notes: `Expired ${batch.remainingQuantity} credits due to subscription deletion`
                });
              }

              // Credits are already handled by expiring batches above
              // No need to update legacy creditsRemaining field as it's removed

              // Update instance subscription status
              await storage.updateInstanceSubscription(instanceSub.id, {
                subscriptionStatus: "inactive" as any,
              });
            }
            
            console.log(`[Stripe Webhook] Subscription deleted and cleaned up for org ${dbSubscription.organizationId}`);
          }
          break;
        }
      }

      res.json({ received: true });
    } catch (error: any) {
      console.error(`[Stripe Webhook] Error processing webhook:`, error);
      res.status(400).json({ error: error.message });
    }
  });

  // Get credit balance
  app.get("/api/credits/balance", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const balance = await storage.getCreditBalance(user.organizationId);

      // Get ledger to calculate consumed credits
      const ledger = await storage.getCreditLedgerByOrganization(user.organizationId, 10000);

      let consumed = 0;
      let expired = 0;

      for (const entry of ledger) {
        if (entry.quantity < 0) {
          // Negative quantities are consumption
          consumed += Math.abs(entry.quantity);
        }
      }

      // Get expired batches
      const expiredBatches = await db
        .select()
        .from(creditBatches)
        .where(
          and(
            eq(creditBatches.organizationId, user.organizationId),
            lt(creditBatches.expiresAt, new Date()),
            gt(creditBatches.remainingQuantity, 0)
          )
        );

      for (const batch of expiredBatches) {
        expired += batch.remainingQuantity;
      }

      // Return in the format the frontend expects
      res.json({
        available: balance.total,
        consumed,
        expired
      });
    } catch (error: any) {
      console.error("Error fetching credit balance:", error);
      res.status(500).json({ message: "Failed to fetch credit balance" });
    }
  });

  // Get credit ledger
  app.get("/api/credits/ledger", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const limit = parseInt(req.query.limit as string) || 100;
      const ledger = await storage.getCreditLedgerByOrganization(user.organizationId, limit);
      res.json(ledger);
    } catch (error: any) {
      console.error("Error fetching credit ledger:", error);
      res.status(500).json({ message: "Failed to fetch credit ledger" });
    }
  });

  // Create top-up checkout session
  app.post("/api/credits/topup/checkout", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { packSize } = req.body;
      if (!packSize || ![100, 250, 500, 1000].includes(packSize)) {
        return res.status(400).json({ message: "Invalid pack size. Must be 100, 250, 500, or 1000" });
      }

      const org = await storage.getOrganization(user.organizationId);
      if (!org) {
        return res.status(404).json({ message: "Organization not found" });
      }

      // Get pricing based on pack size (pence per credit)
      const pricingTiers: Record<number, number> = {
        100: 400,   // Â£4.00 per credit
        250: 300,   // Â£3.00 per credit
        500: 200,   // Â£2.00 per credit
        1000: 150,  // Â£1.50 per credit
      };
      const unitPrice = pricingTiers[packSize];
      const totalPrice = packSize * unitPrice;
      const currency = "GBP"; // Could be determined by country

      // Create top-up order
      const order = await storage.createTopupOrder({
        organizationId: org.id,
        packSize,
        currency: currency as any,
        unitPriceMinorUnits: unitPrice,
        totalPriceMinorUnits: totalPrice,
        status: "pending" as any,
      });

      // Create Stripe checkout session
      const baseUrl = getBaseUrl(req);

      const stripe = await getUncachableStripeClient();
      const session = await stripe.checkout.sessions.create({
        customer: org.stripeCustomerId || undefined,
        mode: "payment",
        line_items: [
          {
            price_data: {
              currency: currency.toLowerCase(),
              product_data: {
                name: `${packSize} Inspection Credits`,
                description: "Credit top-up for inspections",
              },
              unit_amount: totalPrice,
            },
            quantity: 1,
          },
        ],
        success_url: `${baseUrl}/billing?topup_success=true&session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${baseUrl}/billing?topup_canceled=true`,
        metadata: {
          organizationId: org.id,
          topupOrderId: order.id,
          packSize: packSize.toString(),
        },
      });

      // Update order with payment intent
      await storage.updateTopupOrder(order.id, {
        stripePaymentIntentId: session.payment_intent as string,
      });

      res.json({ url: session.url, orderId: order.id });
    } catch (error: any) {
      console.error("Error creating topup checkout:", error);
      res.status(500).json({ message: "Failed to create topup checkout", error: error.message });
    }
  });

  // Admin: Grant credits
  app.post("/api/admin/credits/grant", isAuthenticated, requireRole("owner"), async (req: any, res) => {
    try {
      const { organizationId, quantity, reason } = req.body;
      const user = await storage.getUser(req.user.id);

      if (!organizationId || !quantity || quantity <= 0) {
        return res.status(400).json({ message: "Invalid request" });
      }

      const { subscriptionService: subService } = await import("./subscriptionService");
      await subService.grantCredits(
        organizationId,
        quantity,
        "admin_grant",
        undefined,
        { adminNotes: reason || "Admin grant", createdBy: user?.id }
      );

      res.json({ success: true, granted: quantity });
    } catch (error: any) {
      console.error("Error granting credits:", error);
      res.status(500).json({ message: "Failed to grant credits", error: error.message });
    }
  });

  // ==================== SUBSCRIPTION PLAN ROUTES (Eco-Admin) ====================
  // Note: Country Pricing Overrides have been removed as they are redundant with the currency conversion API

  // Get all plans
  app.get("/api/admin/plans", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const plans = await storage.getPlans();
      res.json(plans);
    } catch (error: any) {
      console.error("Error fetching plans:", error);
      res.status(500).json({ message: "Failed to fetch plans" });
    }
  });

  // Get active plans
  app.get("/api/admin/plans/active", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const plans = await storage.getActivePlans();
      res.json(plans);
    } catch (error: any) {
      console.error("Error fetching active plans:", error);
      res.status(500).json({ message: "Failed to fetch active plans" });
    }
  });

  // Create new plan
  app.post("/api/admin/plans", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Validate request body
      const validated = insertPlanSchema.parse(req.body);
      const plan = await storage.createPlan(validated);
      res.json(plan);
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return res.status(400).json({ message: "Invalid plan data", errors: error.errors });
      }
      console.error("Error creating plan:", error);
      res.status(500).json({ message: "Failed to create plan", error: error.message });
    }
  });

  // Update plan
  app.patch("/api/admin/plans/:id", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Validate request body
      const validated = insertPlanSchema.partial().parse(req.body);
      const { id } = req.params;
      const plan = await storage.updatePlan(id, validated);
      res.json(plan);
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return res.status(400).json({ message: "Invalid plan data", errors: error.errors });
      }
      console.error("Error updating plan:", error);
      res.status(500).json({ message: "Failed to update plan", error: error.message });
    }
  });

  // ==================== CREDIT BUNDLE ROUTES (Eco-Admin) ====================

  // Get all credit bundles
  app.get("/api/admin/bundles", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const bundles = await storage.getCreditBundles();
      res.json(bundles);
    } catch (error: any) {
      console.error("Error fetching bundles:", error);
      res.status(500).json({ message: "Failed to fetch bundles" });
    }
  });

  // Get active credit bundles
  app.get("/api/admin/bundles/active", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const bundles = await storage.getActiveCreditBundles();
      res.json(bundles);
    } catch (error: any) {
      console.error("Error fetching active bundles:", error);
      res.status(500).json({ message: "Failed to fetch active bundles" });
    }
  });

  // Create new credit bundle
  app.post("/api/admin/bundles", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Validate request body
      const validated = insertCreditBundleSchema.parse(req.body);
      const bundle = await storage.createCreditBundle(validated);
      res.json(bundle);
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return res.status(400).json({ message: "Invalid bundle data", errors: error.errors });
      }
      console.error("Error creating bundle:", error);
      res.status(500).json({ message: "Failed to create bundle", error: error.message });
    }
  });

  // Update credit bundle
  app.patch("/api/admin/bundles/:id", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Validate request body
      const validated = insertCreditBundleSchema.partial().parse(req.body);
      const { id } = req.params;
      const bundle = await storage.updateCreditBundle(id, validated);
      res.json(bundle);
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return res.status(400).json({ message: "Invalid bundle data", errors: error.errors });
      }
      console.error("Error updating bundle:", error);
      res.status(500).json({ message: "Failed to update bundle", error: error.message });
    }
  });

  // Delete credit bundle
  app.delete("/api/admin/bundles/:id", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { id } = req.params;
      await storage.deleteCreditBundle(id);
      res.json({ success: true });
    } catch (error: any) {
      console.error("Error deleting bundle:", error);
      res.status(500).json({ message: "Failed to delete bundle", error: error.message });
    }
  });

  // ==================== ECO-ADMIN PRICING MODEL 2026 ROUTES ====================

  // Currency Management
  app.get("/api/admin/currencies", isAdminAuthenticated, async (req: any, res) => {
    try {
      const currencies = await storage.getCurrencyConfig();
      res.json(currencies);
    } catch (error: any) {
      console.error("Error fetching currencies:", error);
      res.status(500).json({ message: "Failed to fetch currencies", error: error.message });
    }
  });

  app.post("/api/admin/currencies", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { code, symbol, isActive, defaultForRegion, conversionRate } = req.body;
      const { currencyConfig } = await import("@shared/schema");
      const [currency] = await db.insert(currencyConfig).values({
        code,
        symbol,
        isActive: isActive !== undefined ? isActive : true,
        defaultForRegion: defaultForRegion || null,
        conversionRate: conversionRate || "1.0000"
      }).returning();
      res.json(currency);
    } catch (error: any) {
      console.error("Error creating currency:", error);
      res.status(500).json({ message: "Failed to create currency", error: error.message });
    }
  });

  app.patch("/api/admin/currencies/:code", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { code } = req.params;
      const { symbol, isActive, defaultForRegion, conversionRate } = req.body;
      const { currencyConfig } = await import("@shared/schema");
      const [currency] = await db.update(currencyConfig)
        .set({
          symbol,
          isActive,
          defaultForRegion,
          conversionRate,
          updatedAt: new Date()
        })
        .where(eq(currencyConfig.code, code))
        .returning();
      res.json(currency);
    } catch (error: any) {
      console.error("Error updating currency:", error);
      res.status(500).json({ message: "Failed to update currency", error: error.message });
    }
  });

  app.delete("/api/admin/currencies/:code", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { code } = req.params;
      const { currencyConfig } = await import("@shared/schema");
      await db.delete(currencyConfig).where(eq(currencyConfig.code, code));
      res.json({ success: true });
    } catch (error: any) {
      console.error("Error deleting currency:", error);
      res.status(500).json({ message: "Failed to delete currency", error: error.message });
    }
  });

  // Subscription Tier Management
  app.get("/api/admin/subscription-tiers", isAdminAuthenticated, async (req: any, res) => {
    try {
      const tiers = await storage.getSubscriptionTiers();
      res.json(tiers);
    } catch (error: any) {
      console.error("Error fetching subscription tiers:", error);
      res.status(500).json({ message: "Failed to fetch subscription tiers", error: error.message });
    }
  });

  app.post("/api/admin/subscription-tiers", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { subscriptionTiersTable } = await import("@shared/schema");
      const { name, code, description, tierOrder, includedInspections, basePriceMonthly, basePriceAnnual, annualDiscountPercentage, isActive, requiresCustomPricing, perInspectionPrice } = req.body;
      
      // Validate required fields
      if (!name || !code || !includedInspections || !basePriceMonthly || !perInspectionPrice || !description) {
        return res.status(400).json({ message: "Missing required fields: name, code, includedInspections, basePriceMonthly, perInspectionPrice, and description are required" });
      }
      
      // Normalize code to lowercase and validate format (alphanumeric with underscores)
      const codeLower = code.toLowerCase().trim();
      if (!/^[a-z0-9_]+$/.test(codeLower)) {
        return res.status(400).json({ 
          message: `Invalid tier code format. Code must contain only lowercase letters, numbers, and underscores.`,
          error: `Tier code "${code}" contains invalid characters.`,
          providedCode: code
        });
      }
      
      // Prepare tier data - check if perInspectionPrice column exists by trying to insert
      const tierData: any = {
        name,
        code: codeLower, // Use lowercase for consistency
        description: description || null,
        tierOrder: tierOrder || 1,
        includedInspections,
        basePriceMonthly,
        basePriceAnnual,
        annualDiscountPercentage: annualDiscountPercentage || "16.70",
        isActive: isActive !== undefined ? isActive : true,
        requiresCustomPricing: requiresCustomPricing || false
      };
      
      // Only include perInspectionPrice if it's provided (column might not exist if migration hasn't run)
      if (perInspectionPrice !== undefined && perInspectionPrice !== null) {
        tierData.perInspectionPrice = perInspectionPrice;
      }
      
      let tier;
      try {
        [tier] = await db.insert(subscriptionTiersTable).values(tierData).returning();
      } catch (insertError: any) {
        // If error is about missing column, provide helpful message
        if (insertError.message && insertError.message.includes("per_inspection_price")) {
          console.error("Database migration required: per_inspection_price column missing");
          return res.status(500).json({ 
            message: "Database migration required. Please run migration 0005_add_per_inspection_price_to_tiers.sql to add the per_inspection_price column.",
            error: "Column 'per_inspection_price' does not exist. Migration required.",
            migrationFile: "migrations/0005_add_per_inspection_price_to_tiers.sql"
          });
        }
        // If error is about invalid enum value (before migration), provide helpful message
        if (insertError.message && insertError.message.includes("invalid input value for enum plan_code")) {
          return res.status(500).json({ 
            message: "Database migration required. The tier code column is still using an enum. Please run migration 0006_change_tier_code_to_varchar.sql to allow custom tier codes.",
            error: "Column 'code' is still an enum type. Migration required.",
            migrationFile: "migrations/0006_change_tier_code_to_varchar.sql"
          });
        }
        throw insertError;
      }
      
      // Automatically create GBP tier pricing entry with the base prices
      try {
        const { tierPricing } = await import("@shared/schema");
        await db.insert(tierPricing).values({
          tierId: tier.id,
          currencyCode: "GBP",
          priceMonthly: basePriceMonthly,
          priceAnnual: basePriceAnnual,
          perInspectionPrice: perInspectionPrice || 0
        });
      } catch (pricingError: any) {
        console.warn("Failed to create default GBP pricing for tier:", pricingError.message);
        // Continue even if pricing creation fails - tier is still created
      }
      
      res.json(tier);
    } catch (error: any) {
      console.error("Error creating subscription tier:", error);
      res.status(500).json({ message: "Failed to create subscription tier", error: error.message });
    }
  });

  app.patch("/api/admin/subscription-tiers/:id", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { subscriptionTiersTable } = await import("@shared/schema");
      const updates: any = { updatedAt: new Date() };
      if (req.body.name !== undefined) updates.name = req.body.name;
      if (req.body.description !== undefined) updates.description = req.body.description;
      if (req.body.tierOrder !== undefined) updates.tierOrder = req.body.tierOrder;
      if (req.body.includedInspections !== undefined) updates.includedInspections = req.body.includedInspections;
      if (req.body.basePriceMonthly !== undefined) updates.basePriceMonthly = req.body.basePriceMonthly;
      if (req.body.basePriceAnnual !== undefined) updates.basePriceAnnual = req.body.basePriceAnnual;
      if (req.body.annualDiscountPercentage !== undefined) updates.annualDiscountPercentage = req.body.annualDiscountPercentage;
      if (req.body.perInspectionPrice !== undefined) {
        (updates as any).perInspectionPrice = req.body.perInspectionPrice;
        // Also update GBP tier pricing if it exists
        const { tierPricing } = await import("@shared/schema");
        await db.update(tierPricing)
          .set({ perInspectionPrice: req.body.perInspectionPrice })
          .where(and(eq(tierPricing.tierId, id), eq(tierPricing.currencyCode, "GBP")));
      }
      if (req.body.isActive !== undefined) updates.isActive = req.body.isActive;
      if (req.body.requiresCustomPricing !== undefined) updates.requiresCustomPricing = req.body.requiresCustomPricing;

      const [tier] = await db.update(subscriptionTiersTable)
        .set(updates)
        .where(eq(subscriptionTiersTable.id, id))
        .returning();
      res.json(tier);
    } catch (error: any) {
      console.error("Error updating subscription tier:", error);
      res.status(500).json({ message: "Failed to update subscription tier", error: error.message });
    }
  });

  // Tier Pricing Management
  app.get("/api/admin/subscription-tiers/:tierId/pricing", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { tierId } = req.params;
      const { tierPricing } = await import("@shared/schema");
      const pricing = await db.select().from(tierPricing).where(eq(tierPricing.tierId, tierId));
      res.json(pricing);
    } catch (error: any) {
      console.error("Error fetching tier pricing:", error);
      res.status(500).json({ message: "Failed to fetch tier pricing", error: error.message });
    }
  });

  app.post("/api/admin/subscription-tiers/:tierId/pricing", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { tierId } = req.params;
      const { tierPricing } = await import("@shared/schema");
      const { currencyCode, priceMonthly, priceAnnual, perInspectionPrice } = req.body;
      const [pricing] = await db.insert(tierPricing).values({
        tierId,
        currencyCode,
        priceMonthly,
        priceAnnual,
        perInspectionPrice: perInspectionPrice ?? 0
      }).returning();
      res.json(pricing);
    } catch (error: any) {
      console.error("Error creating tier pricing:", error);
      res.status(500).json({ message: "Failed to create tier pricing", error: error.message });
    }
  });

  app.patch("/api/admin/subscription-tiers/:tierId/pricing/:id", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { tierPricing } = await import("@shared/schema");
      const { priceMonthly, priceAnnual, perInspectionPrice } = req.body;
      const [pricing] = await db.update(tierPricing)
        .set({
          priceMonthly,
          priceAnnual,
          ...(perInspectionPrice !== undefined ? { perInspectionPrice } : {}),
          lastUpdated: new Date()
        })
        .where(eq(tierPricing.id, id))
        .returning();
      res.json(pricing);
    } catch (error: any) {
      console.error("Error updating tier pricing:", error);
      res.status(500).json({ message: "Failed to update tier pricing", error: error.message });
    }
  });

  // Add-On Pack Management
  app.get("/api/admin/addon-packs", isAdminAuthenticated, async (req: any, res) => {
    try {
      const packs = await storage.getAddonPacks();
      res.json(packs);
    } catch (error: any) {
      console.error("Error fetching addon packs:", error);
      res.status(500).json({ message: "Failed to fetch addon packs", error: error.message });
    }
  });

  app.post("/api/admin/addon-packs", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { addonPackConfig } = await import("@shared/schema");
      const { name, inspectionQuantity, packOrder, isActive } = req.body;
      const [pack] = await db.insert(addonPackConfig).values({
        name,
        inspectionQuantity,
        packOrder,
        isActive: isActive !== undefined ? isActive : true
      }).returning();
      res.json(pack);
    } catch (error: any) {
      console.error("Error creating addon pack:", error);
      res.status(500).json({ message: "Failed to create addon pack", error: error.message });
    }
  });

  app.patch("/api/admin/addon-packs/:id", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { addonPackConfig } = await import("@shared/schema");
      const updates: any = {};
      if (req.body.name !== undefined) updates.name = req.body.name;
      if (req.body.inspectionQuantity !== undefined) updates.inspectionQuantity = req.body.inspectionQuantity;
      if (req.body.packOrder !== undefined) updates.packOrder = req.body.packOrder;
      if (req.body.isActive !== undefined) updates.isActive = req.body.isActive;

      const [pack] = await db.update(addonPackConfig)
        .set(updates)
        .where(eq(addonPackConfig.id, id))
        .returning();
      res.json(pack);
    } catch (error: any) {
      console.error("Error updating addon pack:", error);
      res.status(500).json({ message: "Failed to update addon pack", error: error.message });
    }
  });

  // Add-On Pack Pricing Management
  app.get("/api/admin/addon-packs/:packId/pricing", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { packId } = req.params;
      const { addonPackPricing } = await import("@shared/schema");
      const pricing = await db.select().from(addonPackPricing).where(eq(addonPackPricing.packId, packId));
      res.json(pricing);
    } catch (error: any) {
      console.error("Error fetching addon pack pricing:", error);
      res.status(500).json({ message: "Failed to fetch addon pack pricing", error: error.message });
    }
  });

  app.post("/api/admin/addon-packs/:packId/pricing", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { packId } = req.params;
      const { addonPackPricing } = await import("@shared/schema");
      const { tierId, currencyCode, pricePerInspection, totalPackPrice } = req.body;
      const [pricing] = await db.insert(addonPackPricing).values({
        packId,
        tierId,
        currencyCode,
        pricePerInspection,
        totalPackPrice
      }).returning();
      res.json(pricing);
    } catch (error: any) {
      console.error("Error creating addon pack pricing:", error);
      res.status(500).json({ message: "Failed to create addon pack pricing", error: error.message });
    }
  });

  app.patch("/api/admin/addon-packs/:packId/pricing/:id", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { addonPackPricing } = await import("@shared/schema");
      const { pricePerInspection, totalPackPrice } = req.body;
      const [pricing] = await db.update(addonPackPricing)
        .set({
          pricePerInspection,
          totalPackPrice,
          lastUpdated: new Date()
        })
        .where(eq(addonPackPricing.id, id))
        .returning();
      res.json(pricing);
    } catch (error: any) {
      console.error("Error updating addon pack pricing:", error);
      res.status(500).json({ message: "Failed to update addon pack pricing", error: error.message });
    }
  });

  app.delete("/api/admin/addon-packs/:packId/pricing/:id", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { addonPackPricing } = await import("@shared/schema");
      await db.delete(addonPackPricing).where(eq(addonPackPricing.id, id));
      res.json({ message: "Pricing deleted successfully" });
    } catch (error: any) {
      console.error("Error deleting addon pack pricing:", error);
      res.status(500).json({ message: "Failed to delete addon pack pricing", error: error.message });
    }
  });

  app.delete("/api/admin/addon-packs/:id", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { addonPackConfig, instanceAddonPurchases, addonPackPricing } = await import("@shared/schema");
      
      // Check if pack has any active purchases
      const packPurchases = await db.select()
        .from(instanceAddonPurchases)
        .where(and(
          eq(instanceAddonPurchases.packId, id),
          eq(instanceAddonPurchases.status, "active")
        ));
      
      if (packPurchases.length > 0) {
        return res.status(400).json({ 
          message: `Cannot delete pack. There are ${packPurchases.length} active purchase(s) associated with this pack.` 
        });
      }

      // Delete all pricing entries for this pack first (to avoid foreign key constraint violation)
      await db.delete(addonPackPricing).where(eq(addonPackPricing.packId, id));
      
      // Now delete the pack itself
      await db.delete(addonPackConfig).where(eq(addonPackConfig.id, id));
      res.json({ message: "Pack deleted successfully" });
    } catch (error: any) {
      console.error("Error deleting addon pack:", error);
      res.status(500).json({ message: "Failed to delete addon pack", error: error.message });
    }
  });

  // Extensive Inspection Configuration
  app.get("/api/admin/extensive-inspections", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const configs = await storage.getExtensiveInspectionConfig();
      res.json(configs);
    } catch (error: any) {
      console.error("Error fetching extensive inspection configs:", error);
      res.status(500).json({ message: "Failed to fetch extensive inspection configs", error: error.message });
    }
  });

  app.post("/api/admin/extensive-inspections", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { extensiveInspectionConfig } = await import("@shared/schema");
      const { name, imageCount, description, isActive } = req.body;
      const [config] = await db.insert(extensiveInspectionConfig).values({
        name,
        imageCount: imageCount || 800,
        description: description || null,
        isActive: isActive !== undefined ? isActive : true
      }).returning();
      res.json(config);
    } catch (error: any) {
      console.error("Error creating extensive inspection config:", error);
      res.status(500).json({ message: "Failed to create extensive inspection config", error: error.message });
    }
  });

  app.patch("/api/admin/extensive-inspections/:id", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { id } = req.params;
      const { extensiveInspectionConfig } = await import("@shared/schema");
      const updates: any = {};
      if (req.body.name !== undefined) updates.name = req.body.name;
      if (req.body.imageCount !== undefined) updates.imageCount = req.body.imageCount;
      if (req.body.description !== undefined) updates.description = req.body.description;
      if (req.body.isActive !== undefined) updates.isActive = req.body.isActive;

      const [config] = await db.update(extensiveInspectionConfig)
        .set(updates)
        .where(eq(extensiveInspectionConfig.id, id))
        .returning();
      res.json(config);
    } catch (error: any) {
      console.error("Error updating extensive inspection config:", error);
      res.status(500).json({ message: "Failed to update extensive inspection config", error: error.message });
    }
  });

  // Extensive Inspection Pricing
  app.get("/api/admin/extensive-inspections/:typeId/pricing", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { typeId } = req.params;
      const { extensiveInspectionPricing } = await import("@shared/schema");
      const pricing = await db.select().from(extensiveInspectionPricing).where(eq(extensiveInspectionPricing.extensiveTypeId, typeId));
      res.json(pricing);
    } catch (error: any) {
      console.error("Error fetching extensive inspection pricing:", error);
      res.status(500).json({ message: "Failed to fetch extensive inspection pricing", error: error.message });
    }
  });

  app.post("/api/admin/extensive-inspections/:typeId/pricing", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { typeId } = req.params;
      const { extensiveInspectionPricing } = await import("@shared/schema");
      const { tierId, currencyCode, pricePerInspection } = req.body;
      const [pricing] = await db.insert(extensiveInspectionPricing).values({
        extensiveTypeId: typeId,
        tierId,
        currencyCode,
        pricePerInspection
      }).returning();
      res.json(pricing);
    } catch (error: any) {
      console.error("Error creating extensive inspection pricing:", error);
      res.status(500).json({ message: "Failed to create extensive inspection pricing", error: error.message });
    }
  });

  // Module Management
  app.get("/api/admin/modules", isAdminAuthenticated, async (req: any, res) => {
    try {
      const modules = await storage.getMarketplaceModules();
      console.log(`[Admin] Fetched ${modules.length} marketplace modules`);
      res.json(modules);
    } catch (error: any) {
      console.error("Error fetching modules:", error);
      res.status(500).json({ message: "Failed to fetch modules", error: error.message });
    }
  });

  // Get all module pricing in one request (avoids multiple parallel requests)
  app.get("/api/admin/modules/pricing/all", isAdminAuthenticated, async (req: any, res) => {
    try {
      const modules = await storage.getMarketplaceModules();
      console.log(`[Admin Pricing] Fetching pricing for ${modules.length} modules`);
      
      // Query all pricing directly from database to ensure we get everything
      const { modulePricing, marketplaceModules } = await import("@shared/schema");
      const allPricing = await db.select().from(modulePricing);
      console.log(`[Admin Pricing] Found ${allPricing.length} total pricing entries in database`);
      
      // Get all modules from database to match by module_key (in case IDs don't match)
      const allModules = await db.select().from(marketplaceModules);
      const modulesByKey = new Map<string, any>();
      allModules.forEach((m: any) => {
        modulesByKey.set(m.moduleKey, m);
      });
      
      // Create a map of module_key -> pricing entries
      // First, get the module_key for each pricing entry
      const pricingByModuleKey = new Map<string, any[]>();
      for (const pricing of allPricing) {
        // Find the module for this pricing entry
        const module = allModules.find((m: any) => m.id === pricing.moduleId);
        if (module) {
          const key = module.moduleKey;
          if (!pricingByModuleKey.has(key)) {
            pricingByModuleKey.set(key, []);
          }
          pricingByModuleKey.get(key)!.push(pricing);
        }
      }
      
      // Match pricing to modules by module_key (more reliable than ID)
      const pricingData = modules.map((module: any) => {
        const pricing = pricingByModuleKey.get(module.moduleKey) || [];
        console.log(`[Admin Pricing] Module ${module.name} (${module.moduleKey}): Found ${pricing.length} pricing entries`);
        if (pricing.length > 0) {
          console.log(`[Admin Pricing] Pricing details:`, pricing.map((p: any) => ({
            id: p.id,
            currency: p.currencyCode,
            monthly: p.priceMonthly,
            annual: p.priceAnnual
          })));
        }
        return { moduleId: module.id, pricing };
      });
      
      console.log(`[Admin Pricing] Returning pricing data for ${pricingData.length} modules`);
      res.json(pricingData);
    } catch (error: any) {
      console.error("Error fetching all module pricing:", error);
      res.status(500).json({ message: "Failed to fetch module pricing", error: error.message });
    }
  });

  // Get instance modules (enabled/disabled status)
  app.get("/api/admin/instances/:id/modules", isAdminAuthenticated, async (req, res) => {
    try {
      const org = await storage.getOrganization(req.params.id);
      if (!org) {
        return res.status(404).json({ message: "Organization not found" });
      }
      
      const subscription = await storage.getInstanceSubscription(req.params.id);
      if (!subscription) {
        return res.json([]); // No subscription means no modules
      }
      
      const instanceModules = await storage.getInstanceModules(subscription.id);
      res.json(instanceModules);
    } catch (error: any) {
      console.error("Error fetching instance modules:", error);
      res.status(500).json({ message: "Failed to fetch instance modules", error: error.message });
    }
  });

  app.post("/api/admin/modules", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { marketplaceModules } = await import("@shared/schema");
      const { name, moduleKey, description, iconName, isAvailableGlobally, defaultEnabled, displayOrder } = req.body;
      const [module] = await db.insert(marketplaceModules).values({
        name,
        moduleKey,
        description: description || null,
        iconName: iconName || null,
        isAvailableGlobally: isAvailableGlobally !== undefined ? isAvailableGlobally : true,
        defaultEnabled: defaultEnabled || false,
        displayOrder
      }).returning();
      res.json(module);
    } catch (error: any) {
      console.error("Error creating module:", error);
      res.status(500).json({ message: "Failed to create module", error: error.message });
    }
  });

  app.patch("/api/admin/modules/:id", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { id } = req.params;
      const { marketplaceModules } = await import("@shared/schema");
      const updates: any = { updatedAt: new Date() };
      if (req.body.name !== undefined) updates.name = req.body.name;
      if (req.body.description !== undefined) updates.description = req.body.description;
      if (req.body.iconName !== undefined) updates.iconName = req.body.iconName;
      if (req.body.isAvailableGlobally !== undefined) updates.isAvailableGlobally = req.body.isAvailableGlobally;
      if (req.body.defaultEnabled !== undefined) updates.defaultEnabled = req.body.defaultEnabled;
      if (req.body.displayOrder !== undefined) updates.displayOrder = req.body.displayOrder;

      const [module] = await db.update(marketplaceModules)
        .set(updates)
        .where(eq(marketplaceModules.id, id))
        .returning();
      res.json(module);
    } catch (error: any) {
      console.error("Error updating module:", error);
      res.status(500).json({ message: "Failed to update module", error: error.message });
    }
  });

  // Module Pricing Management
  app.get("/api/admin/modules/:moduleId/pricing", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { moduleId } = req.params;
      // Use storage method to get all pricing for the module (same as marketplace uses)
      const allPricing = await storage.getAllModulePricing(moduleId);
      res.json(allPricing);
    } catch (error: any) {
      console.error("Error fetching module pricing:", error);
      res.status(500).json({ message: "Failed to fetch module pricing", error: error.message });
    }
  });

  app.post("/api/admin/modules/:moduleId/pricing", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { moduleId } = req.params;
      const { modulePricing } = await import("@shared/schema");
      const { currencyCode, priceMonthly, priceAnnual } = req.body;
      const [pricing] = await db.insert(modulePricing).values({
        moduleId,
        currencyCode,
        priceMonthly,
        priceAnnual
      }).returning();
      res.json(pricing);
    } catch (error: any) {
      console.error("Error creating module pricing:", error);
      res.status(500).json({ message: "Failed to create module pricing", error: error.message });
    }
  });

  app.patch("/api/admin/modules/:moduleId/pricing/:id", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { modulePricing } = await import("@shared/schema");
      const { priceMonthly, priceAnnual } = req.body;
      
      console.log(`[Admin Pricing Update] Updating pricing ${id} with monthly: ${priceMonthly}, annual: ${priceAnnual}`);
      
      if (priceMonthly === undefined || priceAnnual === undefined) {
        return res.status(400).json({ message: "priceMonthly and priceAnnual are required" });
      }
      
      const [pricing] = await db.update(modulePricing)
        .set({
          priceMonthly: parseInt(priceMonthly, 10),
          priceAnnual: parseInt(priceAnnual, 10),
          lastUpdated: new Date()
        })
        .where(eq(modulePricing.id, id))
        .returning();
      
      console.log(`[Admin Pricing Update] Updated pricing:`, pricing);
      res.json(pricing);
    } catch (error: any) {
      console.error("Error updating module pricing:", error);
      res.status(500).json({ message: "Failed to update module pricing", error: error.message });
    }
  });

  // Module Limits Management
  app.get("/api/admin/modules/:moduleId/limits", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { moduleId } = req.params;
      const { moduleLimits } = await import("@shared/schema");
      const limits = await db.select().from(moduleLimits).where(eq(moduleLimits.moduleId, moduleId));
      res.json(limits);
    } catch (error: any) {
      console.error("Error fetching module limits:", error);
      res.status(500).json({ message: "Failed to fetch module limits", error: error.message });
    }
  });

  app.post("/api/admin/modules/:moduleId/limits", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { moduleId } = req.params;
      const { moduleLimits } = await import("@shared/schema");
      const { limitType, includedQuantity, overagePrice, overageCurrency } = req.body;
      const [limit] = await db.insert(moduleLimits).values({
        moduleId,
        limitType,
        includedQuantity,
        overagePrice,
        overageCurrency
      }).returning();
      res.json(limit);
    } catch (error: any) {
      console.error("Error creating module limit:", error);
      res.status(500).json({ message: "Failed to create module limit", error: error.message });
    }
  });

  // Module Bundle Management
  app.get("/api/admin/module-bundles", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const bundles = await storage.getModuleBundles();
      res.json(bundles);
    } catch (error: any) {
      console.error("Error fetching module bundles:", error);
      res.status(500).json({ message: "Failed to fetch module bundles", error: error.message });
    }
  });

  app.post("/api/admin/module-bundles", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { moduleBundlesTable } = await import("@shared/schema");
      const { name, description, discountPercentage, isActive } = req.body;
      const [bundle] = await db.insert(moduleBundlesTable).values({
        name,
        description: description || null,
        discountPercentage: discountPercentage || null,
        isActive: isActive !== undefined ? isActive : true
      }).returning();
      res.json(bundle);
    } catch (error: any) {
      console.error("Error creating module bundle:", error);
      res.status(500).json({ message: "Failed to create module bundle", error: error.message });
    }
  });

  app.patch("/api/admin/module-bundles/:id", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { id } = req.params;
      const { moduleBundlesTable } = await import("@shared/schema");
      const updates: any = {};
      if (req.body.name !== undefined) updates.name = req.body.name;
      if (req.body.description !== undefined) updates.description = req.body.description;
      if (req.body.discountPercentage !== undefined) updates.discountPercentage = req.body.discountPercentage;
      if (req.body.isActive !== undefined) updates.isActive = req.body.isActive;

      const [bundle] = await db.update(moduleBundlesTable)
        .set(updates)
        .where(eq(moduleBundlesTable.id, id))
        .returning();
      res.json(bundle);
    } catch (error: any) {
      console.error("Error updating module bundle:", error);
      res.status(500).json({ message: "Failed to update module bundle", error: error.message });
    }
  });

  // Bundle Modules Junction (add/remove modules from bundle)
  app.get("/api/admin/module-bundles/:bundleId/modules", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { bundleId } = req.params;
      const { bundleModulesJunction, marketplaceModules } = await import("@shared/schema");
      const modules = await db.select({
        moduleId: bundleModulesJunction.moduleId,
        module: marketplaceModules
      })
        .from(bundleModulesJunction)
        .innerJoin(marketplaceModules, eq(bundleModulesJunction.moduleId, marketplaceModules.id))
        .where(eq(bundleModulesJunction.bundleId, bundleId));
      res.json(modules);
    } catch (error: any) {
      console.error("Error fetching bundle modules:", error);
      res.status(500).json({ message: "Failed to fetch bundle modules", error: error.message });
    }
  });

  app.post("/api/admin/module-bundles/:bundleId/modules", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { bundleId } = req.params;
      const { moduleId } = req.body;
      const { bundleModulesJunction } = await import("@shared/schema");
      await db.insert(bundleModulesJunction).values({ bundleId, moduleId });
      res.json({ success: true });
    } catch (error: any) {
      console.error("Error adding module to bundle:", error);
      res.status(500).json({ message: "Failed to add module to bundle", error: error.message });
    }
  });

  app.delete("/api/admin/module-bundles/:bundleId/modules/:moduleId", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { bundleId, moduleId } = req.params;
      
      // IMPORTANT: Handle graceful removal of module from bundle
      // Check if there are active instance bundles using this bundle
      const { instanceBundles: instanceBundlesTable, instanceModules: instanceModulesTable } = await import("@shared/schema");
      const { eq, and } = await import("drizzle-orm");
      const { db } = await import("./db");
      const { pricingService } = await import("./pricingService");
      
      // Get all active instance bundles for this bundle
      const activeInstanceBundles = await db.select()
        .from(instanceBundlesTable)
        .where(and(
          eq(instanceBundlesTable.bundleId, bundleId),
          eq(instanceBundlesTable.isActive, true)
        ));
      
      // Get bundle modules BEFORE removal to handle gracefully
      const bundleModulesBeforeRemoval = await storage.getBundleModules(bundleId);
      const willBeEmpty = bundleModulesBeforeRemoval.length === 1; // Only this module remains
      
      // Remove module from bundle configuration
      const { bundleModulesJunction } = await import("@shared/schema");
      await db.delete(bundleModulesJunction)
        .where(and(
          eq(bundleModulesJunction.bundleId, bundleId),
          eq(bundleModulesJunction.moduleId, moduleId)
        ));
      
      // Handle active instance bundles gracefully
      if (activeInstanceBundles.length > 0) {
        console.log(`[Bundle Module Removal] Found ${activeInstanceBundles.length} active instance bundles for bundle ${bundleId}. Handling module removal gracefully.`);
        
        if (willBeEmpty) {
          // Bundle will be empty - deactivate all instance bundles
          console.log(`[Bundle Module Removal] Bundle ${bundleId} will be empty after module removal. Deactivating all ${activeInstanceBundles.length} active instance bundles.`);
          
          for (const instanceBundle of activeInstanceBundles) {
            // Get instance subscription by ID
            const { instanceSubscriptions } = await import("@shared/schema");
            const instanceSubs = await db.select()
              .from(instanceSubscriptions)
              .where(eq(instanceSubscriptions.id, instanceBundle.instanceId))
              .limit(1);
            const instanceSub = instanceSubs[0];
            if (!instanceSub) continue;
            
            // Get organization for currency
            const org = await storage.getOrganization(instanceSub.organizationId);
            const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
            
            // Get all modules that were in the bundle (before removal)
            const allBundleModules = bundleModulesBeforeRemoval;
            
            // Deactivate the instance bundle
            await db.update(instanceBundlesTable)
              .set({
                isActive: false,
                endDate: new Date()
              })
              .where(eq(instanceBundlesTable.id, instanceBundle.id));
            
            // Revert all bundle modules to individual pricing
            for (const bm of allBundleModules) {
              const instanceModules = await storage.getInstanceModules(instanceSub.id);
              const instanceModule = instanceModules.find(im => im.moduleId === bm.moduleId);
              
              if (instanceModule && instanceModule.isEnabled) {
                // Get individual module pricing
                const modulePricing = await storage.getModulePricing(bm.moduleId, currency);
                
                if (modulePricing) {
                  // Check if module is covered by another active bundle
                  const isInOtherBundle = await pricingService.isModuleInActiveBundle(instanceSub.id, bm.moduleId);
                  
                  if (!isInOtherBundle) {
                    // Revert to individual module pricing
                    await db.update(instanceModulesTable)
                      .set({
                        monthlyPrice: modulePricing.priceMonthly,
                        annualPrice: modulePricing.priceAnnual,
                        currencyCode: currency,
                        billingStartDate: new Date()
                      })
                      .where(eq(instanceModulesTable.id, instanceModule.id));
                    
                    console.log(`[Bundle Module Removal] Reverted module ${bm.moduleId} to individual pricing for org ${instanceSub.organizationId}`);
                  }
                }
              }
            }
            
            console.log(`[Bundle Module Removal] Deactivated instance bundle ${instanceBundle.id} for org ${instanceSub.organizationId} (bundle became empty)`);
          }
        } else {
          // Bundle still has modules - handle the removed module individually
          console.log(`[Bundle Module Removal] Bundle ${bundleId} still has modules. Handling removed module ${moduleId} individually.`);
          
          for (const instanceBundle of activeInstanceBundles) {
            // Get instance subscription by ID
            const { instanceSubscriptions } = await import("@shared/schema");
            const instanceSubs = await db.select()
              .from(instanceSubscriptions)
              .where(eq(instanceSubscriptions.id, instanceBundle.instanceId))
              .limit(1);
            const instanceSub = instanceSubs[0];
            if (!instanceSub) continue;
            
            // Get organization for currency
            const org = await storage.getOrganization(instanceSub.organizationId);
            const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
            
            // Get instance modules
            const instanceModules = await storage.getInstanceModules(instanceSub.id);
            const instanceModule = instanceModules.find(im => im.moduleId === moduleId);
            
            if (instanceModule && instanceModule.isEnabled) {
              // Check if module is covered by another active bundle
              const isInOtherBundle = await pricingService.isModuleInActiveBundle(instanceSub.id, moduleId);
              
              if (!isInOtherBundle) {
                // Get individual module pricing
                const modulePricing = await storage.getModulePricing(moduleId, currency);
                
                if (modulePricing) {
                  // Revert this specific module to individual pricing
                  await db.update(instanceModulesTable)
                    .set({
                      monthlyPrice: modulePricing.priceMonthly,
                      annualPrice: modulePricing.priceAnnual,
                      currencyCode: currency,
                      billingStartDate: new Date()
                    })
                    .where(eq(instanceModulesTable.id, instanceModule.id));
                  
                  console.log(`[Bundle Module Removal] Reverted module ${moduleId} to individual pricing for org ${instanceSub.organizationId} (removed from bundle but bundle still active)`);
                }
              } else {
                console.log(`[Bundle Module Removal] Module ${moduleId} is covered by another bundle, keeping price at 0 for org ${instanceSub.organizationId}`);
              }
            }
          }
        }
      }
      
      res.json({ 
        success: true,
        message: willBeEmpty 
          ? `Module removed. Bundle is now empty and ${activeInstanceBundles.length} active instance bundle(s) have been deactivated.`
          : `Module removed. ${activeInstanceBundles.length} active instance bundle(s) updated - removed module will be charged individually.`,
        affectedInstances: activeInstanceBundles.length,
        bundleEmpty: willBeEmpty
      });
    } catch (error: any) {
      console.error("Error removing module from bundle:", error);
      res.status(500).json({ message: "Failed to remove module from bundle", error: error.message });
    }
  });

  // Bundle Pricing Management
  app.get("/api/admin/module-bundles/:bundleId/pricing", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { bundleId } = req.params;
      const { bundlePricingTable } = await import("@shared/schema");
      const pricing = await db.select().from(bundlePricingTable).where(eq(bundlePricingTable.bundleId, bundleId));
      res.json(pricing);
    } catch (error: any) {
      console.error("Error fetching bundle pricing:", error);
      res.status(500).json({ message: "Failed to fetch bundle pricing", error: error.message });
    }
  });

  app.post("/api/admin/module-bundles/:bundleId/pricing", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { bundleId } = req.params;
      const { bundlePricingTable } = await import("@shared/schema");
      const { currencyCode, priceMonthly, priceAnnual, savingsMonthly } = req.body;
      const [pricing] = await db.insert(bundlePricingTable).values({
        bundleId,
        currencyCode,
        priceMonthly,
        priceAnnual,
        savingsMonthly: savingsMonthly || null
      }).returning();
      res.json(pricing);
    } catch (error: any) {
      console.error("Error creating bundle pricing:", error);
      res.status(500).json({ message: "Failed to create bundle pricing", error: error.message });
    }
  });

  app.patch("/api/admin/module-bundles/:bundleId/pricing/:id", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { id } = req.params;
      const { bundlePricingTable } = await import("@shared/schema");
      const { priceMonthly, priceAnnual, savingsMonthly } = req.body;
      const [pricing] = await db.update(bundlePricingTable)
        .set({
          priceMonthly,
          priceAnnual,
          savingsMonthly,
          lastUpdated: new Date()
        })
        .where(eq(bundlePricingTable.id, id))
        .returning();
      res.json(pricing);
    } catch (error: any) {
      console.error("Error updating bundle pricing:", error);
      res.status(500).json({ message: "Failed to update bundle pricing", error: error.message });
    }
  });

  // Pricing Preview
  app.get("/api/admin/pricing-preview", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }
      const { currency } = req.query;
      const currencyCode = (currency as string) || "GBP";

      const tiers = await storage.getSubscriptionTiers();
      const packs = await storage.getAddonPacks();
      const modules = await storage.getMarketplaceModules();
      const bundles = await storage.getModuleBundles();

      const pricingData = {
        currency: currencyCode,
        tiers: await Promise.all(tiers.map(async (tier) => {
          const pricing = await storage.getTierPricing(tier.id, currencyCode);
          return {
            ...tier,
            pricing: pricing || {
              priceMonthly: tier.basePriceMonthly,
              priceAnnual: tier.basePriceAnnual
            }
          };
        })),
        addonPacks: await Promise.all(packs.map(async (pack) => {
          const packPricing = await Promise.all(tiers.map(async (tier) => {
            const pricing = await storage.getAddonPackPricing(pack.id, tier.id, currencyCode);
            return { tierId: tier.id, tierName: tier.name, pricing };
          }));
          return { ...pack, pricing: packPricing };
        })),
        modules: await Promise.all(modules.map(async (module) => {
          const pricing = await storage.getModulePricing(module.id, currencyCode);
          return {
            ...module,
            pricing: pricing || { priceMonthly: 0, priceAnnual: 0 }
          };
        })),
        bundles: await Promise.all(bundles.map(async (bundle) => {
          const { bundlePricingTable } = await import("@shared/schema");
          const [pricing] = await db.select()
            .from(bundlePricingTable)
            .where(and(
              eq(bundlePricingTable.bundleId, bundle.id),
              eq(bundlePricingTable.currencyCode, currencyCode)
            ));
          return { ...bundle, pricing: pricing || { priceMonthly: 0, priceAnnual: 0 } };
        }))
      };

      res.json(pricingData);
    } catch (error: any) {
      console.error("Error generating pricing preview:", error);
      res.status(500).json({ message: "Failed to generate pricing preview", error: error.message });
    }
  });

  // Instance Pricing Override Management
  app.post("/api/admin/instances/:organizationId/pricing-override", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      // TODO: Add permission check for super_admin or pricing_admin role
      // For now, any admin can set overrides

      const { organizationId } = req.params;
      const { overrideMonthlyFee, overrideAnnualFee, overrideReason } = req.body;

      const instanceSub = await storage.getInstanceSubscription(organizationId);
      if (!instanceSub) {
        return res.status(404).json({ message: "Instance subscription not found" });
      }

      // Get old prices for history
      const oldMonthlyFee = instanceSub.overrideMonthlyFee;
      const oldAnnualFee = instanceSub.overrideAnnualFee;

      // Update instance subscription with override
      const updated = await storage.updateInstanceSubscription(instanceSub.id, {
        overrideMonthlyFee: overrideMonthlyFee ? Math.round(overrideMonthlyFee * 100) : null,
        overrideAnnualFee: overrideAnnualFee ? Math.round(overrideAnnualFee * 100) : null,
        overrideReason: overrideReason || null,
        overrideSetBy: adminUser.id,
        overrideDate: new Date()
      });

      // Create history record
      await storage.createPricingOverrideHistory({
        instanceId: instanceSub.id,
        overrideType: "subscription",
        targetId: instanceSub.currentTierId || "",
        oldPriceMonthly: oldMonthlyFee || null,
        newPriceMonthly: overrideMonthlyFee ? Math.round(overrideMonthlyFee * 100) : null,
        oldPriceAnnual: oldAnnualFee || null,
        newPriceAnnual: overrideAnnualFee ? Math.round(overrideAnnualFee * 100) : null,
        reason: overrideReason || null,
        changedBy: adminUser.id
      });

      // Send admin notification
      const { notificationService } = await import("./notificationService");
      await notificationService.sendAdminPricingOverrideAlert(
        adminUser.id,
        organizationId,
        "subscription",
        {
          oldPriceMonthly: oldMonthlyFee ? oldMonthlyFee / 100 : null,
          newPriceMonthly: overrideMonthlyFee || null,
          oldPriceAnnual: oldAnnualFee ? oldAnnualFee / 100 : null,
          newPriceAnnual: overrideAnnualFee || null,
          reason: overrideReason || null
        }
      );

      res.json(updated);
    } catch (error: any) {
      console.error("Error setting pricing override:", error);
      res.status(500).json({ message: "Failed to set pricing override", error: error.message });
    }
  });

  app.post("/api/admin/instances/:organizationId/modules/:moduleId/override", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { organizationId, moduleId } = req.params;
      const { overrideMonthlyPrice, overrideAnnualPrice, reason } = req.body;

      const instanceSub = await storage.getInstanceSubscription(organizationId);
      if (!instanceSub) {
        return res.status(404).json({ message: "Instance subscription not found" });
      }

      // Get existing override if any
      const existingOverrides = await storage.getInstanceModuleOverrides(instanceSub.id);
      const existingOverride = existingOverrides.find(o => o.moduleId === moduleId && o.isActive);

      const oldMonthlyPrice = existingOverride?.overrideMonthlyPrice || null;
      const oldAnnualPrice = existingOverride?.overrideAnnualPrice || null;

      // Create or update override
      let override;
      if (existingOverride) {
        const { instanceModuleOverrides } = await import("@shared/schema");
        const [updated] = await db.update(instanceModuleOverrides)
          .set({
            overrideMonthlyPrice: overrideMonthlyPrice ? Math.round(overrideMonthlyPrice * 100) : null,
            overrideAnnualPrice: overrideAnnualPrice ? Math.round(overrideAnnualPrice * 100) : null,
            reason: reason || null,
            setBy: adminUser.id,
            date: new Date(),
            isActive: true
          })
          .where(eq(instanceModuleOverrides.id, existingOverride.id))
          .returning();
        override = updated;
      } else {
        override = await storage.createInstanceModuleOverride({
          instanceId: instanceSub.id,
          moduleId,
          overrideMonthlyPrice: overrideMonthlyPrice ? Math.round(overrideMonthlyPrice * 100) : null,
          overrideAnnualPrice: overrideAnnualPrice ? Math.round(overrideAnnualPrice * 100) : null,
          reason: reason || null,
          setBy: adminUser.id,
          date: new Date(),
          isActive: true
        });
      }

      // Create history record
      await storage.createPricingOverrideHistory({
        instanceId: instanceSub.id,
        overrideType: "module",
        targetId: moduleId,
        oldPriceMonthly: oldMonthlyPrice,
        newPriceMonthly: overrideMonthlyPrice ? Math.round(overrideMonthlyPrice * 100) : null,
        oldPriceAnnual: oldAnnualPrice,
        newPriceAnnual: overrideAnnualPrice ? Math.round(overrideAnnualPrice * 100) : null,
        reason: reason || null,
        changedBy: adminUser.id
      });

      // Send admin notification
      const modules = await storage.getMarketplaceModules();
      const module = modules.find(m => m.id === moduleId);
      const { notificationService } = await import("./notificationService");
      await notificationService.sendAdminPricingOverrideAlert(
        adminUser.id,
        organizationId,
        "module",
        {
          moduleName: module?.name || "Unknown Module",
          oldPriceMonthly: oldMonthlyPrice ? oldMonthlyPrice / 100 : null,
          newPriceMonthly: overrideMonthlyPrice || null,
          oldPriceAnnual: oldAnnualPrice ? oldAnnualPrice / 100 : null,
          newPriceAnnual: overrideAnnualPrice || null,
          reason: reason || null
        }
      );

      res.json(override);
    } catch (error: any) {
      console.error("Error setting module override:", error);
      res.status(500).json({ message: "Failed to set module override", error: error.message });
    }
  });

  app.get("/api/admin/instances/:organizationId/override-history", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { organizationId } = req.params;
      const instanceSub = await storage.getInstanceSubscription(organizationId);
      if (!instanceSub) {
        return res.status(404).json({ message: "Instance subscription not found" });
      }

      const { pricingOverrideHistory } = await import("@shared/schema");
      const history = await db.select()
        .from(pricingOverrideHistory)
        .where(eq(pricingOverrideHistory.instanceId, instanceSub.id))
        .orderBy(desc(pricingOverrideHistory.changeDate));

      res.json(history);
    } catch (error: any) {
      console.error("Error fetching override history:", error);
      res.status(500).json({ message: "Failed to fetch override history", error: error.message });
    }
  });

  // Get current organization subscription
  app.get("/api/billing/subscription", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      console.log(`[Get Subscription] Fetching subscription for org: ${user.organizationId}, user: ${user.id}`);

      // Get all subscriptions for this org to debug
      const allSubscriptions = await db
        .select()
        .from(subscriptions)
        .where(eq(subscriptions.organizationId, user.organizationId));

      console.log(`[Get Subscription] Found ${allSubscriptions.length} subscription(s) for org ${user.organizationId}:`,
        allSubscriptions.map(s => ({ id: s.id, status: s.status, planName: s.planSnapshotJson?.planName }))
      );

      const subscription = await storage.getSubscriptionByOrganization(user.organizationId);

      if (subscription) {
        console.log(`[Get Subscription] Returning subscription:`, {
          id: subscription.id,
          planName: subscription.planSnapshotJson?.planName,
          status: subscription.status,
          organizationId: subscription.organizationId,
          currentPeriodStart: subscription.currentPeriodStart,
          currentPeriodEnd: subscription.currentPeriodEnd
        });
      } else {
        console.log(`[Get Subscription] No subscription found for org: ${user.organizationId}`);
        console.log(`[Get Subscription] All subscriptions in DB for this org:`, allSubscriptions);
      }

      res.json(subscription || null);
    } catch (error: any) {
      console.error("[Get Subscription] Error fetching subscription:", error);
      console.error("[Get Subscription] Error stack:", error.stack);
      res.status(500).json({ message: "Failed to fetch subscription", error: error.message });
    }
  });

  // Get aggregate credit balance across all organizations for normalized email (detects duplicates)
  app.get("/api/billing/aggregate-credits", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId || !user.email) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Get all organizations associated with this normalized email
      const orgs = await storage.getOrganizationsByNormalizedEmail(user.email);

      // Get credit balances for each organization
      const orgBalances = await Promise.all(
        orgs.map(async (org) => {
          const balance = await storage.getCreditBalance(org.organizationId);
          return {
            organizationId: org.organizationId,
            organizationName: org.organizationName,
            userRole: org.userRole,
            credits: balance.current,
            rolled: balance.rolled,
            total: balance.total,
          };
        })
      );

      // Calculate aggregate totals
      const totalCredits = orgBalances.reduce((sum, org) => sum + org.credits, 0);
      const totalRolled = orgBalances.reduce((sum, org) => sum + org.rolled, 0);
      const grandTotal = orgBalances.reduce((sum, org) => sum + org.total, 0);

      // Find current org balance
      const currentOrgBalance = orgBalances.find(org => org.organizationId === user.organizationId);

      res.json({
        primaryOrganizationCredits: currentOrgBalance?.credits || 0,
        duplicateOrganizations: orgBalances.filter(org => org.organizationId !== user.organizationId),
        allOrganizations: orgBalances,
        totalCredits,
        totalRolled,
        grandTotal,
        hasDuplicates: orgBalances.length > 1,
      });
    } catch (error: any) {
      console.error("Error fetching aggregate credits:", error);
      res.status(500).json({ message: "Failed to fetch aggregate credits" });
    }
  });

  // Get recommended plan based on inspection slider value
  app.get("/api/billing/recommend-plan", async (req, res) => {
    try {
      const inspectionsNeeded = parseInt(req.query.inspections as string) || 10;
      const currency = ((req.query.currency as string) || "GBP").toUpperCase();

      const plans = await storage.getActivePlans();

      // Sort plans by included inspections
      const sortedPlans = plans
        .filter(p => ["freelancer", "btr", "pbsa", "housing_association", "council"].includes(p.code))
        .sort((a, b) => (a.includedInspections || 0) - (b.includedInspections || 0));

      // Find the smallest plan that covers the needed inspections
      let recommendedPlan = sortedPlans[sortedPlans.length - 1]; // Default to largest
      for (const plan of sortedPlans) {
        if ((plan.includedInspections || 0) >= inspectionsNeeded) {
          recommendedPlan = plan;
          break;
        }
      }

      // Get price based on currency
      const getCurrencyPrice = (plan: any, isAnnual: boolean) => {
        if (currency === "USD") {
          return isAnnual ? plan.annualPriceUsd : plan.monthlyPriceUsd;
        } else if (currency === "AED") {
          return isAnnual ? plan.annualPriceAed : plan.monthlyPriceAed;
        }
        return isAnnual ? plan.annualPriceGbp : plan.monthlyPriceGbp;
      };

      res.json({
        recommendedPlan: {
          id: recommendedPlan.id,
          code: recommendedPlan.code,
          name: recommendedPlan.name,
          includedInspections: recommendedPlan.includedInspections || recommendedPlan.includedCredits,
          monthlyPrice: getCurrencyPrice(recommendedPlan, false),
          annualPrice: getCurrencyPrice(recommendedPlan, true),
          topupPricePerInspection: currency === "USD" ? recommendedPlan.topupPricePerInspectionUsd :
            currency === "AED" ? recommendedPlan.topupPricePerInspectionAed :
              recommendedPlan.topupPricePerInspectionGbp,
          currency,
        },
        allPlans: sortedPlans.map(p => ({
          id: p.id,
          code: p.code,
          name: p.name,
          includedInspections: p.includedInspections || p.includedCredits,
          monthlyPrice: getCurrencyPrice(p, false),
          annualPrice: getCurrencyPrice(p, true),
          currency,
        })),
        inspectionsNeeded,
        needsContactForEnterprise: inspectionsNeeded > 2000,
      });
    } catch (error: any) {
      console.error("Error recommending plan:", error);
      res.status(500).json({ message: "Failed to recommend plan" });
    }
  });

  // Get automated tier recommendations based on usage (authenticated)
  app.get("/api/billing/recommend-tier", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Get current usage
      const balance = await storage.getCreditBalance(user.organizationId);
      const instanceSub = await storage.getInstanceSubscription(user.organizationId);
      
      // Calculate average monthly usage (if available)
      let averageMonthlyUsage = 0;
      if (instanceSub) {
        const quotaIncluded = instanceSub.inspectionQuotaIncluded || 0;
        const used = quotaIncluded - balance.total;
        averageMonthlyUsage = Math.max(used, 10); // Minimum 10
      }

      // Get inspections needed from query or calculate from usage
      const inspectionsNeeded = parseInt(req.query.inspections as string) || averageMonthlyUsage || 10;
      const currency = ((req.query.currency as string) || instanceSub?.registrationCurrency || "GBP").toUpperCase();

      // Get all available tiers (not just legacy plans)
      const tiers = await storage.getSubscriptionTiers();
      const activeTiers = tiers.filter(t => t.isActive !== false);

      // Sort tiers by included inspections
      const sortedTiers = [...activeTiers].sort((a, b) => a.includedInspections - b.includedInspections);

      // Find the smallest tier that covers the needed inspections
      let recommendedTier = sortedTiers[sortedTiers.length - 1]; // Default to largest
      for (const tier of sortedTiers) {
        if (tier.includedInspections >= inspectionsNeeded) {
          recommendedTier = tier;
          break;
        }
      }

      // Get current tier
      const currentTier = instanceSub?.currentTierId 
        ? tiers.find(t => t.id === instanceSub.currentTierId)
        : null;

      // Calculate pricing using pricingService
      const { pricingService } = await import("./pricingService");
      
      const recommendedMonthlyPrice = currentTier && instanceSub
        ? await pricingService.calculateInstancePrice(user.organizationId, "monthly")
        : 0;
      const recommendedAnnualPrice = currentTier && instanceSub
        ? await pricingService.calculateInstancePrice(user.organizationId, "annual")
        : 0;

      // Get tier pricing for recommended tier
      const recommendedTierPricing = await storage.getTierPricing(recommendedTier.id, currency);
      const recommendedMonthly = recommendedTierPricing?.priceMonthly || recommendedTier.basePriceMonthly || 0;
      const recommendedAnnual = recommendedTierPricing?.priceAnnual || recommendedTier.basePriceAnnual || 0;

      // Get all tier options with pricing
      const tierOptions = await Promise.all(sortedTiers.map(async (tier) => {
        const tierPricing = await storage.getTierPricing(tier.id, currency);
        const monthlyPrice = tierPricing?.priceMonthly || tier.basePriceMonthly || 0;
        const annualPrice = tierPricing?.priceAnnual || tier.basePriceAnnual || 0;
        
        return {
          id: tier.id,
          code: tier.code,
          name: tier.name,
          includedInspections: tier.includedInspections,
          monthlyPrice: monthlyPrice / 100,
          annualPrice: annualPrice / 100,
          currency,
          isCurrent: currentTier?.id === tier.id,
          isRecommended: tier.id === recommendedTier.id
        };
      }));

      // Determine if upgrade or downgrade
      const isUpgrade = currentTier 
        ? recommendedTier.includedInspections > currentTier.includedInspections
        : false;
      const isDowngrade = currentTier
        ? recommendedTier.includedInspections < currentTier.includedInspections
        : false;

      res.json({
        currentUsage: {
          averageMonthly: averageMonthlyUsage,
          currentQuota: instanceSub?.inspectionQuotaIncluded || 0,
          remainingCredits: balance.total
        },
        recommendedTier: {
          id: recommendedTier.id,
          code: recommendedTier.code,
          name: recommendedTier.name,
          includedInspections: recommendedTier.includedInspections,
          monthlyPrice: recommendedMonthly / 100,
          annualPrice: recommendedAnnual / 100,
          currency,
          reason: isUpgrade 
            ? `Your average usage (${averageMonthlyUsage}) exceeds your current plan. Upgrade recommended.`
            : isDowngrade
            ? `Your usage (${averageMonthlyUsage}) is below your current plan. Downgrade to save costs.`
            : `Based on your usage of ${averageMonthlyUsage} inspections per month.`
        },
        allTiers: tierOptions,
        currentTier: currentTier ? {
          id: currentTier.id,
          code: currentTier.code,
          name: currentTier.name,
          includedInspections: currentTier.includedInspections
        } : null,
        recommendation: {
          action: isUpgrade ? "upgrade" : isDowngrade ? "downgrade" : "maintain",
          savings: currentTier && isDowngrade && instanceSub
            ? {
                monthly: (recommendedMonthlyPrice / 100) - (recommendedMonthly / 100),
                annual: (recommendedAnnualPrice / 100) - (recommendedAnnual / 100)
              }
            : null
        },
        inspectionsNeeded,
        needsContactForEnterprise: inspectionsNeeded > 500,
      });
    } catch (error: any) {
      console.error("Error recommending tier:", error);
      res.status(500).json({ message: "Failed to recommend tier", error: error.message });
    }
  });

  // Get tier-based bundle pricing
  app.get("/api/billing/bundles", async (req, res) => {
    try {
      const currency = ((req.query.currency as string) || "GBP").toUpperCase();
      const planCode = req.query.planCode as string;

      const bundles = await storage.getActiveCreditBundles();
      const allTierPricing = await storage.getAllBundleTierPricing();

      const bundlesWithPricing = bundles.map(bundle => {
        // Find tier pricing for this bundle
        let pricing = allTierPricing.filter(tp => tp.bundleId === bundle.id);

        // If planCode provided, filter to that tier
        let effectivePrice = bundle.priceGbp; // Default Freelancer price
        if (planCode && pricing.length > 0) {
          const tierPricing = pricing.find(tp => tp.planCode === planCode);
          if (tierPricing) {
            effectivePrice = currency === "USD" ? tierPricing.priceUsd :
              currency === "AED" ? tierPricing.priceAed :
                tierPricing.priceGbp;
          }
        } else {
          effectivePrice = currency === "USD" ? bundle.priceUsd :
            currency === "AED" ? bundle.priceAed :
              bundle.priceGbp;
        }

        return {
          id: bundle.id,
          name: bundle.name,
          credits: bundle.credits,
          price: effectivePrice,
          currency,
          isPopular: bundle.isPopular,
          discountLabel: bundle.discountLabel,
          tierPricing: pricing.map(tp => ({
            planCode: tp.planCode,
            price: currency === "USD" ? tp.priceUsd :
              currency === "AED" ? tp.priceAed :
                tp.priceGbp,
            currency,
          })),
        };
      });

      res.json(bundlesWithPricing);
    } catch (error: any) {
      console.error("Error fetching bundles:", error);
      res.status(500).json({ message: "Failed to fetch bundles" });
    }
  });

  // DUPLICATE ENDPOINT REMOVED - Using the more comprehensive endpoint at line 2143

  // Cancel subscription with reason
  app.post("/api/billing/cancel", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only owners can cancel subscriptions
      if (user.role !== "owner") {
        return res.status(403).json({ message: "Only organization owners can cancel subscriptions" });
      }

      const { reason, reasonText, cancelImmediately } = req.body;
      if (!reason) {
        return res.status(400).json({ message: "Cancellation reason is required" });
      }

      const org = await storage.getOrganization(user.organizationId);
      if (!org) {
        return res.status(404).json({ message: "Organization not found" });
      }

      const subscription = await storage.getSubscriptionByOrganization(user.organizationId);
      if (!subscription) {
        return res.status(404).json({ message: "No active subscription found" });
      }

      // Cancel in Stripe
      if (subscription.stripeSubscriptionId) {
        const stripe = await getUncachableStripeClient();

        if (cancelImmediately) {
          await stripe.subscriptions.cancel(subscription.stripeSubscriptionId);
          
          // Handle immediate cancellation: expire credits and deactivate modules
          const instanceSub = await storage.getInstanceSubscription(user.organizationId);
          if (instanceSub) {
            // Deactivate all enabled modules
            const instanceModules = await storage.getInstanceModules(instanceSub.id);
            const enabledModules = instanceModules.filter(m => m.isEnabled);
            for (const module of enabledModules) {
              await storage.toggleInstanceModule(instanceSub.id, module.moduleId, false);
            }

            // Expire all credit batches
            const { subscriptionService: subService } = await import("./subscriptionService");
            const allBatches = await storage.getCreditBatchesByOrganization(user.organizationId);
            const activeBatches = allBatches.filter(b => b.remainingQuantity > 0);
            for (const batch of activeBatches) {
              await storage.expireCreditBatch(batch.id);
              await storage.createCreditLedgerEntry({
                organizationId: user.organizationId,
                source: "expiry" as any,
                quantity: -batch.remainingQuantity,
                batchId: batch.id,
                notes: `Expired ${batch.remainingQuantity} credits due to immediate cancellation`
              });
            }

            // Credits are already handled by expiring batches above
            // No need to update legacy creditsRemaining field as it's removed

            // Update instance subscription status
            await storage.updateInstanceSubscription(instanceSub.id, {
              subscriptionStatus: "inactive" as any,
            });

            // Send subscription cancelled notification
            try {
              const endDate = instanceSub.subscriptionRenewalDate || new Date();
              const { notificationService } = await import("./notificationService");
              await notificationService.sendSubscriptionCancelledNotification(
                user.organizationId,
                new Date(),
                endDate
              );
            } catch (notifError) {
              console.error("Error sending subscription cancelled notification:", notifError);
            }
          }
        } else {
          await stripe.subscriptions.update(subscription.stripeSubscriptionId, {
            cancel_at_period_end: true,
          });

          // Send subscription cancelled notification (at period end)
          try {
            const instanceSub = await storage.getInstanceSubscription(user.organizationId);
            if (instanceSub && instanceSub.subscriptionRenewalDate) {
              const { notificationService } = await import("./notificationService");
              await notificationService.sendSubscriptionCancelledNotification(
                user.organizationId,
                new Date(),
                instanceSub.subscriptionRenewalDate
              );
            }
          } catch (notifError) {
            console.error("Error sending subscription cancelled notification:", notifError);
          }
        }
      }

      // Update subscription in database
      await storage.updateSubscription(subscription.id, {
        cancelAtPeriodEnd: !cancelImmediately,
        cancellationReason: reason,
        cancellationReasonText: reasonText || null,
        cancelledAt: cancelImmediately ? new Date() : null,
        status: cancelImmediately ? "cancelled" : subscription.status,
      } as any);

      res.json({
        success: true,
        cancelledImmediately: cancelImmediately,
        cancelAtPeriodEnd: !cancelImmediately,
        currentPeriodEnd: subscription.currentPeriodEnd,
      });
    } catch (error: any) {
      console.error("Error cancelling subscription:", error);
      res.status(500).json({ message: "Failed to cancel subscription", error: error.message });
    }
  });

  // One-click upgrade/downgrade subscription (automated)
  app.post("/api/billing/upgrade-downgrade", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only owners can change subscriptions
      if (user.role !== "owner") {
        return res.status(403).json({ message: "Only organization owners can change plans" });
      }

      const { tierId, billingCycle, autoRecommend = false } = req.body;

      // If autoRecommend is true, get recommendation first
      let targetTierId = tierId;
      if (autoRecommend && !tierId) {
        const balance = await storage.getCreditBalance(user.organizationId);
        const instanceSub = await storage.getInstanceSubscription(user.organizationId);
        const quotaIncluded = instanceSub?.inspectionQuotaIncluded || 0;
        const averageUsage = Math.max(quotaIncluded - balance.total, 10);

        const tiers = await storage.getSubscriptionTiers();
        const activeTiers = tiers.filter(t => t.isActive !== false).sort((a, b) => a.includedInspections - b.includedInspections);
        
        for (const tier of activeTiers) {
          if (tier.includedInspections >= averageUsage) {
            targetTierId = tier.id;
            break;
          }
        }

        if (!targetTierId) {
          targetTierId = activeTiers[activeTiers.length - 1].id; // Default to largest
        }
      }

      if (!targetTierId) {
        return res.status(400).json({ message: "Tier ID is required or enable autoRecommend" });
      }

      const instanceSub = await storage.getInstanceSubscription(user.organizationId);
      if (!instanceSub) {
        return res.status(404).json({ message: "Instance subscription not found" });
      }

      const tiers = await storage.getSubscriptionTiers();
      const newTier = tiers.find(t => t.id === targetTierId);
      const currentTier = instanceSub.currentTierId ? tiers.find(t => t.id === instanceSub.currentTierId) : null;

      if (!newTier) {
        return res.status(404).json({ message: "Tier not found" });
      }

      if (currentTier && currentTier.id === newTier.id) {
        return res.status(400).json({ message: "Already on this tier" });
      }

      const isUpgrade = !currentTier || newTier.includedInspections > currentTier.includedInspections;
      const isDowngrade = currentTier ? newTier.includedInspections < currentTier.includedInspections : false;

      // Get pricing
      const targetBillingCycle = billingCycle || instanceSub.billingCycle || "monthly";
      const org = await storage.getOrganization(user.organizationId);
      const currency = instanceSub.registrationCurrency || org?.preferredCurrency || "GBP";
      
      // Get tier pricing
      const tierPricing = await storage.getTierPricing(newTier.id, currency);
      const newPrice = targetBillingCycle === "annual" 
        ? (tierPricing?.priceAnnual || newTier.basePriceAnnual || 0)
        : (tierPricing?.priceMonthly || newTier.basePriceMonthly || 0);
      
      // Convert to minor units if needed (prices are stored in minor units)
      const priceInMinorUnits = typeof newPrice === 'number' && newPrice < 1000 
        ? Math.round(newPrice * 100) 
        : (typeof newPrice === 'number' ? newPrice : 0);

      // Create Stripe checkout session for the upgrade/downgrade
      if (!org?.stripeCustomerId) {
        return res.status(400).json({ message: "No Stripe customer found. Please set up payment method first." });
      }

      const stripe = await getUncachableStripeClient();

      // Get active modules (excluding those in bundles) to include in checkout
      const instanceModules = await storage.getInstanceModules(instanceSub.id);
      const enabledModules = instanceModules.filter(m => m.isEnabled);
      
      // Get modules covered by bundles (these should not be charged separately)
      const { pricingService } = await import("./pricingService");
      const coveredModuleIds = await pricingService.getBundledModuleIds(instanceSub.id);
      
      // Filter out modules covered by bundles
      const modulesToCharge = enabledModules.filter(im => !coveredModuleIds.has(im.moduleId));
      
      // Get module details and calculate prorated credits
      const modules = await storage.getMarketplaceModules();
      const { calculateProRataWithPriority } = await import("./proRataService");
      
      let totalModuleCost = 0;
      let totalProratedCredit = 0;
      const moduleLineItems: any[] = [];
      const moduleCredits: Array<{ moduleId: string; moduleName: string; credit: number }> = [];
      const moduleNames: string[] = [];
      
      for (const instanceModule of modulesToCharge) {
        const module = modules.find(m => m.id === instanceModule.moduleId);
        if (!module) continue;
        
        const modulePrice = targetBillingCycle === "annual" 
          ? (instanceModule.annualPrice || 0)
          : (instanceModule.monthlyPrice || 0);
        
        if (modulePrice > 0) {
          
          // Calculate prorated credit for already-paid portion
          let moduleCredit = 0;
          if (instanceSub.subscriptionRenewalDate) {
            const proRataData = await calculateProRataWithPriority(
              modulePrice,
              user.organizationId,
              instanceSub.billingCycle,
              storage
            );
            
            if (proRataData && proRataData.result.isProrated) {
              moduleCredit = proRataData.result.proratedPrice;
              totalProratedCredit += moduleCredit;
              moduleCredits.push({
                moduleId: instanceModule.moduleId,
                moduleName: module.name,
                credit: moduleCredit
              });
            }
          }
          
          // Add module as line item with NET price (full price - prorated credit)
          // This shows modules in checkout with credit already applied
          const moduleNetPrice = Math.max(0, modulePrice - moduleCredit);
          
          moduleLineItems.push({
            price_data: {
              currency: currency.toLowerCase(),
              product_data: {
                name: module.name,
                description: `${module.name} module (${targetBillingCycle} billing)${moduleCredit > 0 ? ` - Prorated credit: ${currency} ${(moduleCredit / 100).toFixed(2)}` : ''}`
              },
              recurring: {
                interval: targetBillingCycle === "annual" ? "year" : "month"
              },
              unit_amount: moduleNetPrice
            },
            quantity: 1
          });
          
          totalModuleCost += modulePrice;
          moduleNames.push(module.name);
        }
      }

      // Build description to prominently show active modules and credits
      let tierDescription = `${isUpgrade ? 'Upgrade' : isDowngrade ? 'Downgrade' : 'Change'} to ${newTier.name} (${targetBillingCycle})`;
      
      if (moduleNames.length > 0) {
        tierDescription += `\n\nðŸ“¦ Active Modules (included below with prorated credits applied):\n${moduleNames.map((name, idx) => `${idx + 1}. ${name}`).join("\n")}`;
        
        if (totalProratedCredit > 0) {
          const creditAmount = (totalProratedCredit / 100).toFixed(2);
          tierDescription += `\n\nðŸ’° Total Prorated Credit Applied: ${currency} ${creditAmount}`;
          tierDescription += `\n(Credits for already-paid module subscriptions are deducted from module prices below)`;
          
          // Show per-module credits
          if (moduleCredits.length > 0) {
            tierDescription += `\n\nCredit Breakdown:`;
            moduleCredits.forEach(mc => {
              tierDescription += `\n  â€¢ ${mc.moduleName}: ${currency} ${(mc.credit / 100).toFixed(2)}`;
            });
          }
        }
      }

      // Note: Prorated credits are already applied in module line item prices (net price = full price - credit)
      // No need to create separate invoice items - the reduced price is shown directly in checkout
      if (totalProratedCredit > 0) {
        console.log(`[Tier Change] Applied prorated credits totaling ${(totalProratedCredit / 100).toFixed(2)} ${currency} to module prices in checkout`);
      }

      // Build line items: tier + modules (with prorated credits already applied in module prices)
      const lineItems: any[] = [
        {
          price_data: {
            currency: currency.toLowerCase(),
            product_data: {
              name: newTier.name,
              description: tierDescription
            },
            recurring: {
              interval: targetBillingCycle === "annual" ? "year" : "month"
            },
            unit_amount: priceInMinorUnits
          },
          quantity: 1
        },
        ...moduleLineItems // Add modules with net prices (prorated credits already deducted)
      ];

      // Create checkout session for tier change
      const checkoutSession = await stripe.checkout.sessions.create({
        customer: org.stripeCustomerId,
        payment_method_types: ["card"],
        mode: "subscription",
        line_items: lineItems,
        metadata: {
          organizationId: user.organizationId,
          type: "tier_change",
          currentTierId: currentTier?.id || "",
          newTierId: newTier.id,
          isUpgrade: isUpgrade.toString(),
          isDowngrade: (isDowngrade || false).toString(),
          billingCycle: targetBillingCycle,
          moduleCount: modulesToCharge.length.toString(),
          moduleNames: moduleNames.join(","),
          totalProratedCredit: totalProratedCredit.toString()
        },
        success_url: `${process.env.FRONTEND_URL || "http://localhost:5173"}/billing?session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${process.env.FRONTEND_URL || "http://localhost:5173"}/billing`
      });

      res.json({
        success: true,
        checkoutUrl: checkoutSession.url,
        sessionId: checkoutSession.id,
        action: isUpgrade ? "upgrade" : isDowngrade ? "downgrade" : "change",
        currentTier: currentTier ? {
          id: currentTier.id,
          name: currentTier.name,
          includedInspections: currentTier.includedInspections
        } : null,
        newTier: {
          id: newTier.id,
          name: newTier.name,
          includedInspections: newTier.includedInspections,
          price: priceInMinorUnits / 100,
          currency,
          billingCycle: targetBillingCycle
        },
        modules: moduleNames.length > 0 ? {
          count: moduleNames.length,
          names: moduleNames,
          totalCost: totalModuleCost / 100,
          proratedCredit: totalProratedCredit > 0 ? totalProratedCredit / 100 : 0,
          moduleCredits: moduleCredits.map(mc => ({
            moduleName: mc.moduleName,
            credit: mc.credit / 100
          }))
        } : null,
        message: isUpgrade 
          ? `Upgrading to ${newTier.name} will increase your monthly inspections from ${currentTier?.includedInspections || 0} to ${newTier.includedInspections}.${moduleNames.length > 0 ? ` Active modules (${moduleNames.join(", ")}) will continue with prorated credit applied.` : ""}`
          : isDowngrade
          ? `Downgrading to ${newTier.name} will reduce your monthly inspections from ${currentTier.includedInspections} to ${newTier.includedInspections}.${moduleNames.length > 0 ? ` Active modules (${moduleNames.join(", ")}) will continue with prorated credit applied.` : ""}`
          : `Changing to ${newTier.name}.${moduleNames.length > 0 ? ` Active modules (${moduleNames.join(", ")}) will continue with prorated credit applied.` : ""}`
      });
    } catch (error: any) {
      console.error("Error processing upgrade/downgrade:", error);
      res.status(500).json({ message: "Failed to process upgrade/downgrade", error: error.message });
    }
  });

  // Upgrade or downgrade subscription
  // Helper function to handle tier-based plan changes with modules and proration
  async function handleTierBasedPlanChange(
    req: any,
    res: any,
    user: any,
    org: any,
    tierId: string,
    billingInterval: string | undefined,
    currency: string | undefined,
    inspectionCount: number | undefined
  ) {
    try {
      const organizationId = user.organizationId;
      const billingPeriod = billingInterval || "monthly";
      const orgCurrency = currency || org.preferredCurrency || "GBP";
      
      // Get the tier
      const tiers = await storage.getSubscriptionTiers();
      const selectedTier = tiers.find(t => t.id === tierId);
      if (!selectedTier) {
        return res.status(404).json({ message: "Tier not found" });
      }

      // Get current instance subscription
      const instanceSub = await storage.getInstanceSubscription(organizationId);
      if (!instanceSub) {
        return res.status(404).json({ message: "No active subscription found" });
      }

      // Get current Stripe subscription
      const stripe = await getUncachableStripeClient();
      let stripeSubscription = null;
      
      if (org.stripeCustomerId) {
        try {
          const subscriptions = await stripe.subscriptions.list({
            customer: org.stripeCustomerId,
            status: "active",
            limit: 100
          });
          
          // Find subscription with matching tier or any active subscription
          for (const sub of subscriptions.data) {
            const subTierId = sub.metadata?.tierId;
            if (subTierId === tierId || subscriptions.data.length === 1) {
              stripeSubscription = sub;
              break;
            }
          }
          
          // If no matching subscription found, use the first active one
          if (!stripeSubscription && subscriptions.data.length > 0) {
            stripeSubscription = subscriptions.data[0];
          }
        } catch (listError: any) {
          console.error(`[Plan Change] Error listing subscriptions:`, listError.message);
          return res.status(500).json({ message: "Failed to retrieve subscription" });
        }
      }

      if (!stripeSubscription) {
        return res.status(404).json({ message: "No active Stripe subscription found" });
      }

      // Calculate tier pricing
      const { pricingService } = await import("./pricingService");
      const totalInspections = Number(inspectionCount) || instanceSub.inspectionQuotaIncluded || selectedTier.includedInspections;
      const pricingResult = await pricingService.calculatePricing(
        totalInspections,
        orgCurrency,
        organizationId
      );

      const tierAmount = billingPeriod === "annual" 
        ? pricingResult.calculations.baseAnnual 
        : pricingResult.calculations.baseMonthly;

      // Get active modules (excluding those in bundles) to include in plan change
      const instanceModules = await storage.getInstanceModules(instanceSub.id);
      const enabledModules = instanceModules.filter(m => m.isEnabled);
      const coveredModuleIds = await pricingService.getBundledModuleIds(instanceSub.id);
      const modulesToInclude = enabledModules.filter(im => !coveredModuleIds.has(im.moduleId));

      // Get modules already in subscription
      const modulesAlreadyInSubscription = new Set<string>();
      const subscriptionModuleNames = stripeSubscription.metadata?.moduleNames;
      if (subscriptionModuleNames) {
        const moduleNameList = subscriptionModuleNames.split(',').filter(Boolean);
        const modules = await storage.getMarketplaceModules();
        for (const moduleName of moduleNameList) {
          const matchedModule = modules.find(m => m.name === moduleName.trim());
          if (matchedModule) {
            modulesAlreadyInSubscription.add(matchedModule.id);
          }
        }
      }

      // Calculate module proration and create line items
      const moduleLineItems: any[] = [];
      let totalProratedCredit = 0;
      const moduleNames: string[] = [];
      const { calculateProRataWithPriority } = await import("./proRataService");
      const allModules = await storage.getMarketplaceModules();

      for (const instanceModule of modulesToInclude) {
        const module = allModules.find(m => m.id === instanceModule.moduleId);
        if (!module) continue;

        const modulePrice = billingPeriod === "annual" 
          ? (instanceModule.annualPrice || 0)
          : (instanceModule.monthlyPrice || 0);
        
        if (modulePrice > 0) {
          // Calculate prorated credit for already-paid portion
          let moduleCredit = 0;
          if (instanceSub.subscriptionRenewalDate) {
            const proRataData = await calculateProRataWithPriority(
              modulePrice,
              organizationId,
              billingPeriod as "monthly" | "annual",
              storage
            );
            if (proRataData && proRataData.result.isProrated) {
              moduleCredit = proRataData.result.proratedPrice;
              totalProratedCredit += moduleCredit;
            }
          }
          
          const moduleNetPrice = Math.max(0, modulePrice - moduleCredit);
          
          if (moduleNetPrice > 0 || modulesAlreadyInSubscription.has(instanceModule.moduleId)) {
            moduleLineItems.push({
              price_data: {
                currency: orgCurrency.toLowerCase(),
                product_data: {
                  name: module.name,
                  description: `${module.name} module (${billingPeriod} billing)${moduleCredit > 0 ? ` - Prorated credit: ${orgCurrency} ${(moduleCredit / 100).toFixed(2)} applied` : ''}`
                },
                recurring: {
                  interval: billingPeriod === "annual" ? "year" : "month"
                },
                unit_amount: moduleNetPrice
              }
            });
            moduleNames.push(module.name);
          }
        }
      }

      // Build subscription update items
      const updateItems: any[] = [];
      
      // Update tier item
      const tierItem = stripeSubscription.items.data.find(item => {
        const product = item.price?.product;
        const productName = (typeof product === 'object' && product && 'name' in product) 
          ? (product.name || '') 
          : (item.price?.nickname || '');
        return productName && (productName.includes('Plan') || productName.includes('Inspect360'));
      });

      if (tierItem) {
        // Create new price for updated tier
        const newTierPrice = await stripe.prices.create({
          currency: orgCurrency.toLowerCase(),
          product_data: {
            name: `Inspect360 ${selectedTier.name} Plan${moduleNames.length > 0 ? ` + ${moduleNames.length} Active Module${moduleNames.length > 1 ? 's' : ''}` : ''}`,
          },
          recurring: {
            interval: billingPeriod === "annual" ? "year" : "month",
          },
          unit_amount: tierAmount,
        });
        
        updateItems.push({
          id: tierItem.id,
          price: newTierPrice.id,
        });
      }

      // Add/update module items
      for (const moduleItem of moduleLineItems) {
        const existingModuleItem = stripeSubscription.items.data.find(item => {
          const product = item.price?.product;
          const productName = (typeof product === 'object' && product && 'name' in product) 
            ? (product.name || '') 
            : (item.price?.nickname || '');
          const matchedModule = allModules.find(m => productName === m.name || productName.includes(m.name));
          return matchedModule && modulesToInclude.some(im => im.moduleId === matchedModule.id);
        });

        const modulePrice = await stripe.prices.create({
          currency: moduleItem.price_data.currency,
          product_data: {
            name: moduleItem.price_data.product_data.name,
          },
          recurring: moduleItem.price_data.recurring,
          unit_amount: moduleItem.price_data.unit_amount,
        });

        if (existingModuleItem) {
          updateItems.push({
            id: existingModuleItem.id,
            price: modulePrice.id,
          });
        } else {
          updateItems.push({
            price: modulePrice.id,
          });
        }
      }

      // Remove modules that are disabled but still in subscription
      for (const item of stripeSubscription.items.data) {
        const product = item.price?.product;
        const productName = (typeof product === 'object' && product && 'name' in product) 
          ? (product.name || '') 
          : (item.price?.nickname || '');
        
        const isModuleItem = allModules.some(m => productName === m.name || productName.includes(m.name));
        const isTierItem = productName && (productName.includes('Plan') || productName.includes('Inspect360'));

        if (isModuleItem && !isTierItem) {
          const matchedModule = allModules.find(m => productName === m.name || productName.includes(m.name));
          const isModuleStillEnabled = matchedModule ? enabledModules.some(im => im.moduleId === matchedModule.id) : false;
          const isModuleCoveredByBundle = matchedModule ? coveredModuleIds.has(matchedModule.id) : false;

          if (!isModuleStillEnabled || isModuleCoveredByBundle) {
            updateItems.push({ id: item.id, deleted: true });
          }
        }
      }

      // Update Stripe subscription
      await stripe.subscriptions.update(stripeSubscription.id, {
        items: updateItems,
        proration_behavior: "always_invoice",
        metadata: {
          ...stripeSubscription.metadata,
          organizationId: organizationId,
          tierId: selectedTier.id,
          planCode: selectedTier.code,
          billingPeriod: billingPeriod,
          currency: orgCurrency,
          requestedInspections: totalInspections.toString(),
          type: "tier_subscription",
          moduleCount: modulesToInclude.length.toString(),
          moduleNames: moduleNames.join(","),
          totalProratedCredit: totalProratedCredit.toString()
        }
      });

      // Update instance subscription in database
      await storage.updateInstanceSubscription(instanceSub.id, {
        currentTierId: selectedTier.id,
        inspectionQuotaIncluded: totalInspections,
        billingCycle: billingPeriod as any,
        registrationCurrency: orgCurrency as any,
        subscriptionStatus: "active",
      });

      // Reset credits to new quota
      const { subscriptionService: subService } = await import("./subscriptionService");
      const existingBatches = await storage.getCreditBatchesByOrganization(organizationId);
      const planBatches = existingBatches.filter(b => 
        b.grantSource === 'plan_inclusion' && 
        b.remainingQuantity > 0 &&
        !b.rolled
      );

      if (planBatches.length > 0) {
        console.log(`[Plan Change] Resetting ${planBatches.length} existing plan_inclusion batches for org ${organizationId}`);
        for (const batch of planBatches) {
          await storage.expireCreditBatch(batch.id);
          await storage.createCreditLedgerEntry({
            organizationId: organizationId,
            source: "expiry" as any,
            quantity: -batch.remainingQuantity,
            batchId: batch.id,
            notes: `Expired ${batch.remainingQuantity} credits due to plan change to ${selectedTier.code}`
          });
        }
      }

      // Grant new quota
      const renewalDate = instanceSub.subscriptionRenewalDate || new Date(Date.now() + (billingPeriod === "annual" ? 365 : 30) * 24 * 60 * 60 * 1000);
      await subService.grantCredits(
        organizationId,
        totalInspections,
        "plan_inclusion",
        renewalDate,
        { adminNotes: `Plan changed to ${selectedTier.code} (${selectedTier.name})` }
      );

      console.log(`[Plan Change] Updated tier to ${selectedTier.name} with ${moduleNames.length} modules and granted ${totalInspections} credits to org ${organizationId}`);

      return res.json({
        success: true,
        isUpgrade: totalInspections > (instanceSub.inspectionQuotaIncluded || 0),
        newTier: {
          id: selectedTier.id,
          code: selectedTier.code,
          name: selectedTier.name,
          includedInspections: totalInspections,
        },
        modules: moduleNames,
        proratedCredit: totalProratedCredit / 100,
      });
    } catch (error: any) {
      console.error("Error in tier-based plan change:", error);
      return res.status(500).json({ message: "Failed to change plan", error: error.message });
    }
  }

  app.post("/api/billing/change-plan", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only owners can change subscriptions
      if (user.role !== "owner") {
        return res.status(403).json({ message: "Only organization owners can change plans" });
      }

      const { newPlanCode, billingInterval, tierId, autoRecommend = false, currency, inspectionCount } = req.body;
      
      // PRIORITY: Tier-based subscriptions (tierId) take precedence over legacy plan codes
      // Support both for backward compatibility, but prioritize tierId
      if (!tierId && !newPlanCode && !autoRecommend) {
        return res.status(400).json({ message: "Tier ID, plan code, or autoRecommend is required" });
      }

      const org = await storage.getOrganization(user.organizationId);
      if (!org) {
        return res.status(404).json({ message: "Organization not found" });
      }

      // PRIORITY 1: Handle tier-based subscription change (preferred method)
      if (tierId) {
        return await handleTierBasedPlanChange(req, res, user, org, tierId, billingInterval, currency, inspectionCount);
      }

      // PRIORITY 2: Handle auto-recommendation
      if (autoRecommend) {
        // Get current usage and recommend tier
        // For now, use the current tier (auto-recommendation can be enhanced later)
        const instanceSub = await storage.getInstanceSubscription(user.organizationId);
        if (instanceSub?.currentTierId) {
          return await handleTierBasedPlanChange(req, res, user, org, instanceSub.currentTierId, billingInterval, currency, inspectionCount);
        }
        return res.status(400).json({ message: "Could not determine current tier for recommendation" });
      }

      // PRIORITY 3: Legacy plan code support (for backward compatibility)
      const subscription = await storage.getSubscriptionByOrganization(user.organizationId);
      if (!subscription?.stripeSubscriptionId) {
        return res.status(400).json({ message: "No active Stripe subscription to change" });
      }

      const newPlan = await storage.getPlanByCode(newPlanCode);
      if (!newPlan) {
        return res.status(404).json({ message: "New plan not found" });
      }

      const currentPlan = subscription.planSnapshotJson;
      const isUpgrade = (newPlan.includedInspections || newPlan.includedCredits) >
        (currentPlan?.includedInspections || currentPlan?.includedCredits || 0);

      // Get the Stripe subscription to modify
      const stripe = await getUncachableStripeClient();
      const stripeSubscription = await stripe.subscriptions.retrieve(subscription.stripeSubscriptionId);

      // IMPORTANT: Cancel all other active Stripe subscriptions for this organization
      // This ensures only the latest plan is renewed, preventing double billing
      if (org.stripeCustomerId) {
        try {
          const allSubscriptions = await stripe.subscriptions.list({
            customer: org.stripeCustomerId,
            status: "active",
            limit: 100
          });

          // Cancel all subscriptions except the one we're updating
          for (const sub of allSubscriptions.data) {
            if (sub.id !== subscription.stripeSubscriptionId && sub.status === "active") {
              console.log(`[Plan Change] Cancelling old subscription ${sub.id} for org ${user.organizationId} (keeping ${subscription.stripeSubscriptionId})`);
              try {
                await stripe.subscriptions.cancel(sub.id);
                console.log(`[Plan Change] Successfully cancelled old subscription ${sub.id}`);
              } catch (cancelError: any) {
                console.error(`[Plan Change] Failed to cancel subscription ${sub.id}:`, cancelError.message);
                // Continue with plan change even if cancellation fails
              }
            }
          }
        } catch (listError: any) {
          console.error(`[Plan Change] Error listing subscriptions:`, listError.message);
          // Continue with plan change even if listing fails
        }
      }

      // Determine pricing based on currency and interval
      const orgCurrency = org.preferredCurrency || "GBP";
      const isAnnual = billingInterval === "annual";

      let unitAmount: number;
      if (orgCurrency === "USD") {
        unitAmount = isAnnual ? (newPlan.annualPriceUsd || newPlan.monthlyPriceUsd! * 12) : newPlan.monthlyPriceUsd!;
      } else if (orgCurrency === "AED") {
        unitAmount = isAnnual ? (newPlan.annualPriceAed || newPlan.monthlyPriceAed! * 12) : newPlan.monthlyPriceAed!;
      } else {
        unitAmount = isAnnual ? (newPlan.annualPriceGbp || newPlan.monthlyPriceGbp * 12) : newPlan.monthlyPriceGbp;
      }

      // Create a new price for the subscription
      const subscriptionItemId = stripeSubscription.items.data[0]?.id;
      if (!subscriptionItemId) {
        return res.status(400).json({ message: "Invalid subscription state" });
      }

      // Create a Stripe Price first (required for subscription updates)
      // First create or get the product
      const product = await stripe.products.create({
              name: newPlan.name,
      });
      
      const stripePrice = await stripe.prices.create({
        currency: orgCurrency.toLowerCase(),
        product: product.id,
            recurring: {
              interval: isAnnual ? "year" : "month",
            },
            unit_amount: unitAmount,
      });

      // IMPORTANT: Handle modules in legacy plan change
      // Get active modules (excluding those in bundles) to include in plan change
      const instanceSub = await storage.getInstanceSubscription(user.organizationId);
      const updateItems: any[] = [{
          id: subscriptionItemId,
          price: stripePrice.id,
      }];

      if (instanceSub) {
        const instanceModules = await storage.getInstanceModules(instanceSub.id);
        const enabledModules = instanceModules.filter(m => m.isEnabled);
        const { pricingService } = await import("./pricingService");
        const coveredModuleIds = await pricingService.getBundledModuleIds(instanceSub.id);
        const modulesToInclude = enabledModules.filter(im => !coveredModuleIds.has(im.moduleId));

        // Get modules already in subscription
        const modulesAlreadyInSubscription = new Set<string>();
        const subscriptionModuleNames = stripeSubscription.metadata?.moduleNames;
        if (subscriptionModuleNames) {
          const moduleNameList = subscriptionModuleNames.split(',').filter(Boolean);
          const allModules = await storage.getMarketplaceModules();
          for (const moduleName of moduleNameList) {
            const matchedModule = allModules.find(m => m.name === moduleName.trim());
            if (matchedModule) {
              modulesAlreadyInSubscription.add(matchedModule.id);
            }
          }
        }

        // Calculate module proration and create line items
        const { calculateProRataWithPriority } = await import("./proRataService");
        const allModules = await storage.getMarketplaceModules();
        const moduleNames: string[] = [];

        for (const instanceModule of modulesToInclude) {
          const module = allModules.find(m => m.id === instanceModule.moduleId);
          if (!module) continue;

          const modulePrice = isAnnual 
            ? (instanceModule.annualPrice || 0)
            : (instanceModule.monthlyPrice || 0);
          
          if (modulePrice > 0) {
            // Calculate prorated credit for already-paid portion
            let moduleCredit = 0;
            if (instanceSub.subscriptionRenewalDate) {
              const proRataData = await calculateProRataWithPriority(
                modulePrice,
                user.organizationId,
                isAnnual ? "annual" : "monthly",
                storage
              );
              if (proRataData && proRataData.result.isProrated) {
                moduleCredit = proRataData.result.proratedPrice;
              }
            }
            
            const moduleNetPrice = Math.max(0, modulePrice - moduleCredit);
            
            // Check if module is already in subscription
            const existingModuleItem = stripeSubscription.items.data.find(item => {
              const product = item.price?.product;
              const productName = (typeof product === 'object' && product && 'name' in product) 
                ? (product.name || '') 
                : (item.price?.nickname || '');
              return productName === module.name || productName.includes(module.name);
            });

            if (existingModuleItem) {
              // Update existing module item
              const moduleStripePrice = await stripe.prices.create({
                currency: orgCurrency.toLowerCase(),
                product_data: {
                  name: module.name,
                },
                recurring: {
                  interval: isAnnual ? "year" : "month"
                },
                unit_amount: moduleNetPrice
              });
              
              updateItems.push({
                id: existingModuleItem.id,
                price: moduleStripePrice.id,
              });
            } else if (moduleNetPrice > 0) {
              // Add new module item
              const moduleStripePrice = await stripe.prices.create({
                currency: orgCurrency.toLowerCase(),
                product_data: {
                  name: module.name,
                },
                recurring: {
                  interval: isAnnual ? "year" : "month"
                },
                unit_amount: moduleNetPrice
              });
              
              updateItems.push({
                price: moduleStripePrice.id,
              });
            }
            
            if (moduleNetPrice > 0 || modulesAlreadyInSubscription.has(instanceModule.moduleId)) {
              moduleNames.push(module.name);
            }
          }
        }

        // Remove modules that are disabled but still in subscription
        for (const item of stripeSubscription.items.data) {
          const product = item.price?.product;
          const productName = (typeof product === 'object' && product && 'name' in product) 
            ? (product.name || '') 
            : (item.price?.nickname || '');
          
          // Skip the main tier subscription item
          if (item.id === subscriptionItemId) {
            continue;
          }
          
          const isModuleItem = allModules.some(m => productName === m.name || productName.includes(m.name));
          if (isModuleItem) {
            const matchedModule = allModules.find(m => productName === m.name || productName.includes(m.name));
            const isModuleStillEnabled = matchedModule ? enabledModules.some(im => im.moduleId === matchedModule.id) : false;
            const isModuleCoveredByBundle = matchedModule ? coveredModuleIds.has(matchedModule.id) : false;

            if (!isModuleStillEnabled || isModuleCoveredByBundle) {
              updateItems.push({ id: item.id, deleted: true });
            }
          }
        }

        // Update subscription metadata with module information
        await stripe.subscriptions.update(subscription.stripeSubscriptionId, {
          items: updateItems,
        proration_behavior: isUpgrade ? "create_prorations" : "none",
          metadata: {
            ...stripeSubscription.metadata,
            moduleCount: moduleNames.length.toString(),
            moduleNames: moduleNames.join(","),
          }
        });
      } else {
        // No instance subscription, just update tier
        await stripe.subscriptions.update(subscription.stripeSubscriptionId, {
          items: updateItems,
          proration_behavior: isUpgrade ? "create_prorations" : "none",
        });
      }

      // Update subscription in database
      await storage.updateSubscription(subscription.id, {
        planSnapshotJson: {
          planId: newPlan.id,
          planCode: newPlan.code,
          planName: newPlan.name,
          monthlyPrice: newPlan.monthlyPriceGbp,
          annualPrice: newPlan.annualPriceGbp || undefined,
          includedCredits: newPlan.includedCredits,
          includedInspections: newPlan.includedInspections || newPlan.includedCredits,
          currency: orgCurrency,
        },
        billingInterval: isAnnual ? "annual" : "monthly",
      } as any);

      // Update organization's included inspections
      await storage.updateOrganization(user.organizationId, {
        includedInspectionsPerMonth: newPlan.includedInspections || newPlan.includedCredits,
        currentPlanId: newPlan.id,
        subscriptionLevel: newPlan.code as any,
      });

      // Handle tier-based subscriptions: update instanceSubscriptions and reset credits
      // Reuse instanceSub from module handling above, or get it if not already retrieved
      const instanceSubForTier = instanceSub || await storage.getInstanceSubscription(user.organizationId);
      if (instanceSubForTier) {
        // Find tier by plan code
        const tiers = await storage.getSubscriptionTiers();
        const newTier = tiers.find(t => t.code === newPlanCode);
        
        if (newTier) {
          const newQuota = newPlan.includedInspections || newPlan.includedCredits;
          
          // Update instance subscription
          await storage.updateInstanceSubscription(instanceSubForTier.id, {
            currentTierId: newTier.id,
            inspectionQuotaIncluded: newQuota,
            billingCycle: isAnnual ? "annual" : "monthly" as any,
          });

          // Reset credits to new quota (expire old plan_inclusion batches, grant new)
          const { subscriptionService: subService } = await import("./subscriptionService");
          const existingBatches = await storage.getCreditBatchesByOrganization(user.organizationId);
          const planBatches = existingBatches.filter(b => 
            b.grantSource === 'plan_inclusion' && 
            b.remainingQuantity > 0 &&
            !b.rolled
          );

          if (planBatches.length > 0) {
            console.log(`[Plan Change] Resetting ${planBatches.length} existing plan_inclusion batches for org ${user.organizationId}`);
            for (const batch of planBatches) {
              await storage.expireCreditBatch(batch.id);
              await storage.createCreditLedgerEntry({
                organizationId: user.organizationId,
                source: "expiry" as any,
                quantity: -batch.remainingQuantity,
                batchId: batch.id,
                notes: `Expired ${batch.remainingQuantity} credits due to plan change to ${newPlan.code}`
              });
            }
          }

          // Grant new quota
          const renewalDate = instanceSubForTier.subscriptionRenewalDate || new Date(Date.now() + (isAnnual ? 365 : 30) * 24 * 60 * 60 * 1000);
          await subService.grantCredits(
            user.organizationId,
            newQuota,
            "plan_inclusion",
            renewalDate,
            { adminNotes: `Plan changed to ${newPlan.code} (${newPlan.name})` }
          );
          
          console.log(`[Plan Change] Updated tier to ${newTier.name} and granted ${newQuota} credits to org ${user.organizationId}`);
        }
      }

      res.json({
        success: true,
        isUpgrade,
        newPlan: {
          code: newPlan.code,
          name: newPlan.name,
          includedInspections: newPlan.includedInspections || newPlan.includedCredits,
        },
      });
    } catch (error: any) {
      console.error("Error changing plan:", error);
      res.status(500).json({ message: "Failed to change plan", error: error.message });
    }
  });

  // Monthly Reset Endpoint (for scheduled jobs)
  app.post("/api/admin/billing/monthly-reset", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { monthlyResetService } = await import("./monthlyResetService");
      const result = await monthlyResetService.processMonthlyResets();

      res.json({
        success: true,
        processed: result.processed,
        errors: result.errors
      });
    } catch (error: any) {
      console.error("Error processing monthly reset:", error);
      res.status(500).json({ message: "Failed to process monthly reset", error: error.message });
    }
  });

  // Export invoices to CSV
  app.get("/api/billing/invoices/export", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { startDate, endDate, format = "csv" } = req.query;
      
      // Get invoices for the organization
      const { invoices: invoicesTable } = await import("@shared/schema");
      const { db } = await import("./db");
      const { eq, and, gte, lte } = await import("drizzle-orm");
      
      // Build conditions array
      const conditions: any[] = [eq(invoicesTable.organizationId, user.organizationId)];
      if (startDate) {
        conditions.push(gte(invoicesTable.periodStart, new Date(startDate as string)));
      }
      if (endDate) {
        conditions.push(lte(invoicesTable.periodEnd, new Date(endDate as string)));
      }
      
      const invoiceList = await db.select()
        .from(invoicesTable)
        .where(and(...conditions));

      if (format === "csv") {
        // Generate CSV
        const csvHeaders = [
          "Invoice Number",
          "Date",
          "Period Start",
          "Period End",
          "Billing Cycle",
          "Currency",
          "Subtotal",
          "Discount",
          "Total",
          "Status",
          "Due Date",
          "Paid Date"
        ];

        const csvRows = invoiceList.map(inv => [
          inv.invoiceNumber,
          inv.createdAt?.toISOString().split('T')[0] || '',
          inv.periodStart.toISOString().split('T')[0],
          inv.periodEnd.toISOString().split('T')[0],
          inv.billingCycle,
          inv.currencyCode,
          (inv.subtotal / 100).toFixed(2),
          (inv.discount || 0) / 100,
          (inv.total / 100).toFixed(2),
          inv.status || 'draft',
          inv.dueDate?.toISOString().split('T')[0] || '',
          inv.paidAt?.toISOString().split('T')[0] || ''
        ]);

        const csvContent = [
          csvHeaders.join(','),
          ...csvRows.map(row => row.map(cell => `"${cell}"`).join(','))
        ].join('\n');

        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename="invoices-${new Date().toISOString().split('T')[0]}.csv"`);
        res.send(csvContent);
      } else {
        // JSON format
        res.json({
          invoices: invoiceList.map(inv => ({
            invoiceNumber: inv.invoiceNumber,
            date: inv.createdAt?.toISOString(),
            periodStart: inv.periodStart.toISOString(),
            periodEnd: inv.periodEnd.toISOString(),
            billingCycle: inv.billingCycle,
            currency: inv.currencyCode,
            subtotal: inv.subtotal / 100,
            discount: (inv.discount || 0) / 100,
            total: inv.total / 100,
            status: inv.status,
            dueDate: inv.dueDate?.toISOString(),
            paidAt: inv.paidAt?.toISOString(),
            lineItems: inv.lineItems
          })),
          total: invoiceList.reduce((sum, inv) => sum + inv.total, 0) / 100,
          count: invoiceList.length
        });
      }
    } catch (error: any) {
      console.error("Error exporting invoices:", error);
      res.status(500).json({ message: "Failed to export invoices", error: error.message });
    }
  });

  // Get billing report
  app.get("/api/billing/reports", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { startDate, endDate, type = "summary" } = req.query;
      
      const { invoices: invoicesTable, instanceSubscriptions } = await import("@shared/schema");
      const { db } = await import("./db");
      const { eq, and, gte, lte } = await import("drizzle-orm");
      
      // Build date filter
      const conditions: any[] = [eq(invoicesTable.organizationId, user.organizationId)];
      if (startDate) {
        conditions.push(gte(invoicesTable.periodStart, new Date(startDate as string)));
      }
      if (endDate) {
        conditions.push(lte(invoicesTable.periodEnd, new Date(endDate as string)));
      }
      
      const invoiceList = await db.select()
        .from(invoicesTable)
        .where(and(...conditions));

      // Get subscription info
      const instanceSub = await storage.getInstanceSubscription(user.organizationId);
      
      if (type === "summary") {
        const totalRevenue = invoiceList
          .filter(inv => inv.status === "paid")
          .reduce((sum, inv) => sum + inv.total, 0) / 100;
        
        const totalInvoices = invoiceList.length;
        const paidInvoices = invoiceList.filter(inv => inv.status === "paid").length;
        const pendingInvoices = invoiceList.filter(inv => inv.status === "draft" || inv.status === "sent").length;
        const overdueInvoices = invoiceList.filter(inv => {
          if (inv.status !== "paid" && inv.dueDate) {
            return new Date(inv.dueDate) < new Date();
          }
          return false;
        }).length;

        // Group by currency
        const revenueByCurrency = invoiceList
          .filter(inv => inv.status === "paid")
          .reduce((acc: any, inv) => {
            const currency = inv.currencyCode;
            if (!acc[currency]) {
              acc[currency] = { total: 0, count: 0 };
            }
            acc[currency].total += inv.total / 100;
            acc[currency].count += 1;
            return acc;
          }, {});

        res.json({
          period: {
            start: startDate || null,
            end: endDate || null
          },
          summary: {
            totalRevenue,
            totalInvoices,
            paidInvoices,
            pendingInvoices,
            overdueInvoices,
            revenueByCurrency
          },
          currentSubscription: instanceSub ? {
            tier: instanceSub.currentTierId,
            billingCycle: instanceSub.billingCycle,
            status: instanceSub.subscriptionStatus
          } : null
        });
      } else if (type === "detailed") {
        res.json({
          period: {
            start: startDate || null,
            end: endDate || null
          },
          invoices: invoiceList.map(inv => ({
            invoiceNumber: inv.invoiceNumber,
            date: inv.createdAt?.toISOString(),
            periodStart: inv.periodStart.toISOString(),
            periodEnd: inv.periodEnd.toISOString(),
            billingCycle: inv.billingCycle,
            currency: inv.currencyCode,
            subtotal: inv.subtotal / 100,
            discount: (inv.discount || 0) / 100,
            total: inv.total / 100,
            status: inv.status,
            dueDate: inv.dueDate?.toISOString(),
            paidAt: inv.paidAt?.toISOString(),
            lineItems: inv.lineItems
          }))
        });
      } else {
        res.status(400).json({ message: "Invalid report type. Use 'summary' or 'detailed'" });
      }
    } catch (error: any) {
      console.error("Error generating billing report:", error);
      res.status(500).json({ message: "Failed to generate billing report", error: error.message });
    }
  });

  // Get revenue report (admin only)
  app.get("/api/admin/billing/revenue-report", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { startDate, endDate, organizationId, groupBy = "month" } = req.query;
      
      const { invoices: invoicesTable } = await import("@shared/schema");
      const { db } = await import("./db");
      const { eq, and, gte, lte } = await import("drizzle-orm");
      
      let conditions: any[] = [];
      if (organizationId) {
        conditions.push(eq(invoicesTable.organizationId, organizationId as string));
      }
      if (startDate) {
        conditions.push(gte(invoicesTable.periodStart, new Date(startDate as string)));
      }
      if (endDate) {
        conditions.push(lte(invoicesTable.periodEnd, new Date(endDate as string)));
      }
      
      const invoiceList = conditions.length > 0
        ? await db.select().from(invoicesTable).where(and(...conditions))
        : await db.select().from(invoicesTable);

      // Filter paid invoices only
      const paidInvoices = invoiceList.filter(inv => inv.status === "paid");

      // Group revenue by period
      const revenueByPeriod: Record<string, { revenue: number; count: number; currency: string }> = {};
      
      paidInvoices.forEach(inv => {
        let periodKey: string;
        if (groupBy === "month") {
          periodKey = inv.periodStart.toISOString().slice(0, 7); // YYYY-MM
        } else if (groupBy === "year") {
          periodKey = inv.periodStart.toISOString().slice(0, 4); // YYYY
        } else {
          periodKey = inv.periodStart.toISOString().split('T')[0]; // YYYY-MM-DD
        }

        if (!revenueByPeriod[periodKey]) {
          revenueByPeriod[periodKey] = { revenue: 0, count: 0, currency: inv.currencyCode };
        }
        revenueByPeriod[periodKey].revenue += inv.total / 100;
        revenueByPeriod[periodKey].count += 1;
      });

      // Revenue by organization
      const revenueByOrganization: Record<string, { revenue: number; count: number; currency: string }> = {};
      paidInvoices.forEach(inv => {
        if (!revenueByOrganization[inv.organizationId]) {
          revenueByOrganization[inv.organizationId] = { revenue: 0, count: 0, currency: inv.currencyCode };
        }
        revenueByOrganization[inv.organizationId].revenue += inv.total / 100;
        revenueByOrganization[inv.organizationId].count += 1;
      });

      // Get organization names
      const orgIds = Object.keys(revenueByOrganization);
      const orgs = await Promise.all(orgIds.map(id => storage.getOrganization(id)));
      const orgMap: Record<string, string> = {};
      orgs.forEach(org => {
        if (org) orgMap[org.id] = org.name;
      });

      res.json({
        period: {
          start: startDate || null,
          end: endDate || null
        },
        summary: {
          totalRevenue: paidInvoices.reduce((sum, inv) => sum + inv.total, 0) / 100,
          totalInvoices: paidInvoices.length,
          revenueByPeriod: Object.entries(revenueByPeriod).map(([period, data]) => ({
            period,
            revenue: data.revenue,
            count: data.count,
            currency: data.currency
          })),
          revenueByOrganization: Object.entries(revenueByOrganization).map(([orgId, data]) => ({
            organizationId: orgId,
            organizationName: orgMap[orgId] || 'Unknown',
            revenue: data.revenue,
            count: data.count,
            currency: data.currency
          }))
        }
      });
    } catch (error: any) {
      console.error("Error generating revenue report:", error);
      res.status(500).json({ message: "Failed to generate revenue report", error: error.message });
    }
  });

  // Generate Invoice
  app.post("/api/billing/invoices/generate", isAuthenticated, async (req: any, res) => {
    try {
      const organizationId = req.user.organizationId;
      const { periodStart, periodEnd } = req.body;

      if (!periodStart || !periodEnd) {
        return res.status(400).json({ message: "periodStart and periodEnd are required" });
      }

      const { billingService } = await import("./billingService");
      const invoice = await billingService.generateInvoice(
        organizationId,
        new Date(periodStart),
        new Date(periodEnd)
      );

      res.json(invoice);
    } catch (error: any) {
      console.error("Error generating invoice:", error);
      res.status(500).json({ message: "Failed to generate invoice", error: error.message });
    }
  });

  // Get invoices (new invoice system)
  app.get("/api/billing/invoices", isAuthenticated, async (req: any, res) => {
    try {
      const organizationId = req.user.organizationId;
      const { invoices } = await import("@shared/schema");
      const { desc } = await import("drizzle-orm");

      const invoiceList = await db.select()
        .from(invoices)
        .where(eq(invoices.organizationId, organizationId))
        .orderBy(desc(invoices.createdAt));

      res.json(invoiceList);
    } catch (error: any) {
      console.error("Error fetching invoices:", error);
      res.status(500).json({ message: "Failed to fetch invoices", error: error.message });
    }
  });

  // Create Credit Note (admin only)
  app.post("/api/admin/billing/credit-notes", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { organizationId, invoiceId, reason, amount, currency, description } = req.body;

      if (!organizationId || !reason || !amount || !currency) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      const { billingService } = await import("./billingService");
      const creditNote = await billingService.createCreditNote(
        organizationId,
        invoiceId || null,
        reason,
        amount,
        currency,
        description || "",
        adminUser.id
      );

      res.json(creditNote);
    } catch (error: any) {
      console.error("Error creating credit note:", error);
      res.status(500).json({ message: "Failed to create credit note", error: error.message });
    }
  });

  // Apply Credit Note to Invoice (admin only)
  app.post("/api/admin/billing/credit-notes/:creditNoteId/apply", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { creditNoteId } = req.params;
      const { invoiceId } = req.body;

      if (!invoiceId) {
        return res.status(400).json({ message: "invoiceId is required" });
      }

      const { billingService } = await import("./billingService");
      await billingService.applyCreditNote(creditNoteId, invoiceId);

      res.json({ success: true, message: "Credit note applied successfully" });
    } catch (error: any) {
      console.error("Error applying credit note:", error);
      res.status(500).json({ message: "Failed to apply credit note", error: error.message });
    }
  });

  // Get Credit Notes for Organization (admin only)
  app.get("/api/admin/billing/credit-notes", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { organizationId, status } = req.query;

      if (!organizationId) {
        return res.status(400).json({ message: "organizationId is required" });
      }

      const { billingService } = await import("./billingService");
      const creditNotes = await billingService.getCreditNotes(
        organizationId as string,
        status as "issued" | "applied" | "cancelled" | undefined
      );

      res.json({
        creditNotes: creditNotes.map(cn => ({
          id: cn.id,
          creditNoteNumber: cn.creditNoteNumber,
          organizationId: cn.organizationId,
          invoiceId: cn.invoiceId,
          appliedToInvoiceId: cn.appliedToInvoiceId,
          reason: cn.reason,
          amount: cn.amount / 100, // Convert to major units
          currency: cn.currencyCode,
          description: cn.description,
          status: cn.status,
          createdAt: cn.createdAt?.toISOString(),
          appliedAt: cn.appliedAt?.toISOString(),
          createdBy: cn.createdBy
        })),
        total: creditNotes.reduce((sum, cn) => sum + cn.amount, 0) / 100,
        count: creditNotes.length
      });
    } catch (error: any) {
      console.error("Error fetching credit notes:", error);
      res.status(500).json({ message: "Failed to fetch credit notes", error: error.message });
    }
  });

  // Get Credit Notes for User's Organization
  app.get("/api/billing/credit-notes", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { status } = req.query;

      const { billingService } = await import("./billingService");
      const creditNotes = await billingService.getCreditNotes(
        user.organizationId,
        status as "issued" | "applied" | "cancelled" | undefined
      );

      res.json({
        creditNotes: creditNotes.map(cn => ({
          id: cn.id,
          creditNoteNumber: cn.creditNoteNumber,
          invoiceId: cn.invoiceId,
          appliedToInvoiceId: cn.appliedToInvoiceId,
          reason: cn.reason,
          amount: cn.amount / 100, // Convert to major units
          currency: cn.currencyCode,
          description: cn.description,
          status: cn.status,
          createdAt: cn.createdAt?.toISOString(),
          appliedAt: cn.appliedAt?.toISOString()
        })),
        total: creditNotes.reduce((sum, cn) => sum + cn.amount, 0) / 100,
        count: creditNotes.length
      });
    } catch (error: any) {
      console.error("Error fetching credit notes:", error);
      res.status(500).json({ message: "Failed to fetch credit notes", error: error.message });
    }
  });

  // Get Single Credit Note
  app.get("/api/billing/credit-notes/:creditNoteId", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { creditNoteId } = req.params;

      const { billingService } = await import("./billingService");
      const creditNote = await billingService.getCreditNoteById(creditNoteId);

      if (!creditNote) {
        return res.status(404).json({ message: "Credit note not found" });
      }

      // Verify organization ownership
      if (creditNote.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      res.json({
        id: creditNote.id,
        creditNoteNumber: creditNote.creditNoteNumber,
        invoiceId: creditNote.invoiceId,
        appliedToInvoiceId: creditNote.appliedToInvoiceId,
        reason: creditNote.reason,
        amount: creditNote.amount / 100,
        currency: creditNote.currencyCode,
        description: creditNote.description,
        status: creditNote.status,
        createdAt: creditNote.createdAt?.toISOString(),
        appliedAt: creditNote.appliedAt?.toISOString()
      });
    } catch (error: any) {
      console.error("Error fetching credit note:", error);
      res.status(500).json({ message: "Failed to fetch credit note", error: error.message });
    }
  });

  // Cancel Credit Note (admin only)
  app.post("/api/admin/billing/credit-notes/:creditNoteId/cancel", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { creditNoteId } = req.params;

      const { billingService } = await import("./billingService");
      await billingService.cancelCreditNote(creditNoteId);

      res.json({ success: true, message: "Credit note cancelled successfully" });
    } catch (error: any) {
      console.error("Error cancelling credit note:", error);
      res.status(500).json({ message: "Failed to cancel credit note", error: error.message });
    }
  });

  // Reconcile invoices with Stripe (admin only)
  app.post("/api/admin/billing/reconcile", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { organizationId, startDate, endDate } = req.body;

      const { reconciliationService } = await import("./reconciliationService");
      const report = await reconciliationService.reconcileInvoices(
        organizationId,
        startDate ? new Date(startDate) : undefined,
        endDate ? new Date(endDate) : undefined
      );

      res.json(report);
    } catch (error: any) {
      console.error("Error reconciling invoices:", error);
      res.status(500).json({ message: "Failed to reconcile invoices", error: error.message });
    }
  });

  // Get reconciliation summary (admin only)
  app.get("/api/admin/billing/reconcile/summary", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { organizationId } = req.query;

      const { reconciliationService } = await import("./reconciliationService");
      const summary = await reconciliationService.getReconciliationSummary(
        organizationId as string | undefined
      );

      res.json(summary);
    } catch (error: any) {
      console.error("Error getting reconciliation summary:", error);
      res.status(500).json({ message: "Failed to get reconciliation summary", error: error.message });
    }
  });

  // Get reconciliation report (admin only)
  app.get("/api/admin/billing/reconcile/report", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { organizationId, startDate, endDate, format = "json" } = req.query;

      const { reconciliationService } = await import("./reconciliationService");
      const report = await reconciliationService.reconcileInvoices(
        organizationId as string | undefined,
        startDate ? new Date(startDate as string) : undefined,
        endDate ? new Date(endDate as string) : undefined
      );

      if (format === "csv") {
        // Generate CSV report
        const csvRows: string[] = [];
        
        // Header
        csvRows.push("Type,Severity,Description,DB Invoice ID,Stripe Invoice ID,DB Amount,Stripe Amount,DB Status,Stripe Status,Organization ID,Organization Name");
        
        // Discrepancies
        for (const disc of report.discrepancies) {
          csvRows.push([
            disc.type,
            disc.severity,
            `"${disc.description}"`,
            disc.dbInvoiceId || "",
            disc.stripeInvoiceId || "",
            disc.dbAmount?.toFixed(2) || "",
            disc.stripeAmount?.toFixed(2) || "",
            disc.dbStatus || "",
            disc.stripeStatus || "",
            disc.organizationId,
            disc.organizationName || ""
          ].join(","));
        }

        const csvContent = csvRows.join("\n");
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename="reconciliation-${new Date().toISOString().split('T')[0]}.csv"`);
        res.send(csvContent);
      } else {
        res.json(report);
      }
    } catch (error: any) {
      console.error("Error generating reconciliation report:", error);
      res.status(500).json({ message: "Failed to generate reconciliation report", error: error.message });
    }
  });

  // Calculate Module Overage
  app.post("/api/billing/modules/:instanceModuleId/calculate-overage", isAuthenticated, async (req: any, res) => {
    try {
      const organizationId = req.user.organizationId;
      const { instanceModuleId } = req.params;
      const { billingService } = await import("./billingService");
      
      const overageCharge = await billingService.calculateModuleOverage(instanceModuleId, organizationId);

      res.json({ overageCharge });
    } catch (error: any) {
      console.error("Error calculating module overage:", error);
      res.status(500).json({ message: "Failed to calculate overage", error: error.message });
    }
  });

  // Get billing history / Stripe invoices (legacy endpoint for Stripe invoices)
  app.get("/api/billing/stripe-invoices", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const org = await storage.getOrganization(user.organizationId);
      if (!org?.stripeCustomerId) {
        return res.json({ invoices: [], hasStripeCustomer: false });
      }

      const stripe = await getUncachableStripeClient();
      const stripeInvoices = await stripe.invoices.list({
        customer: org.stripeCustomerId,
        limit: 24,
      });

      const formattedInvoices = stripeInvoices.data.map(inv => ({
        id: inv.id,
        number: inv.number,
        date: inv.created ? new Date(inv.created * 1000).toISOString() : null,
        dueDate: inv.due_date ? new Date(inv.due_date * 1000).toISOString() : null,
        amount: inv.total,
        currency: inv.currency?.toUpperCase(),
        status: inv.status,
        pdfUrl: inv.invoice_pdf,
        hostedInvoiceUrl: inv.hosted_invoice_url,
        description: inv.lines?.data?.[0]?.description || "Subscription",
      }));

      res.json({
        invoices: formattedInvoices,
        hasStripeCustomer: true,
      });
    } catch (error: any) {
      console.error("Error fetching invoices:", error);
      res.status(500).json({ message: "Failed to fetch invoices", error: error.message });
    }
  });

  // Create top-up checkout session with tier-based pricing
  app.post("/api/billing/topup-checkout", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { bundleId, currency = "GBP", recurring = false } = req.body;
      if (!bundleId) {
        return res.status(400).json({ message: "Bundle ID is required" });
      }

      const org = await storage.getOrganization(user.organizationId);
      if (!org) {
        return res.status(404).json({ message: "Organization not found" });
      }

      const bundle = await storage.getCreditBundle(bundleId);
      if (!bundle) {
        return res.status(404).json({ message: "Bundle not found" });
      }

      // Determine tier pricing based on current plan
      const subscription = await storage.getSubscriptionByOrganization(user.organizationId);
      const planCode = subscription?.planSnapshotJson?.planCode || "freelancer";

      // Try to get tier-specific pricing
      const tierPricing = await storage.getBundleTierPricing(bundleId, planCode);

      let price: number;
      if (tierPricing) {
        price = currency === "USD" ? tierPricing.priceUsd :
          currency === "AED" ? tierPricing.priceAed :
            tierPricing.priceGbp;
      } else {
        price = currency === "USD" ? bundle.priceUsd :
          currency === "AED" ? bundle.priceAed :
            bundle.priceGbp;
      }

      // Create or get Stripe customer
      let stripeCustomerId = org.stripeCustomerId;
      if (!stripeCustomerId) {
        const stripe = await getUncachableStripeClient();
        const customer = await stripe.customers.create({
          email: user.email,
          name: org.name,
          metadata: { organizationId: org.id },
        });
        stripeCustomerId = customer.id;
        await storage.updateOrganizationStripe(org.id, stripeCustomerId, "inactive");
      }

      // Create top-up order record
      const topupOrder = await storage.createTopupOrder({
        organizationId: org.id,
        packSize: bundle.credits,
        currency: currency as any,
        unitPriceMinorUnits: Math.round(price / bundle.credits),
        totalPriceMinorUnits: price,
        status: "pending",
      });

      // Create checkout session
      const baseUrl = getBaseUrl(req);
      const stripe = await getUncachableStripeClient();

      // For recurring top-ups, create a subscription
      if (recurring) {
        const session = await stripe.checkout.sessions.create({
          customer: stripeCustomerId,
          mode: "subscription",
          line_items: [{
            price_data: {
              currency: currency.toLowerCase(),
              product_data: {
                name: `${bundle.name} (Monthly)`,
                description: `${bundle.credits} inspection credits delivered monthly`,
              },
              recurring: {
                interval: "month",
              },
              unit_amount: price,
            },
            quantity: 1,
          }],
          success_url: `${baseUrl}/billing?topup=success&recurring=true&session_id={CHECKOUT_SESSION_ID}`,
          cancel_url: `${baseUrl}/billing?topup=canceled`,
          metadata: {
            organizationId: org.id,
            topupOrderId: topupOrder.id,
            packSize: bundle.credits.toString(),
            bundleId: bundle.id,
            recurring: "true",
          },
        });

        // Save auto-renew preference
        await db.update(organizations)
          .set({
            autoRenewEnabled: true,
            autoRenewBundleId: bundleId,
            updatedAt: new Date(),
          })
          .where(eq(organizations.id, org.id));

        res.json({ url: session.url, orderId: topupOrder.id });
      } else {
        // One-time payment
        const session = await stripe.checkout.sessions.create({
          customer: stripeCustomerId,
          mode: "payment",
          line_items: [{
            price_data: {
              currency: currency.toLowerCase(),
              product_data: {
                name: bundle.name,
                description: `${bundle.credits} inspection credits`,
              },
              unit_amount: price,
            },
            quantity: 1,
          }],
          success_url: `${baseUrl}/billing?topup=success&session_id={CHECKOUT_SESSION_ID}`,
          cancel_url: `${baseUrl}/billing?topup=canceled`,
          metadata: {
            organizationId: org.id,
            topupOrderId: topupOrder.id,
            packSize: bundle.credits.toString(),
            bundleId: bundle.id,
          },
        });

        res.json({ url: session.url, orderId: topupOrder.id });
      }
    } catch (error: any) {
      console.error("Error creating top-up checkout:", error);
      res.status(500).json({ message: "Failed to create top-up checkout", error: error.message });
    }
  });

  // User/Contact endpoints for team management (restricted)

  // Get users for team management (admin/owner only)
  // Update user (firstName, lastName, email) - for tenant editing
  app.put("/api/users/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const targetUserId = req.params.id;
      const requester = await storage.getUser(userId);

      if (!requester?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Get the target user
      const targetUser = await storage.getUser(targetUserId);
      if (!targetUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Allow update if:
      // 1. User is updating themselves, OR
      // 2. User is owner/clerk and target user is in same organization
      const canUpdate =
        userId === targetUserId ||
        (requester.role === "owner" || requester.role === "clerk") &&
        targetUser.organizationId === requester.organizationId;

      if (!canUpdate) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Extract and validate the fields we allow updating
      const { firstName, lastName, email } = req.body;

      const updatePayload: any = {};

      // Update firstName if provided
      if (firstName !== undefined) {
        updatePayload.firstName = firstName === null || firstName === "" ? null : firstName.trim() || null;
      }

      // Update lastName if provided
      if (lastName !== undefined) {
        updatePayload.lastName = lastName === null || lastName === "" ? null : lastName.trim() || null;
      }

      // Update email if provided
      if (email !== undefined) {
        if (email === null || email === "") {
          return res.status(400).json({ message: "Email cannot be empty" });
        }
        const normalizedEmail = email.trim().toLowerCase();

        // Check if email is already in use by another user
        const existingUser = await storage.getUserByEmail(normalizedEmail);
        if (existingUser && existingUser.id !== targetUserId) {
          return res.status(400).json({ message: "Email is already in use by another user" });
        }

        updatePayload.email = normalizedEmail;
      }

      if (Object.keys(updatePayload).length === 0) {
        return res.status(400).json({ message: "No valid fields to update" });
      }

      console.log(`[PUT /api/users/:id] Updating user ${targetUserId} with payload:`, updatePayload);
      const updatedUser = await storage.updateUser(targetUserId, updatePayload);
      console.log(`[PUT /api/users/:id] Updated user:`, {
        id: updatedUser.id,
        firstName: updatedUser.firstName,
        lastName: updatedUser.lastName,
        email: updatedUser.email
      });

      // Don't return password
      const { password, ...userWithoutPassword } = updatedUser;
      res.json(userWithoutPassword);
    } catch (error: any) {
      console.error("Error updating user:", error);
      if (error.message?.includes('unique') || error.message?.includes('duplicate')) {
        return res.status(400).json({ message: "Email is already in use by another user" });
      }
      res.status(500).json({ message: "Failed to update user" });
    }
  });

  app.get("/api/users", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only admins and owners can view users
      if (!['admin', 'owner'].includes(user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      const users = await storage.getUsersByOrganization(user.organizationId);

      // Return minimal user data for team selection
      const sanitizedUsers = users.map(u => ({
        id: u.id,
        firstName: u.firstName,
        lastName: u.lastName,
        email: u.email,
        role: u.role,
      }));

      res.json(sanitizedUsers);
    } catch (error: any) {
      console.error("Error fetching users:", error);
      res.status(500).json({ message: "Failed to fetch users" });
    }
  });

  // Get single user by ID (for tenant detail page)
  app.get("/api/users/:userId", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { userId } = req.params;
      const targetUser = await storage.getUser(userId);

      if (!targetUser) {
        return res.status(404).json({ message: "User not found" });
      }

      // Verify user belongs to same organization
      if (targetUser.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Return sanitized user data
      const { password, ...userWithoutPassword } = targetUser;
      res.json(userWithoutPassword);
    } catch (error: any) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });

  // Get tenant tenancy history
  app.get("/api/tenants/:tenantId/history", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { tenantId } = req.params;

      // Get all tenant assignments for this tenant
      const assignments = await db.select()
        .from(tenantAssignments)
        .where(and(
          eq(tenantAssignments.tenantId, tenantId),
          eq(tenantAssignments.organizationId, user.organizationId)
        ))
        .orderBy(desc(tenantAssignments.leaseStartDate));

      // Get property and block details for each assignment
      const history = await Promise.all(assignments.map(async (assignment) => {
        const property = await storage.getProperty(assignment.propertyId);
        const block = property?.blockId ? await storage.getBlock(property.blockId) : null;

        return {
          id: assignment.id,
          propertyId: assignment.propertyId,
          propertyName: property?.name || "Unknown Property",
          propertyAddress: property?.address,
          blockId: block?.id,
          blockName: block?.name,
          leaseStartDate: assignment.leaseStartDate,
          leaseEndDate: assignment.leaseEndDate,
          monthlyRent: assignment.monthlyRent,
          depositAmount: assignment.depositAmount,
          status: (assignment as any).status || (assignment.isActive ? "current" : "ended"),
          isActive: assignment.isActive,
        };
      }));

      res.json(history);
    } catch (error: any) {
      console.error("Error fetching tenant history:", error);
      res.status(500).json({ message: "Failed to fetch tenant history" });
    }
  });

  // Get inspections for tenant's properties
  app.get("/api/tenants/:tenantId/inspections", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { tenantId } = req.params;

      // Get all tenant assignments for this tenant
      const assignments = await db.select()
        .from(tenantAssignments)
        .where(and(
          eq(tenantAssignments.tenantId, tenantId),
          eq(tenantAssignments.organizationId, user.organizationId)
        ));

      const propertyIds = assignments.map(a => a.propertyId);

      if (propertyIds.length === 0) {
        return res.json([]);
      }

      // Get inspections for these properties
      const allInspections = await db.select()
        .from(inspections)
        .where(and(
          eq(inspections.organizationId, user.organizationId),
          inArray(inspections.propertyId, propertyIds)
        ))
        .orderBy(desc(inspections.createdAt))
        .limit(50);

      // Get property and template details
      const result = await Promise.all(allInspections.map(async (inspection) => {
        const property = await storage.getProperty(inspection.propertyId!);
        const template = inspection.templateId ? await storage.getInspectionTemplate(inspection.templateId) : null;

        return {
          id: inspection.id,
          propertyId: inspection.propertyId,
          propertyName: property?.name || "Unknown Property",
          templateName: template?.name || "Unknown Template",
          inspectionType: (inspection as any).inspectionType || "routine",
          status: inspection.status,
          scheduledDate: inspection.scheduledDate,
          completedAt: inspection.completedDate || null,
        };
      }));

      res.json(result);
    } catch (error: any) {
      console.error("Error fetching tenant inspections:", error);
      res.status(500).json({ message: "Failed to fetch tenant inspections" });
    }
  });

  // Get maintenance requests for tenant
  app.get("/api/tenants/:tenantId/maintenance", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { tenantId } = req.params;

      // Get maintenance requests reported by this tenant or for their properties
      const assignments = await db.select()
        .from(tenantAssignments)
        .where(and(
          eq(tenantAssignments.tenantId, tenantId),
          eq(tenantAssignments.organizationId, user.organizationId)
        ));

      const propertyIds = assignments.map(a => a.propertyId);

      // Get requests reported by tenant OR for their properties
      const requests = await db.select()
        .from(maintenanceRequests)
        .where(and(
          eq(maintenanceRequests.organizationId, user.organizationId),
          or(
            eq(maintenanceRequests.reportedBy, tenantId),
            propertyIds.length > 0 ? inArray(maintenanceRequests.propertyId, propertyIds) : sql`false`
          )
        ))
        .orderBy(desc(maintenanceRequests.createdAt))
        .limit(50);

      // Get property details
      const result = await Promise.all(requests.map(async (request) => {
        const property = request.propertyId ? await storage.getProperty(request.propertyId) : null;

        return {
          id: request.id,
          title: request.title,
          description: request.description,
          propertyId: request.propertyId,
          propertyName: property?.name || "Unknown Property",
          status: request.status,
          priority: request.priority,
          createdAt: request.createdAt,
        };
      }));

      res.json(result);
    } catch (error: any) {
      console.error("Error fetching tenant maintenance:", error);
      res.status(500).json({ message: "Failed to fetch tenant maintenance" });
    }
  });

  // Get disputes for tenant
  app.get("/api/tenants/:tenantId/disputes", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { tenantId } = req.params;

      // Get comparison reports for this tenant
      const { comparisonReports } = await import("@shared/schema");
      const { db } = await import("./db");
      const { eq, and } = await import("drizzle-orm");
      const reports = await db.select()
        .from(comparisonReports)
        .where(and(
          eq(comparisonReports.organizationId, user.organizationId),
          eq(comparisonReports.tenantId, tenantId)
        ));

      if (reports.length === 0) {
        return res.json([]);
      }

      const reportIds = reports.map(r => r.id);

      // Get disputed items from these reports
      const disputedItems = await db.select()
        .from(comparisonReportItems)
        .where(and(
          inArray(comparisonReportItems.comparisonReportId, reportIds),
          eq(comparisonReportItems.status, "disputed")
        ))
        .orderBy(desc(comparisonReportItems.createdAt));

      // Get property details
      const result = await Promise.all(disputedItems.map(async (item) => {
        const report = reports.find(r => r.id === item.comparisonReportId);
        const property = report?.propertyId ? await storage.getProperty(report.propertyId) : null;

        return {
          id: item.id,
          reportId: item.comparisonReportId,
          itemRef: item.itemRef || item.sectionRef,
          status: item.status,
          estimatedCost: item.estimatedCost,
          finalCost: item.finalCost,
          propertyName: property?.name || "Unknown Property",
          createdAt: item.createdAt,
        };
      }));

      res.json(result);
    } catch (error: any) {
      console.error("Error fetching tenant disputes:", error);
      res.status(500).json({ message: "Failed to fetch tenant disputes" });
    }
  });

  // Get contacts for team management (admin/owner only)
  app.get("/api/contacts", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only admins and owners can view contacts
      if (!['admin', 'owner'].includes(user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      const contacts = await storage.getContactsByOrganization(user.organizationId);

      // Return minimal contact data for team selection
      const sanitizedContacts = contacts.map(c => ({
        id: c.id,
        firstName: c.firstName,
        lastName: c.lastName,
        email: c.email,
        type: c.type,
      }));

      res.json(sanitizedContacts);
    } catch (error: any) {
      console.error("Error fetching contacts:", error);
      res.status(500).json({ message: "Failed to fetch contacts" });
    }
  });

  // Team Management Routes

  // Get all teams for organization
  app.get("/api/teams", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only admins and owners can view teams
      if (!['admin', 'owner'].includes(user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      const teams = await storage.getTeamsByOrganization(user.organizationId);
      res.json(teams);
    } catch (error: any) {
      console.error("Error fetching teams:", error);
      res.status(500).json({ message: "Failed to fetch teams" });
    }
  });

  // Get single team
  app.get("/api/teams/:id", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only admins and owners can view teams
      if (!['admin', 'owner'].includes(user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { id } = req.params;
      const team = await storage.getTeam(id);

      if (!team) {
        return res.status(404).json({ message: "Team not found" });
      }

      // Verify team belongs to user's organization
      if (team.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      res.json(team);
    } catch (error: any) {
      console.error("Error fetching team:", error);
      res.status(500).json({ message: "Failed to fetch team" });
    }
  });

  // Create team
  // Create team with members and categories (atomic transaction)
  app.post("/api/teams/full", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only admins and owners can create teams
      if (!['admin', 'owner'].includes(user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Validate request body
      const bodySchema = z.object({
        name: z.string().min(1),
        description: z.string().optional(),
        email: z.string().email(),
        isActive: z.boolean().optional(),
        userIds: z.array(z.string()).optional(),
        contactIds: z.array(z.string()).optional(),
        categories: z.array(z.string()).optional(),
      });

      const validationResult = bodySchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validationResult.error.errors,
        });
      }

      const { name, description, email, isActive, userIds, contactIds, categories } = validationResult.data;

      // Create team with members and categories in a single transaction
      try {
        const result = await db.transaction(async (tx) => {
          // 1. Create team
          const [createdTeam] = await tx.insert(teams).values({
            organizationId: user.organizationId || "",
            name,
            description: description || null,
            email: email || null,
            isActive: isActive ?? true,
          }).returning();

          // 2. Add user members
          if (userIds && Array.isArray(userIds) && userIds.length > 0) {
            await tx.insert(teamMembers).values(
              userIds.map(userId => ({
                teamId: createdTeam.id,
                userId,
                contactId: null,
                role: 'member' as const,
              }))
            );
          }

          // 3. Add contractor members
          if (contactIds && Array.isArray(contactIds) && contactIds.length > 0) {
            await tx.insert(teamMembers).values(
              contactIds.map(contactId => ({
                teamId: createdTeam.id,
                userId: null,
                contactId,
                role: 'contractor' as const,
              }))
            );
          }

          // 4. Add categories
          if (categories && Array.isArray(categories) && categories.length > 0) {
            await tx.insert(teamCategories).values(
              categories.map(category => ({
                teamId: createdTeam.id,
                category,
              }))
            );
          }

          // Return created team with counts
          const finalMembers = await tx
            .select()
            .from(teamMembers)
            .where(eq(teamMembers.teamId, createdTeam.id));

          const finalCategories = await tx
            .select()
            .from(teamCategories)
            .where(eq(teamCategories.teamId, createdTeam.id));

          return {
            ...createdTeam,
            memberCount: finalMembers.length,
            categories: finalCategories.map(c => c.category),
          };
        });

        res.status(201).json(result);
      } catch (error: any) {
        // Transaction automatically rolled back on error
        throw error;
      }
    } catch (error: any) {
      console.error("Error creating team:", error);
      res.status(500).json({ message: "Failed to create team", error: error.message });
    }
  });

  // Simple team creation (without members/categories)
  app.post("/api/teams", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only admins and owners can create teams
      if (!['admin', 'owner'].includes(user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { name, description, email, isActive } = req.body;

      if (!name || !email) {
        return res.status(400).json({ message: "Name and email are required" });
      }

      const team = await storage.createTeam({
        organizationId: user.organizationId,
        name,
        description,
        email,
        isActive: isActive ?? true,
      });

      res.status(201).json(team);
    } catch (error: any) {
      console.error("Error creating team:", error);
      res.status(500).json({ message: "Failed to create team" });
    }
  });

  // Update team
  app.patch("/api/teams/:id", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only admins and owners can update teams
      if (!['admin', 'owner'].includes(user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { id } = req.params;
      const team = await storage.getTeam(id);

      if (!team) {
        return res.status(404).json({ message: "Team not found" });
      }

      // Verify team belongs to user's organization
      if (team.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { name, description, email, isActive } = req.body;
      const updates: any = {};
      if (name !== undefined) updates.name = name;
      if (description !== undefined) updates.description = description;
      if (email !== undefined) updates.email = email;
      if (isActive !== undefined) updates.isActive = isActive;

      const updatedTeam = await storage.updateTeam(id, updates);
      res.json(updatedTeam);
    } catch (error: any) {
      console.error("Error updating team:", error);
      res.status(500).json({ message: "Failed to update team" });
    }
  });

  // Update team with members and categories (server-side batched)
  app.patch("/api/teams/:id/full", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only admins and owners can update teams
      if (!['admin', 'owner'].includes(user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { id } = req.params;

      // Validate request body
      const bodySchema = z.object({
        name: z.string().min(1).optional(),
        description: z.string().optional(),
        email: z.string().email().optional(),
        isActive: z.boolean().optional(),
        userIds: z.array(z.string()).optional(),
        contactIds: z.array(z.string()).optional(),
        categories: z.array(z.string()).optional(),
      });

      const validationResult = bodySchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          message: "Invalid request data",
          errors: validationResult.error.errors
        });
      }

      const { name, description, email, isActive, userIds, contactIds, categories } = validationResult.data;

      const team = await storage.getTeam(id);
      if (!team) {
        return res.status(404).json({ message: "Team not found" });
      }

      // Verify team belongs to user's organization
      if (team.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Begin database transaction for atomic updates
      try {
        const result = await db.transaction(async (tx) => {
          // 1. Update team details
          const teamUpdates: any = {};
          if (name !== undefined) teamUpdates.name = name;
          if (description !== undefined) teamUpdates.description = description;
          if (email !== undefined) teamUpdates.email = email;
          if (isActive !== undefined) teamUpdates.isActive = isActive;

          const [updatedTeam] = await tx
            .update(teams)
            .set(teamUpdates)
            .where(eq(teams.id, id))
            .returning();

          // 2. Update members - delete all and recreate
          await tx.delete(teamMembers).where(eq(teamMembers.teamId, id));

          // Add new user members
          if (userIds && Array.isArray(userIds) && userIds.length > 0) {
            await tx.insert(teamMembers).values(
              userIds.map(userId => ({
                teamId: id,
                userId,
                contactId: null,
                role: 'member' as const,
              }))
            );
          }

          // Add new contractor members
          if (contactIds && Array.isArray(contactIds) && contactIds.length > 0) {
            await tx.insert(teamMembers).values(
              contactIds.map(contactId => ({
                teamId: id,
                userId: null,
                contactId,
                role: 'contractor' as const,
              }))
            );
          }

          // 3. Update categories - delete all and recreate
          await tx.delete(teamCategories).where(eq(teamCategories.teamId, id));

          if (categories && Array.isArray(categories) && categories.length > 0) {
            await tx.insert(teamCategories).values(
              categories.map(category => ({
                teamId: id,
                category,
              }))
            );
          }

          // Return updated team with counts
          const finalMembers = await tx
            .select()
            .from(teamMembers)
            .where(eq(teamMembers.teamId, id));

          const finalCategories = await tx
            .select()
            .from(teamCategories)
            .where(eq(teamCategories.teamId, id));

          return {
            ...updatedTeam,
            memberCount: finalMembers.length,
            categories: finalCategories.map(c => c.category),
          };
        });

        res.json(result);
      } catch (error: any) {
        // Transaction automatically rolled back on error
        throw error;
      }
    } catch (error: any) {
      console.error("Error updating team:", error);
      res.status(500).json({ message: "Failed to update team", error: error.message });
    }
  });

  // Delete team
  app.delete("/api/teams/:id", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only admins and owners can delete teams
      if (!['admin', 'owner'].includes(user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { id } = req.params;
      const team = await storage.getTeam(id);

      if (!team) {
        return res.status(404).json({ message: "Team not found" });
      }

      // Verify team belongs to user's organization
      if (team.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      await storage.deleteTeam(id);
      res.json({ success: true });
    } catch (error: any) {
      console.error("Error deleting team:", error);
      res.status(500).json({ message: "Failed to delete team" });
    }
  });

  // Get team members
  app.get("/api/teams/:teamId/members", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only admins and owners can view team members
      if (!['admin', 'owner'].includes(user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { teamId } = req.params;
      const team = await storage.getTeam(teamId);

      if (!team) {
        return res.status(404).json({ message: "Team not found" });
      }

      // Verify team belongs to user's organization
      if (team.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const members = await storage.getTeamMembers(teamId);
      res.json(members);
    } catch (error: any) {
      console.error("Error fetching team members:", error);
      res.status(500).json({ message: "Failed to fetch team members" });
    }
  });

  // Add team member
  app.post("/api/teams/:teamId/members", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only admins and owners can add team members
      if (!['admin', 'owner'].includes(user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { teamId } = req.params;
      const { userId, contactId, role } = req.body;

      const team = await storage.getTeam(teamId);
      if (!team) {
        return res.status(404).json({ message: "Team not found" });
      }

      // Verify team belongs to user's organization
      if (team.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Validate that exactly one of userId or contactId is provided
      if ((userId && contactId) || (!userId && !contactId)) {
        return res.status(400).json({ message: "Must provide either userId or contactId, not both" });
      }

      const member = await storage.addTeamMember({
        teamId,
        userId: userId || null,
        contactId: contactId || null,
        role: role || 'member',
      });

      res.status(201).json(member);
    } catch (error: any) {
      console.error("Error adding team member:", error);
      res.status(500).json({ message: "Failed to add team member" });
    }
  });

  // Remove team member
  app.delete("/api/teams/:teamId/members/:memberId", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only admins and owners can remove team members
      if (!['admin', 'owner'].includes(user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { teamId, memberId } = req.params;
      const team = await storage.getTeam(teamId);

      if (!team) {
        return res.status(404).json({ message: "Team not found" });
      }

      // Verify team belongs to user's organization
      if (team.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      await storage.removeTeamMember(memberId);
      res.json({ success: true });
    } catch (error: any) {
      console.error("Error removing team member:", error);
      res.status(500).json({ message: "Failed to remove team member" });
    }
  });

  // Get team categories
  app.get("/api/teams/:teamId/categories", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only admins and owners can view team categories
      if (!['admin', 'owner'].includes(user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { teamId } = req.params;
      const team = await storage.getTeam(teamId);

      if (!team) {
        return res.status(404).json({ message: "Team not found" });
      }

      // Verify team belongs to user's organization
      if (team.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const categories = await storage.getTeamCategories(teamId);
      res.json(categories);
    } catch (error: any) {
      console.error("Error fetching team categories:", error);
      res.status(500).json({ message: "Failed to fetch team categories" });
    }
  });

  // Add team category
  app.post("/api/teams/:teamId/categories", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only admins and owners can add team categories
      if (!['admin', 'owner'].includes(user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { teamId } = req.params;
      const { category } = req.body;

      const team = await storage.getTeam(teamId);
      if (!team) {
        return res.status(404).json({ message: "Team not found" });
      }

      // Verify team belongs to user's organization
      if (team.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      if (!category) {
        return res.status(400).json({ message: "Category is required" });
      }

      const teamCategory = await storage.addTeamCategory({
        teamId,
        category,
      });

      res.status(201).json(teamCategory);
    } catch (error: any) {
      console.error("Error adding team category:", error);
      res.status(500).json({ message: "Failed to add team category" });
    }
  });

  // Remove team category
  app.delete("/api/teams/:teamId/categories/:categoryId", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      // Only admins and owners can remove team categories
      if (!['admin', 'owner'].includes(user.role)) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { teamId, categoryId } = req.params;
      const team = await storage.getTeam(teamId);

      if (!team) {
        return res.status(404).json({ message: "Team not found" });
      }

      // Verify team belongs to user's organization
      if (team.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      await storage.removeTeamCategory(categoryId);
      res.json({ success: true });
    } catch (error: any) {
      console.error("Error removing team category:", error);
      res.status(500).json({ message: "Failed to remove team category" });
    }
  });

  // ==================== KNOWLEDGE BASE ROUTES (AI CHATBOT) ====================

  // Upload knowledge base document (admin only)
  app.post("/api/knowledge-base/documents", isAdminAuthenticated, async (req: any, res) => {
    try {
      const admin = (req.session as any).adminUser;
      const { title, fileName, fileUrl, fileType, fileSizeBytes, category, description } = req.body;

      if (!title || !fileName || !fileUrl || !fileType || !fileSizeBytes) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      console.log(`[Knowledge Base] Extracting text from ${fileName} (${fileType})`);

      const processed = await extractTextFromFile(fileUrl, fileType);

      if (processed.error) {
        console.error(`[Knowledge Base] Extraction error: ${processed.error}`);
        return res.status(400).json({ message: processed.error });
      }

      const document = await storage.createKnowledgeBaseDocument({
        title,
        fileName,
        fileUrl,
        fileType,
        fileSizeBytes,
        extractedText: processed.extractedText,
        category: category || null,
        description: description || null,
        uploadedBy: admin.id,
      });

      console.log(`[Knowledge Base] Document created: ${document.id} (${processed.extractedText.length} characters)`);
      res.status(201).json(document);
    } catch (error: any) {
      console.error("[Knowledge Base] Error uploading document:", error);
      res.status(500).json({ message: "Failed to upload document" });
    }
  });

  // Get all knowledge base documents (admin only)
  app.get("/api/knowledge-base/documents", isAdminAuthenticated, async (req: any, res) => {
    try {
      const activeOnly = req.query.activeOnly !== 'false';
      const documents = await storage.getKnowledgeBaseDocuments(activeOnly);
      res.json(documents);
    } catch (error: any) {
      console.error("[Knowledge Base] Error fetching documents:", error);
      res.status(500).json({ message: "Failed to fetch documents" });
    }
  });

  // Update knowledge base document (admin only)
  app.patch("/api/knowledge-base/documents/:id", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;

      const document = await storage.updateKnowledgeBaseDocument(id, updates);
      res.json(document);
    } catch (error: any) {
      console.error("[Knowledge Base] Error updating document:", error);
      res.status(500).json({ message: "Failed to update document" });
    }
  });

  // Delete knowledge base document (admin only)
  app.delete("/api/knowledge-base/documents/:id", isAdminAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      await storage.deleteKnowledgeBaseDocument(id);
      res.json({ success: true });
    } catch (error: any) {
      console.error("[Knowledge Base] Error deleting document:", error);
      res.status(500).json({ message: "Failed to delete document" });
    }
  });

  // ==================== IVY CHATBOT ROUTES ====================

  // Ivy - BTR Operations AI Assistant
  app.post("/api/ivy/chat", isAuthenticated, requireRole("owner", "clerk"), async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { message, history = [] } = req.body;

      if (!message || message.trim().length === 0) {
        return res.status(400).json({ message: "Message is required" });
      }

      // Gather organization data for context
      const [
        properties,
        inspections,
        complianceDocuments,
        maintenanceRequests,
        workOrders,
        tenantAssignments,
        blocks,
        teams,
        contacts,
        inventories,
        communityGroups,
      ] = await Promise.all([
        storage.getPropertiesByOrganization(user.organizationId),
        storage.getInspectionsByOrganization(user.organizationId),
        storage.getComplianceDocuments(user.organizationId),
        storage.getMaintenanceByOrganization(user.organizationId),
        storage.getWorkOrdersByOrganization(user.organizationId),
        storage.getTenantAssignmentsByOrganization(user.organizationId),
        storage.getBlocksByOrganization(user.organizationId),
        storage.getTeamsByOrganization(user.organizationId),
        storage.getContactsByOrganization(user.organizationId),
        storage.getInventoriesByOrganization(user.organizationId),
        storage.getCommunityGroupsByOrganization(user.organizationId),
      ]);

      const now = new Date();

      // Calculate statistics
      const overdueInspections = inspections.filter(i =>
        i.status !== "completed" && i.scheduledDate && new Date(i.scheduledDate) < now
      );
      const upcomingInspections = inspections.filter(i =>
        i.status !== "completed" && i.scheduledDate && new Date(i.scheduledDate) >= now
      );
      const draftInspections = inspections.filter(i => i.status === "draft");
      const inProgressInspections = inspections.filter(i => i.status === "in_progress");
      const completedInspections = inspections.filter(i => i.status === "completed");

      const expiredCompliance = complianceDocuments.filter(d =>
        d.expiryDate && new Date(d.expiryDate) < now
      );
      const expiringCompliance = complianceDocuments.filter(d => {
        if (!d.expiryDate) return false;
        const expiry = new Date(d.expiryDate);
        const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
        return expiry >= now && expiry <= thirtyDaysFromNow;
      });

      const openMaintenanceRequests = maintenanceRequests.filter(m =>
        m.status === "pending" || m.status === "in_progress"
      );
      const urgentMaintenance = maintenanceRequests.filter(m =>
        m.priority === "urgent" && m.status !== "resolved"
      );

      const openWorkOrders = workOrders.filter(w =>
        w.status === "pending" || w.status === "in_progress"
      );

      const activeTenants = tenantAssignments.filter(t => t.assignment?.isActive);

      // Build context for AI
      const contextData = {
        summary: {
          totalProperties: properties.length,
          totalBlocks: blocks.length,
          totalInspections: inspections.length,
          overdueInspections: overdueInspections.length,
          upcomingInspections: upcomingInspections.length,
          draftInspections: draftInspections.length,
          inProgressInspections: inProgressInspections.length,
          completedInspections: completedInspections.length,
          totalComplianceDocuments: complianceDocuments.length,
          expiredCompliance: expiredCompliance.length,
          expiringCompliance: expiringCompliance.length,
          totalMaintenanceRequests: maintenanceRequests.length,
          openMaintenanceRequests: openMaintenanceRequests.length,
          urgentMaintenance: urgentMaintenance.length,
          totalWorkOrders: workOrders.length,
          openWorkOrders: openWorkOrders.length,
          activeTenants: activeTenants.length,
          totalTeams: teams.length,
          totalContacts: contacts.length,
          totalInventories: inventories.length,
          totalCommunityGroups: communityGroups.length,
        },
        overdueInspectionsList: overdueInspections.slice(0, 10).map(i => ({
          property: properties.find(p => p.id === i.propertyId)?.name || "Unknown",
          type: i.type,
          scheduledDate: i.scheduledDate,
          status: i.status,
        })),
        expiredComplianceList: expiredCompliance.slice(0, 10).map(d => ({
          property: properties.find(p => p.id === d.propertyId)?.name || "Unknown",
          documentType: d.documentType,
          expiryDate: d.expiryDate,
        })),
        expiringComplianceList: expiringCompliance.slice(0, 10).map(d => ({
          property: properties.find(p => p.id === d.propertyId)?.name || "Unknown",
          documentType: d.documentType,
          expiryDate: d.expiryDate,
        })),
        urgentMaintenanceList: urgentMaintenance.slice(0, 10).map(m => ({
          property: properties.find(p => p.id === m.propertyId)?.name || "Unknown",
          title: m.title,
          status: m.status,
          createdAt: m.createdAt,
        })),
        propertiesList: properties.slice(0, 20).map(p => ({
          name: p.name,
          address: p.address,
          status: (p as any).status,
        })),
      };

      const systemPrompt = `You are Ivy, a friendly and knowledgeable AI assistant for BTR (Build-to-Rent) property operations on the Inspect360 platform. You have access to real-time data about the organization's properties, inspections, compliance, maintenance, tenants, teams, contacts, work orders, inventory, and community.

CURRENT DATA SUMMARY:
${JSON.stringify(contextData.summary, null, 2)}

${overdueInspections.length > 0 ? `OVERDUE INSPECTIONS (${overdueInspections.length} total, showing up to 10):\n${JSON.stringify(contextData.overdueInspectionsList, null, 2)}` : ''}

${expiredCompliance.length > 0 ? `EXPIRED COMPLIANCE DOCUMENTS (${expiredCompliance.length} total, showing up to 10):\n${JSON.stringify(contextData.expiredComplianceList, null, 2)}` : ''}

${expiringCompliance.length > 0 ? `COMPLIANCE EXPIRING WITHIN 30 DAYS (${expiringCompliance.length} total, showing up to 10):\n${JSON.stringify(contextData.expiringComplianceList, null, 2)}` : ''}

${urgentMaintenance.length > 0 ? `URGENT MAINTENANCE REQUESTS (${urgentMaintenance.length} total, showing up to 10):\n${JSON.stringify(contextData.urgentMaintenanceList, null, 2)}` : ''}

PROPERTIES LIST (showing up to 20):
${JSON.stringify(contextData.propertiesList, null, 2)}

Your personality:
- Friendly, professional, and helpful
- Use clear, concise language
- When providing lists, format them nicely with bullet points or numbered items
- Proactively highlight urgent issues or concerns
- Offer actionable suggestions when appropriate
- If you don't have enough information to answer a question, say so politely

Answer the user's question based on the data provided above. Focus on being helpful and actionable.`;

      const openaiClient = getOpenAI();
      const messages: any[] = [
        { role: "system", content: systemPrompt },
        ...history.slice(-8).map((m: any) => ({ role: m.role, content: m.content })),
        { role: "user", content: message },
      ];

      const completion = await openaiClient.chat.completions.create({
        model: "gpt-4o",
        messages,
        max_completion_tokens: 1000,
        temperature: 0.7,
      });

      const response = completion.choices[0]?.message?.content || "I'm sorry, I couldn't generate a response. Please try again.";

      res.json({ response });
    } catch (error: any) {
      console.error("[Ivy] Error processing chat:", error);
      res.status(500).json({ message: "Failed to process chat message" });
    }
  });

  // ==================== CHATBOT ROUTES ====================

  // Get user's chat conversations
  app.get("/api/chat/conversations", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const conversations = await storage.getChatConversationsByUser(userId);
      res.json(conversations);
    } catch (error: any) {
      console.error("[Chatbot] Error fetching conversations:", error);
      res.status(500).json({ message: "Failed to fetch conversations" });
    }
  });

  // Create new chat conversation
  app.post("/api/chat/conversations", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user?.organizationId) {
        return res.status(400).json({ message: "User must belong to an organization" });
      }

      const { title } = req.body;

      const conversation = await storage.createChatConversation({
        organizationId: user.organizationId,
        userId: user.id,
        title: title || "New Chat",
      });

      res.status(201).json(conversation);
    } catch (error: any) {
      console.error("[Chatbot] Error creating conversation:", error);
      res.status(500).json({ message: "Failed to create conversation" });
    }
  });

  // Get conversation messages
  app.get("/api/chat/conversations/:id/messages", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const user = await storage.getUser(req.user.id);

      const conversation = await storage.getChatConversation(id);
      if (!conversation) {
        return res.status(404).json({ message: "Conversation not found" });
      }

      if (conversation.userId !== user?.id) {
        return res.status(403).json({ message: "Access denied" });
      }

      const messages = await storage.getChatMessages(id);
      res.json(messages);
    } catch (error: any) {
      console.error("[Chatbot] Error fetching messages:", error);
      res.status(500).json({ message: "Failed to fetch messages" });
    }
  });

  // Send chat message and get AI response
  app.post("/api/chat/conversations/:id/messages", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { content } = req.body;
      const user = await storage.getUser(req.user.id);

      if (!content || content.trim().length === 0) {
        return res.status(400).json({ message: "Message content is required" });
      }

      const conversation = await storage.getChatConversation(id);
      if (!conversation) {
        return res.status(404).json({ message: "Conversation not found" });
      }

      if (conversation.userId !== user?.id) {
        return res.status(403).json({ message: "Access denied" });
      }

      const userMessage = await storage.createChatMessage({
        conversationId: id,
        role: "user",
        content,
        sourceDocs: [],
      });

      // Get tenant-specific context if user is a tenant
      let tenantContext = '';
      if (user?.role === 'tenant') {
        try {
          const tenancy = await storage.getTenancyByTenantId(user.id);
          if (tenancy) {
            const property = tenancy.propertyId ? await storage.getProperty(tenancy.propertyId) : null;
            const block = tenancy.blockId ? await storage.getBlock(tenancy.blockId) : null;
            const maintenanceRequests = await storage.getMaintenanceRequestsByReporter(user.id);
            const comparisonReports = await storage.getComparisonReportsByTenant(user.id);

            // Fetch property info for comparison reports
            const reportsWithProperty = await Promise.all(
              comparisonReports.slice(0, 3).map(async (r) => {
                if (r.propertyId) {
                  const prop = await storage.getProperty(r.propertyId);
                  return { ...r, propertyName: prop?.name || 'property' };
                }
                return { ...r, propertyName: 'property' };
              })
            );

            tenantContext = `\n\nTENANT CONTEXT:
- Property: ${property?.name || 'N/A'} (${property?.address || 'N/A'})
- Block: ${block?.name || 'N/A'} (${block?.address || 'N/A'})
- Lease Status: ${tenancy.isActive ? 'Active' : 'Inactive'}
- Lease Period: ${tenancy.leaseStartDate ? new Date(tenancy.leaseStartDate).toLocaleDateString() : 'N/A'} to ${tenancy.leaseEndDate ? new Date(tenancy.leaseEndDate).toLocaleDateString() : 'N/A'}
- Monthly Rent: ${tenancy.monthlyRent ? `Â£${parseFloat(tenancy.monthlyRent).toLocaleString()}` : 'N/A'}
- Maintenance Requests: ${maintenanceRequests.length} total (${maintenanceRequests.filter(r => r.status === 'open').length} open, ${maintenanceRequests.filter(r => r.status === 'in_progress').length} in progress, ${maintenanceRequests.filter(r => r.status === 'completed').length} completed)
- Comparison Reports: ${comparisonReports.length} total (${comparisonReports.filter(r => r.status === 'under_review' || r.status === 'awaiting_signatures').length} pending signature)

Recent Maintenance Requests:
${maintenanceRequests.slice(0, 5).map(r => `- ${r.title} (${r.status}, ${r.priority} priority)`).join('\n') || 'None'}

Pending Comparison Reports:
${reportsWithProperty.filter(r => r.status === 'under_review' || r.status === 'awaiting_signatures').map(r => `- Report for ${r.propertyName} (${r.status}, Â£${parseFloat(r.totalEstimatedCost || '0').toFixed(2)})`).join('\n') || 'None'}

You can help the tenant with:
- Questions about their property and tenancy
- Information about their maintenance requests
- Help with comparison reports and signing
- General questions about using the Inspect360 tenant portal
- Questions about community features`;
          }
        } catch (contextError) {
          console.error("[Chatbot] Error fetching tenant context:", contextError);
          // Continue without tenant context if there's an error
        }
      }

      const documents = await storage.searchKnowledgeBase(content);

      let contextChunks: string[] = [];
      const usedDocIds: string[] = [];

      for (const doc of documents.slice(0, 3)) {
        if (doc.extractedText) {
          const relevantChunks = findRelevantChunks(doc.extractedText, content, 2);
          contextChunks.push(...relevantChunks);
          if (relevantChunks.length > 0) {
            usedDocIds.push(doc.id);
          }
        }
      }

      const contextText = contextChunks.length > 0
        ? `Based on the Inspect360 knowledge base:\n\n${contextChunks.join('\n\n---\n\n')}\n\n`
        : '';

      const systemPrompt = `You are an AI assistant for Inspect360, a building inspection and property management platform. ${user?.role === 'tenant' ? 'You are helping a tenant with their property, maintenance requests, and tenancy-related questions.' : 'You help users with property management, inspections, compliance, and maintenance.'} ${contextText ? 'Use the knowledge base information provided to answer questions accurately.' : 'Answer questions about Inspect360 to the best of your ability.'}${tenantContext}`;

      const openaiClient = getOpenAI();

      // Get conversation history for context
      const previousMessages = await storage.getChatMessages(id);
      const messageHistory = previousMessages
        .slice(-10) // Last 10 messages for context
        .map(msg => ({ role: msg.role, content: msg.content }));

      const messages = [
        { role: "system" as const, content: systemPrompt },
        ...messageHistory,
        { role: "user" as const, content: contextText + content },
      ];

      let completion;
      try {
        completion = await openaiClient.chat.completions.create({
          model: "gpt-4o", // Use valid OpenAI model
          messages: messages as any,
          max_tokens: 1000,
          temperature: 0.7,
        });
      } catch (openaiError: any) {
        console.error("[Chatbot] OpenAI API error:", openaiError);
        // Create an error message for the user
        const errorMessage = await storage.createChatMessage({
          conversationId: id,
          role: "assistant",
          content: "I apologize, but I'm experiencing technical difficulties. Please try again in a moment. If the problem persists, please contact support.",
          sourceDocs: [],
        });
        return res.status(500).json({
          message: "Failed to generate response",
          error: openaiError.message,
          userMessage,
          assistantMessage: errorMessage
        });
      }

      const assistantContent = completion.choices[0]?.message?.content || "I'm sorry, I couldn't generate a response. Please try rephrasing your question.";

      if (!assistantContent || assistantContent.trim().length === 0) {
        console.error("[Chatbot] Empty response from OpenAI");
        const errorMessage = await storage.createChatMessage({
          conversationId: id,
          role: "assistant",
          content: "I apologize, but I couldn't generate a response to your question. Please try rephrasing it or ask something else.",
          sourceDocs: [],
        });
        return res.status(500).json({
          message: "Empty response from AI",
          userMessage,
          assistantMessage: errorMessage
        });
      }

      const assistantMessage = await storage.createChatMessage({
        conversationId: id,
        role: "assistant",
        content: assistantContent,
        sourceDocs: usedDocIds,
      });

      if (!conversation.title || conversation.title === "New Chat") {
        try {
          const titlePrompt = `Generate a short 3-5 word title for a conversation that starts with: "${content.substring(0, 100)}"`;
          const titleCompletion = await openaiClient.chat.completions.create({
            model: "gpt-4o-mini", // Use valid OpenAI model
            messages: [{ role: "user", content: titlePrompt }],
            max_tokens: 20,
          });
          const title = titleCompletion.choices[0]?.message?.content?.replace(/['"]/g, '').trim() || "Chat";
          await storage.updateChatConversation(id, { title });
        } catch (titleError) {
          console.error("[Chatbot] Error generating title:", titleError);
          // Don't fail the whole request if title generation fails
        }
      }

      res.json({ userMessage, assistantMessage });
    } catch (error: any) {
      console.error("[Chatbot] Error sending message:", error);
      console.error("[Chatbot] Error stack:", error.stack);
      res.status(500).json({ message: "Failed to send message", error: error.message });
    }
  });

  // ==================== TENANT PORTAL ROUTES ====================

  // Tenant login (separate from main auth)
  // NOTE: This endpoint uses the same 'users' table where tenant users are created.
  // The email and password set during tenant creation (via /api/team) are used here for authentication.
  app.post("/api/tenant/login", async (req, res) => {
    try {
      const { email, password } = req.body;

      if (!email || !password) {
        return res.status(400).json({ message: "Email and password are required" });
      }

      // Normalize email for case-insensitive lookup
      // This looks up the user in the same 'users' table where they were created
      const normalizedEmail = email.toLowerCase().trim();
      console.log(`[Tenant Login] Attempting login for email: ${normalizedEmail}`);

      const user = await storage.getUserByEmail(normalizedEmail);

      if (!user) {
        console.log(`[Tenant Login] User not found for email: ${normalizedEmail}`);
        return res.status(401).json({ message: "Invalid credentials or not a tenant account" });
      }

      console.log(`[Tenant Login] User found: ${user.id}, role: ${user.role}, isActive: ${user.isActive}, hasPassword: ${!!user.password}`);

      if (user.role !== "tenant") {
        console.log(`[Tenant Login] User role is '${user.role}', expected 'tenant'`);
        return res.status(401).json({ message: "Invalid credentials or not a tenant account" });
      }

      // Check if user has a password set
      if (!user.password) {
        console.warn(`[Tenant Login] User ${user.id} (${user.email}) has no password set`);
        return res.status(401).json({ message: "Invalid credentials" });
      }

      // Verify password - this is the same password that was set during tenant creation
      const isValid = await comparePasswords(password, user.password);

      if (!isValid) {
        console.log(`[Tenant Login] Password mismatch for user: ${user.email}`);
        return res.status(401).json({ message: "Invalid credentials" });
      }

      if (!user.isActive) {
        console.log(`[Tenant Login] User account is inactive: ${user.email}`);
        return res.status(403).json({ message: "Account is deactivated. Please contact property management." });
      }

      // Check if user's organization is active
      if (user.organizationId) {
        const organization = await storage.getOrganization(user.organizationId);
        if (organization && organization.isActive === false) {
          console.log(`[Tenant Login] Organization ${user.organizationId} is disabled for user: ${user.email}`);
          return res.status(403).json({ message: "Your account has been blocked. Please contact admin." });
        }
      }

      console.log(`[Tenant Login] Authentication successful for user: ${user.email}`);

      req.login(user, async (err) => {
        if (err) {
          console.error("[Tenant Login] Session creation error:", err);
          return res.status(500).json({ message: "Login failed" });
        }

        // Explicitly save the session before responding (like regular login)
        req.session.save(async (saveErr) => {
          if (saveErr) {
            console.error("[Tenant Login] Session save failed:", saveErr);
            return res.status(500).json({ message: "Login failed" });
          }

          // Sanitize user object - remove all sensitive fields
          const { password: _, resetToken, resetTokenExpiry, ...sanitizedUser } = user;
          console.log(`[Tenant Login] Session created and saved successfully for user: ${user.email}`);

          // Return user object in same format as /api/auth/user endpoint
          // Include organization if available
          try {
            let organization = null;
            if (user.organizationId) {
              organization = await storage.getOrganization(user.organizationId);
            }
            res.json({ ...sanitizedUser, organization });
          } catch (orgError) {
            // If organization fetch fails, still return user without it
            console.warn("[Tenant Login] Failed to fetch organization:", orgError);
            res.json(sanitizedUser);
          }
        });
      });
    } catch (error) {
      console.error("[Tenant Login] Unexpected error:", error);
      res.status(500).json({ message: "Login failed" });
    }
  });

  // Get tenant's tenancy information
  app.get("/api/tenant/tenancy", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user || user.role !== "tenant") {
        return res.status(403).json({ message: "Access denied" });
      }

      const tenancy = await storage.getTenancyByTenantId(userId);
      if (!tenancy) {
        return res.json(null);
      }

      const property = await storage.getProperty(tenancy.propertyId);
      let block = null;
      if (property?.blockId) {
        block = await storage.getBlock(property.blockId);
      }

      res.json({ tenancy, property, block });
    } catch (error) {
      console.error("Error fetching tenant tenancy:", error);
      res.status(500).json({ message: "Failed to fetch tenancy" });
    }
  });

  // Get tenant's maintenance chat conversations
  app.get("/api/tenant/maintenance-chats", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user || user.role !== "tenant") {
        return res.status(403).json({ message: "Access denied" });
      }

      const chats = await storage.getTenantMaintenanceChats(userId);
      res.json(chats);
    } catch (error) {
      console.error("Error fetching maintenance chats:", error);
      res.status(500).json({ message: "Failed to fetch chats" });
    }
  });

  // Get specific maintenance chat with messages
  app.get("/api/tenant/maintenance-chats/:chatId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user || user.role !== "tenant") {
        return res.status(403).json({ message: "Access denied" });
      }

      const { chatId } = req.params;
      const chat = await storage.getMaintenanceChatById(chatId);

      if (!chat || chat.tenantId !== userId) {
        return res.status(404).json({ message: "Chat not found" });
      }

      const messages = await storage.getTenantMaintenanceChatMessages(chatId);
      res.json({ ...chat, messages });
    } catch (error) {
      console.error("Error fetching chat:", error);
      res.status(500).json({ message: "Failed to fetch chat" });
    }
  });

  // Send message in maintenance chat with AI response
  app.post("/api/tenant/maintenance-chat/message", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user || user.role !== "tenant") {
        return res.status(403).json({ message: "Access denied" });
      }

      // Get tenant's tenancy to access propertyId
      const tenancy = await storage.getTenancyByTenantId(userId);
      if (!tenancy) {
        return res.status(404).json({ message: "No tenancy found for this tenant" });
      }

      const { chatId, message, imageUrl } = req.body;

      if (!message && !imageUrl) {
        return res.status(400).json({ message: "Message or image required" });
      }

      console.log("[Tenant Maintenance Chat] Received imageUrl:", imageUrl);

      let chat;
      if (chatId) {
        chat = await storage.getMaintenanceChatById(chatId);
        if (!chat || chat.tenantId !== userId) {
          return res.status(404).json({ message: "Chat not found" });
        }
      } else {
        const title = message.substring(0, 50) + (message.length > 50 ? "..." : "");
        chat = await storage.createTenantMaintenanceChat({
          tenantId: userId,
          organizationId: user.organizationId!,
          propertyId: tenancy.propertyId,
          title,
          status: "active",
        });
      }

      const userMessage = await storage.createTenantMaintenanceChatMessage({
        chatId: chat.id,
        role: "user",
        content: message || "See image",
        imageUrl,
      });

      let aiResponse = "";
      let aiSuggestedFixes = "";

      try {
        const openaiClient = getOpenAI();
        let imageUrlForAI: string | null = null;

        // Try to process image if provided
        if (imageUrl) {
          // Convert image to base64 if it's a localhost URL or internal path
          // OpenAI can't access localhost URLs, so we need to convert them to base64
          // Check if URL is localhost or internal (needs conversion)
          const isLocalhost = imageUrl.includes('localhost') || imageUrl.includes('127.0.0.1');
          const isInternalPath = imageUrl.startsWith('/objects/') || (!imageUrl.startsWith('http') && imageUrl.includes('/objects/'));
          const isLocalhostHttp = imageUrl.startsWith('http://localhost') || imageUrl.startsWith('https://localhost');

          const needsConversion = isLocalhost || isInternalPath || isLocalhostHttp;

          console.log("[Tenant Maintenance Chat] URL check:", {
            imageUrl,
            isLocalhost,
            isInternalPath,
            isLocalhostHttp,
            needsConversion
          });

          // Always convert localhost URLs and internal paths to base64
          if (needsConversion) {
            console.log("[Tenant Maintenance Chat] Detected localhost/internal URL, converting to base64:", imageUrl);
            try {
              const objectStorageService = new ObjectStorageService();

              // Extract path from URL if it's a full URL
              let photoPath = imageUrl;
              if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                try {
                  const urlObj = new URL(imageUrl);
                  photoPath = urlObj.pathname;
                  console.log("[Tenant Maintenance Chat] Extracted pathname from URL:", photoPath);
                } catch (e) {
                  // If URL parsing fails, try to extract path manually
                  const pathMatch = imageUrl.match(/\/objects\/[^?#]+/);
                  if (pathMatch) {
                    photoPath = pathMatch[0];
                    console.log("[Tenant Maintenance Chat] Extracted path using regex:", photoPath);
                  } else {
                    throw new Error(`Could not extract path from URL: ${imageUrl}`);
                  }
                }
              }

              // Ensure path starts with /objects/
              if (!photoPath.startsWith('/objects/')) {
                // If it's just an object ID, prepend /objects/
                if (!photoPath.startsWith('/')) {
                  photoPath = `/objects/${photoPath}`;
                } else {
                  photoPath = `/objects${photoPath}`;
                }
              }

              console.log("[Tenant Maintenance Chat] Loading file from path:", photoPath);
              const objectFile = await objectStorageService.getObjectEntityFile(photoPath);
              const photoBuffer = await fs.readFile(objectFile.name);

              console.log("[Tenant Maintenance Chat] File loaded, size:", photoBuffer.length, "bytes");

              // Detect MIME type from buffer
              let mimeType = detectImageMimeType(photoBuffer);

              // Ensure we have a valid image MIME type
              if (!mimeType || !mimeType.startsWith('image/')) {
                console.warn(`[Tenant Maintenance Chat] Invalid MIME type detected: ${mimeType}, defaulting to image/jpeg`);
                mimeType = 'image/jpeg';
              }

              // Convert to base64 data URL
              const base64Image = photoBuffer.toString('base64');
              imageUrlForAI = `data:${mimeType};base64,${base64Image}`;

              console.log("[Tenant Maintenance Chat] Successfully converted to base64 data URL, MIME type:", mimeType, "Size:", base64Image.length, "chars");
            } catch (error: any) {
              console.error("[Tenant Maintenance Chat] Error converting image to base64, will proceed with text-only:", {
                imageUrl,
                message: error?.message || String(error),
                errorType: error?.constructor?.name,
              });
              // Continue with text-only analysis if image conversion fails
              imageUrlForAI = null;
            }
          } else {
            console.log("[Tenant Maintenance Chat] Using external URL directly:", imageUrl);
            imageUrlForAI = imageUrl;
          }
        }

        // Make AI call with or without image
        let aiCallSucceeded = false;

        // Try with image first if available
        if (imageUrlForAI) {
          console.log("[Tenant Maintenance Chat] Making AI call with image");
          try {
            const analysisCompletion = await openaiClient.chat.completions.create({
              model: "gpt-4o",
              messages: [
                {
                  role: "system",
                  content: "You are a helpful maintenance assistant. Analyze the issue and provide simple suggestions on how to fix it."
                },
                {
                  role: "user",
                  content: [
                    { type: "text", text: message || "Please analyze this maintenance issue" },
                    { type: "image_url", image_url: { url: imageUrlForAI } },
                  ],
                },
              ],
              max_completion_tokens: 1000,
            });

            console.log("[Tenant Maintenance Chat] Full OpenAI response with image:", JSON.stringify(analysisCompletion, null, 2));

            const responseContent = analysisCompletion.choices?.[0]?.message?.content;
            const finishReason = analysisCompletion.choices?.[0]?.finish_reason;
            const usage = analysisCompletion.usage;

            console.log("[Tenant Maintenance Chat] Extracted content:", {
              hasChoices: !!analysisCompletion.choices,
              choicesLength: analysisCompletion.choices?.length,
              firstChoice: analysisCompletion.choices?.[0],
              message: analysisCompletion.choices?.[0]?.message,
              content: responseContent,
              contentType: typeof responseContent,
              contentLength: responseContent?.length,
              finishReason: finishReason,
              reasoningTokens: usage?.completion_tokens_details?.reasoning_tokens,
            });

            if (responseContent && responseContent.trim().length > 0) {
              aiResponse = "I've analyzed your issue. Here are some suggestions:";
              aiSuggestedFixes = cleanMarkdownText(responseContent.trim());
              aiCallSucceeded = true;
              console.log("[Tenant Maintenance Chat] Successfully got AI response with image, length:", aiSuggestedFixes.length);
            } else if (finishReason === "length" && usage?.completion_tokens_details?.reasoning_tokens) {
              console.warn("[Tenant Maintenance Chat] Response hit token limit - all tokens used for reasoning, will try text-only with higher limit");
              // Retry with text-only and higher token limit
            } else {
              console.warn("[Tenant Maintenance Chat] OpenAI returned empty or whitespace-only response with image, will try text-only");
            }
          } catch (imageError: any) {
            console.error("[Tenant Maintenance Chat] Error with image analysis, will try text-only:", imageError?.message);
          }
        }

        // If image analysis failed or no image, try text-only
        if (!aiCallSucceeded) {
          // Text-only message - no image or image conversion failed
          console.log("[Tenant Maintenance Chat] Processing text-only message:", message);
          const completion = await openaiClient.chat.completions.create({
            model: "gpt-4o",
            messages: [
              {
                role: "system",
                content: "You are a helpful maintenance assistant. Analyze the issue and provide simple suggestions on how to fix it."
              },
              { role: "user", content: message },
            ],
            max_completion_tokens: 1000,
          });

          console.log("[Tenant Maintenance Chat] Full OpenAI response (text-only):", JSON.stringify(completion, null, 2));

          const responseContent = completion.choices?.[0]?.message?.content;
          const finishReason = completion.choices?.[0]?.finish_reason;
          const usage = completion.usage;

          console.log("[Tenant Maintenance Chat] Extracted content (text-only):", {
            hasChoices: !!completion.choices,
            choicesLength: completion.choices?.length,
            firstChoice: completion.choices?.[0],
            message: completion.choices?.[0]?.message,
            content: responseContent,
            contentType: typeof responseContent,
            contentLength: responseContent?.length,
            finishReason: finishReason,
            reasoningTokens: usage?.completion_tokens_details?.reasoning_tokens,
            totalTokens: usage?.total_tokens,
          });

          if (responseContent && responseContent.trim().length > 0) {
            aiResponse = "I've analyzed your issue. Here are some suggestions:";
            aiSuggestedFixes = cleanMarkdownText(responseContent.trim());
            console.log("[Tenant Maintenance Chat] Successfully got AI response, length:", aiSuggestedFixes.length);
          } else if (finishReason === "length" && usage?.completion_tokens_details?.reasoning_tokens) {
            // All tokens were used for reasoning, provide a helpful message
            console.error("[Tenant Maintenance Chat] Response hit token limit - all tokens used for reasoning");
            aiResponse = "I'm analyzing your issue, but I need more information.";
            aiSuggestedFixes = "Could you provide more details about the problem, such as what exactly is broken, when it started, and what you've already tried?";
            aiCallSucceeded = true; // Mark as succeeded so we don't throw error
          } else {
            console.error("[Tenant Maintenance Chat] OpenAI returned empty or whitespace-only response");
            throw new Error("OpenAI returned empty response");
          }
        }
      } catch (error: any) {
        console.error("[Tenant Maintenance Chat] AI analysis error:", {
          error: error,
          message: error?.message,
          stack: error?.stack,
          code: error?.code,
          status: error?.status,
          imageUrl: imageUrl || 'none',
          hasMessage: !!message,
        });

        // Provide more specific error messages based on error type
        if (error?.code === 'invalid_image_url' || error?.message?.includes('downloading')) {
          aiResponse = "I'm having trouble accessing the image you uploaded. Please try uploading the image again or describe the issue in text.";
          aiSuggestedFixes = "";
        } else if (error?.message?.includes('base64')) {
          aiResponse = "I'm having trouble processing the image. Please try uploading it again or describe the issue in text.";
          aiSuggestedFixes = "";
        } else if (error?.message?.includes('OpenAI') || error?.message?.includes('empty response')) {
          aiResponse = "I'm having trouble connecting to the AI service. Please try again in a moment or create a maintenance request directly.";
          aiSuggestedFixes = "";
        } else if (error?.message) {
          aiResponse = "I encountered an error while analyzing your issue.";
          aiSuggestedFixes = cleanMarkdownText(error.message);
        } else {
          aiResponse = "I'm having trouble analyzing this right now. You may want to create a maintenance request directly.";
          aiSuggestedFixes = "";
        }
      }

      const assistantMessage = await storage.createTenantMaintenanceChatMessage({
        chatId: chat.id,
        role: "assistant",
        content: aiResponse,
        aiSuggestedFixes,
      });

      res.json({ chatId: chat.id, userMessage, assistantMessage });
    } catch (error) {
      console.error("Error sending maintenance chat message:", error);
      res.status(500).json({ message: "Failed to send message" });
    }
  });

  // Create maintenance request from chat
  app.post("/api/tenant/maintenance-chat/create-request", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user || user.role !== "tenant" || !user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { chatId } = req.body;
      const chat = await storage.getMaintenanceChatById(chatId);

      if (!chat || chat.tenantId !== userId) {
        return res.status(404).json({ message: "Chat not found" });
      }

      if (chat.maintenanceRequestId) {
        return res.status(400).json({ message: "Maintenance request already created for this chat" });
      }

      const messages = await storage.getTenantMaintenanceChatMessages(chatId);
      const tenancy = await storage.getTenancyByTenantId(userId);

      if (!tenancy) {
        return res.status(400).json({ message: "No tenancy found" });
      }

      let description = "";
      let photoUrls: string[] = [];
      let aiSuggestedFixes = "";

      for (const msg of messages) {
        if (msg.role === "user") {
          description += msg.content + "\n\n";
          if (msg.imageUrl) {
            photoUrls.push(msg.imageUrl);
          }
        } else if (msg.role === "assistant" && msg.aiSuggestedFixes) {
          aiSuggestedFixes = msg.aiSuggestedFixes;
        }
      }

      const maintenanceRequest = await storage.createMaintenanceRequest({
        title: chat.title,
        description: description.trim(),
        priority: "medium",
        status: "open",
        propertyId: tenancy.propertyId,
        reportedBy: userId,
        organizationId: user.organizationId,
        photoUrls,
        aiSuggestedFixes,
      });

      await storage.updateTenantMaintenanceChat(chatId, {
        maintenanceRequestId: maintenanceRequest.id,
        status: "resolved",
      });

      res.json(maintenanceRequest);
    } catch (error) {
      console.error("Error creating maintenance request from chat:", error);
      res.status(500).json({ message: "Failed to create maintenance request" });
    }
  });

  // Get tenant's maintenance requests
  app.get("/api/tenant/maintenance-requests", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user || user.role !== "tenant") {
        return res.status(403).json({ message: "Access denied" });
      }

      const requests = await storage.getMaintenanceRequestsByReporter(userId);
      res.json(requests);
    } catch (error) {
      console.error("Error fetching tenant maintenance requests:", error);
      res.status(500).json({ message: "Failed to fetch requests" });
    }
  });

  // ==================== TENANT COMPARISON REPORTS ====================

  // Get tenant's comparison reports
  app.get("/api/tenant/comparison-reports", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user || user.role !== "tenant") {
        return res.status(403).json({ message: "Access denied" });
      }

      const reports = await storage.getComparisonReportsByTenant(userId);

      // Enrich with property info
      const enrichedReports = await Promise.all(
        reports.map(async (report) => {
          const property = await storage.getProperty(report.propertyId);
          return {
            ...report,
            property: property ? { id: property.id, name: property.name, address: property.address } : null,
          };
        })
      );

      res.json(enrichedReports);
    } catch (error) {
      console.error("Error fetching tenant comparison reports:", error);
      res.status(500).json({ message: "Failed to fetch comparison reports" });
    }
  });

  // Get single comparison report for tenant (with items and non-internal comments)
  app.get("/api/tenant/comparison-reports/:id", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user || user.role !== "tenant") {
        return res.status(403).json({ message: "Access denied" });
      }

      const report = await storage.getComparisonReport(id);
      if (!report) {
        return res.status(404).json({ message: "Comparison report not found" });
      }

      // Verify tenant has access to this report - check if tenant has assignment to the property
      // Get tenant assignments for this tenant
      const assignments = await db
        .select({ propertyId: tenantAssignments.propertyId })
        .from(tenantAssignments)
        .where(eq(tenantAssignments.tenantId, userId));

      const tenantPropertyIds = assignments.map(a => a.propertyId);
      const tenantHasAccess = tenantPropertyIds.includes(report.propertyId);

      if (!tenantHasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Get report items
      const items = await storage.getComparisonReportItems(id);

      // Extract photos from aiComparisonJson and also fetch from entries if needed
      const itemsWithPhotos = await Promise.all(items.map(async (item) => {
        const aiComparison = item.aiComparisonJson || {};
        let checkInPhotos = aiComparison.checkInPhotos || [];
        let checkOutPhotos = aiComparison.checkOutPhotos || [];

        // If check-in photos are missing from aiComparisonJson, fetch from check-in entry
        if ((!checkInPhotos || checkInPhotos.length === 0) && item.checkInEntryId) {
          try {
            const checkInEntry = await storage.getInspectionEntry(item.checkInEntryId);
            if (checkInEntry) {
              // Get photos from photos column or valueJson
              if (checkInEntry.photos && Array.isArray(checkInEntry.photos) && checkInEntry.photos.length > 0) {
                checkInPhotos = checkInEntry.photos;
              } else if (checkInEntry.valueJson && typeof checkInEntry.valueJson === 'object') {
                const valueJson = checkInEntry.valueJson as any;
                if (Array.isArray(valueJson.photos)) {
                  checkInPhotos = valueJson.photos;
                } else if (typeof valueJson.photo === 'string' && valueJson.photo) {
                  checkInPhotos = [valueJson.photo];
                }
              }
              console.log(`[ComparisonReport] Fetched ${checkInPhotos.length} check-in photos from entry ${item.checkInEntryId} for item ${item.id}`);
            }
          } catch (error) {
            console.error(`[ComparisonReport] Error fetching check-in entry ${item.checkInEntryId}:`, error);
          }
        }

        // If check-out photos are missing from aiComparisonJson, fetch from check-out entry
        if ((!checkOutPhotos || checkOutPhotos.length === 0) && item.checkOutEntryId) {
          try {
            const checkOutEntry = await storage.getInspectionEntry(item.checkOutEntryId);
            if (checkOutEntry) {
              // Get photos from photos column or valueJson
              if (checkOutEntry.photos && Array.isArray(checkOutEntry.photos) && checkOutEntry.photos.length > 0) {
                checkOutPhotos = checkOutEntry.photos;
              } else if (checkOutEntry.valueJson && typeof checkOutEntry.valueJson === 'object') {
                const valueJson = checkOutEntry.valueJson as any;
                if (Array.isArray(valueJson.photos)) {
                  checkOutPhotos = valueJson.photos;
                } else if (typeof valueJson.photo === 'string' && valueJson.photo) {
                  checkOutPhotos = [valueJson.photo];
                }
              }
            }
          } catch (error) {
            console.error(`[ComparisonReport] Error fetching check-out entry ${item.checkOutEntryId}:`, error);
          }
        }

        return {
          ...item,
          checkInPhotos: checkInPhotos,
          checkOutPhotos: checkOutPhotos,
        };
      }));

      // Get property info
      const property = await storage.getProperty(report.propertyId);

      res.json({
        ...report,
        items: itemsWithPhotos,
        property: property ? { id: property.id, name: property.name, address: property.address } : null,
      });
    } catch (error) {
      console.error("Error fetching tenant comparison report:", error);
      res.status(500).json({ message: "Failed to fetch comparison report" });
    }
  });

  // Get comments for a comparison report (tenant view - excludes internal comments)
  app.get("/api/tenant/comparison-reports/:id/comments", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user || user.role !== "tenant") {
        return res.status(403).json({ message: "Access denied" });
      }

      const report = await storage.getComparisonReport(id);
      if (!report) {
        return res.status(404).json({ message: "Comparison report not found" });
      }

      // Verify tenant has access to this report - check if tenant has assignment to the property
      const assignments = await db
        .select({ propertyId: tenantAssignments.propertyId })
        .from(tenantAssignments)
        .where(eq(tenantAssignments.tenantId, userId));

      const tenantPropertyIds = assignments.map(a => a.propertyId);
      const tenantHasAccess = tenantPropertyIds.includes(report.propertyId);

      if (!tenantHasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }

      const allComments = await storage.getComparisonComments(id);
      // Filter out internal comments - tenants shouldn't see internal notes
      const publicComments = allComments.filter(c => !c.isInternal);

      res.json(publicComments);
    } catch (error) {
      console.error("Error fetching comments:", error);
      res.status(500).json({ message: "Failed to fetch comments" });
    }
  });

  // Add comment to comparison report (tenant)
  app.post("/api/tenant/comparison-reports/:id/comments", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { content } = req.body;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user || user.role !== "tenant") {
        return res.status(403).json({ message: "Access denied" });
      }

      // Validate content is a non-empty string
      if (typeof content !== "string" || content.trim().length === 0) {
        return res.status(400).json({ message: "Comment content is required" });
      }

      const trimmedContent = content.trim();

      const report = await storage.getComparisonReport(id);
      if (!report) {
        return res.status(404).json({ message: "Comparison report not found" });
      }

      // Verify tenant has access to this report - check if tenant has assignment to the property
      const assignments = await db
        .select({ propertyId: tenantAssignments.propertyId })
        .from(tenantAssignments)
        .where(eq(tenantAssignments.tenantId, userId));

      const tenantPropertyIds = assignments.map(a => a.propertyId);
      const tenantHasAccess = tenantPropertyIds.includes(report.propertyId);

      if (!tenantHasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Prevent comments on finalized reports or when already signed
      if (report.status === "signed" || report.status === "filed" || report.tenantSignature) {
        return res.status(409).json({ message: "Cannot add comments to finalized reports" });
      }

      const authorName = [user.firstName, user.lastName].filter(Boolean).join(" ") || user.email;

      const comment = await storage.createComparisonComment({
        comparisonReportId: id,
        userId: user.id,
        authorName,
        authorRole: "tenant",
        content: trimmedContent,
        isInternal: false, // Tenant comments are always public
      });

      res.json(comment);
    } catch (error) {
      console.error("Error creating comment:", error);
      res.status(500).json({ message: "Failed to create comment" });
    }
  });

  // Sign comparison report (tenant)
  app.post("/api/tenant/comparison-reports/:id/sign", isAuthenticated, async (req: any, res) => {
    try {
      const { id } = req.params;
      const { signature } = req.body;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user || user.role !== "tenant") {
        return res.status(403).json({ message: "Access denied" });
      }

      if (!signature || signature.trim().length === 0) {
        return res.status(400).json({ message: "Signature is required" });
      }

      const report = await storage.getComparisonReport(id);
      if (!report) {
        return res.status(404).json({ message: "Comparison report not found" });
      }

      // Verify tenant has access to this report - check if tenant has assignment to the property
      const assignments = await db
        .select({ propertyId: tenantAssignments.propertyId })
        .from(tenantAssignments)
        .where(eq(tenantAssignments.tenantId, userId));

      const tenantPropertyIds = assignments.map(a => a.propertyId);
      const tenantHasAccess = tenantPropertyIds.includes(report.propertyId);

      if (!tenantHasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Check report is in a signable state
      if (report.status !== "awaiting_signatures" && report.status !== "under_review") {
        return res.status(400).json({ message: "Report is not ready for signature" });
      }

      if (report.tenantSignature) {
        return res.status(400).json({ message: "You have already signed this report" });
      }

      // If signature is a data URL (image), extract the user's name from user object
      // Otherwise, use the signature as the typed name (backward compatibility)
      let signatureName: string;
      if (signature.startsWith('data:image/')) {
        // It's a signature image - use user's full name
        signatureName = user.firstName && user.lastName
          ? `${user.firstName} ${user.lastName}`.trim()
          : user.email || user.username || 'Tenant';
      } else {
        // It's a typed name (backward compatibility)
        signatureName = signature.trim();
      }

      const ipAddress = req.ip || req.connection?.remoteAddress || "unknown";
      const now = new Date();

      // Store signature data URL if it's an image, otherwise store typed name
      const signatureToStore = signature.startsWith('data:image/') ? signature : signatureName;

      const updates: any = {
        tenantSignature: signatureToStore,
        tenantSignedAt: now,
        tenantIpAddress: ipAddress,
      };

      // Check if both parties have now signed
      if (report.operatorSignature) {
        updates.status = "signed";
      } else {
        updates.status = "awaiting_signatures";
      }

      const updatedReport = await storage.updateComparisonReport(id, updates);
      res.json(updatedReport);
    } catch (error) {
      console.error("Error signing comparison report:", error);
      res.status(500).json({ message: "Failed to sign comparison report" });
    }
  });

  // Dispute a comparison report item (tenant)
  // ==================== TENANT CHECK-IN REVIEW ROUTES ====================

  // Get pending check-in inspections for tenant
  app.get("/api/tenant/check-ins", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user || user.role !== "tenant") {
        return res.status(403).json({ message: "Access denied" });
      }

      // Get tenant's property assignment
      const tenancy = await storage.getTenancyByTenantId(userId);
      if (!tenancy || !tenancy.propertyId) {
        return res.json([]);
      }

      // Get all check-in inspections for this property that need tenant approval
      const allInspections = await storage.getInspectionsByOrganization(user.organizationId!);
      const propertyInspections = allInspections.filter(
        (i: any) =>
          i.propertyId === tenancy.propertyId &&
          i.type === "check_in" &&
          i.status === "completed" &&
          (i.tenantApprovalStatus === "pending" || i.tenantApprovalStatus === null || !i.tenantApprovalStatus)
      );

      // Auto-approve expired pending inspections
      const now = new Date();
      const autoApprovedInspections: string[] = [];

      for (const inspection of propertyInspections) {
        // Check if deadline exists and has passed
        if (inspection.tenantApprovalDeadline) {
          const deadline = new Date(inspection.tenantApprovalDeadline);
          if (deadline < now && (!inspection.tenantApprovalStatus || inspection.tenantApprovalStatus === "pending")) {
            // Auto-approve expired pending inspections
            try {
              await storage.updateInspection(inspection.id, {
                tenantApprovalStatus: "approved",
                tenantApprovedAt: now,
                tenantApprovedBy: userId, // Set to tenant who would have approved
              } as any);
              autoApprovedInspections.push(inspection.id);
            } catch (error) {
              console.error(`Failed to auto-approve inspection ${inspection.id}:`, error);
            }
          }
        }
      }

      // Filter to only pending (not auto-approved, not already approved/disputed)
      const pendingInspections = propertyInspections.filter(
        (i: any) => {
          // Exclude auto-approved ones
          if (autoApprovedInspections.includes(i.id)) return false;

          // Exclude already approved or disputed
          if (i.tenantApprovalStatus === "approved" || i.tenantApprovalStatus === "disputed") return false;

          // Check if deadline has passed (should have been auto-approved above, but double-check)
          if (i.tenantApprovalDeadline) {
            const deadline = new Date(i.tenantApprovalDeadline);
            if (deadline < now) return false; // Expired, should be auto-approved
          }

          // Only include pending or null status
          return !i.tenantApprovalStatus || i.tenantApprovalStatus === "pending";
        }
      );

      res.json(pendingInspections);
    } catch (error: any) {
      console.error("Error fetching tenant check-ins:", error);
      res.status(500).json({ message: "Failed to fetch check-in inspections" });
    }
  });

  // Tenant approve check-in inspection
  app.post("/api/inspections/:id/tenant-approve", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user || user.role !== "tenant") {
        return res.status(403).json({ message: "Access denied" });
      }

      const { id } = req.params;
      const { comments } = req.body;

      // Get inspection
      const inspection = await storage.getInspection(id);
      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }

      // Verify tenant has access to this property
      const tenancy = await storage.getTenancyByTenantId(userId);
      if (!tenancy || tenancy.propertyId !== inspection.propertyId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Verify it's a check-in inspection
      if (inspection.type !== "check_in") {
        return res.status(400).json({ message: "Only check-in inspections can be approved by tenants" });
      }

      // Check if already approved/disputed
      if (inspection.tenantApprovalStatus === "approved" || inspection.tenantApprovalStatus === "disputed") {
        return res.status(400).json({ message: "This inspection has already been processed" });
      }

      // Auto-approve if deadline has passed
      if (inspection.tenantApprovalDeadline && new Date(inspection.tenantApprovalDeadline) < new Date()) {
        // Auto-approve instead of rejecting
        const updatedInspection = await storage.updateInspection(id, {
          tenantApprovalStatus: "approved",
          tenantApprovedAt: new Date(),
          tenantApprovedBy: userId,
          tenantComments: comments || null,
        } as any);
        return res.json(updatedInspection);
      }

      // Update inspection
      const updatedInspection = await storage.updateInspection(id, {
        tenantApprovalStatus: "approved",
        tenantApprovedAt: new Date(),
        tenantApprovedBy: userId,
        tenantComments: comments || null,
      } as any);

      res.json(updatedInspection);
    } catch (error: any) {
      console.error("Error approving check-in:", error);
      res.status(500).json({ message: "Failed to approve check-in" });
    }
  });

  // Tenant dispute check-in inspection
  app.post("/api/inspections/:id/tenant-dispute", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user || user.role !== "tenant") {
        return res.status(403).json({ message: "Access denied" });
      }

      const { id } = req.params;
      const { comments } = req.body;

      if (!comments || !comments.trim()) {
        return res.status(400).json({ message: "Comments are required when disputing an inspection" });
      }

      // Get inspection
      const inspection = await storage.getInspection(id);
      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }

      // Verify tenant has access to this property
      const tenancy = await storage.getTenancyByTenantId(userId);
      if (!tenancy || tenancy.propertyId !== inspection.propertyId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Verify it's a check-in inspection
      if (inspection.type !== "check_in") {
        return res.status(400).json({ message: "Only check-in inspections can be disputed by tenants" });
      }

      // Check if already approved/disputed
      if (inspection.tenantApprovalStatus === "approved" || inspection.tenantApprovalStatus === "disputed") {
        return res.status(400).json({ message: "This inspection has already been processed" });
      }

      // Auto-approve if deadline has passed (can't dispute after deadline)
      if (inspection.tenantApprovalDeadline && new Date(inspection.tenantApprovalDeadline) < new Date()) {
        // Auto-approve instead of allowing dispute
        const updatedInspection = await storage.updateInspection(id, {
          tenantApprovalStatus: "approved",
          tenantApprovedAt: new Date(),
          tenantApprovedBy: userId,
          tenantComments: comments,
        } as any);
        return res.json(updatedInspection);
      }

      // Update inspection
      const updatedInspection = await storage.updateInspection(id, {
        tenantApprovalStatus: "disputed",
        tenantComments: comments,
      } as any);

      res.json(updatedInspection);
    } catch (error: any) {
      console.error("Error disputing check-in:", error);
      res.status(500).json({ message: "Failed to dispute check-in" });
    }
  });

  // Tenant save comments (without approval/dispute)
  app.patch("/api/inspections/:id/tenant-comments", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user || user.role !== "tenant") {
        return res.status(403).json({ message: "Access denied" });
      }

      const { id } = req.params;
      const { comments } = req.body;

      // Get inspection
      const inspection = await storage.getInspection(id);
      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }

      // Verify tenant has access to this property
      const tenancy = await storage.getTenancyByTenantId(userId);
      if (!tenancy || tenancy.propertyId !== inspection.propertyId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Verify it's a check-in inspection
      if (inspection.type !== "check_in") {
        return res.status(400).json({ message: "Only check-in inspections can have tenant comments" });
      }

      // Check if already approved/disputed
      if (inspection.tenantApprovalStatus === "approved" || inspection.tenantApprovalStatus === "disputed") {
        return res.status(400).json({ message: "Cannot update comments after approval/dispute" });
      }

      // Update inspection
      const updatedInspection = await storage.updateInspection(id, {
        tenantComments: comments || null,
      } as any);

      res.json(updatedInspection);
    } catch (error: any) {
      console.error("Error saving tenant comments:", error);
      res.status(500).json({ message: "Failed to save comments" });
    }
  });

  app.post("/api/tenant/comparison-reports/:reportId/items/:itemId/dispute", isAuthenticated, async (req: any, res) => {
    try {
      const { reportId, itemId } = req.params;
      const { reason } = req.body; // Only accept reason - itemType is determined server-side
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user || user.role !== "tenant") {
        return res.status(403).json({ message: "Access denied" });
      }

      if (!reason || reason.trim().length === 0) {
        return res.status(400).json({ message: "Dispute reason is required" });
      }

      const report = await storage.getComparisonReport(reportId);
      if (!report) {
        return res.status(404).json({ message: "Comparison report not found" });
      }

      // Verify tenant has access to this report
      const assignments = await db
        .select({ propertyId: tenantAssignments.propertyId })
        .from(tenantAssignments)
        .where(eq(tenantAssignments.tenantId, userId));

      const tenantPropertyIds = assignments.map(a => a.propertyId);
      const tenantHasAccess = tenantPropertyIds.includes(report.propertyId);

      if (!tenantHasAccess) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Prevent disputes on finalized reports
      if (report.status === "signed" || report.status === "filed" || report.tenantSignature) {
        return res.status(409).json({ message: "Cannot dispute items on finalized reports" });
      }

      // Get the comparison report item
      const items = await storage.getComparisonReportItems(reportId);
      const item = items.find((i: any) => i.id === itemId);

      if (!item) {
        return res.status(404).json({ message: "Comparison report item not found" });
      }

      // Get property for location data
      const property = await storage.getProperty(report.propertyId);
      if (!property) {
        return res.status(404).json({ message: "Property not found" });
      }

      let aiCostNotes = "";
      let costMethod = "";
      let calculatedCost = item.estimatedCost;
      let calculatedDepreciation = item.depreciation;
      let calculatedFinalCost = item.finalCost;
      let verifiedAssetId: string | null = null;

      // Server-side only: Check if there's an existing linked asset on the item
      // This is set by operators during comparison report creation, not by tenants
      const existingAssetId = item.assetInventoryId;
      let matchedAsset = null;

      if (existingAssetId) {
        // Only use assets that are already linked AND belong to the right organization
        const { assetInventory } = await import("@shared/schema");
        const { db } = await import("./db");
        const { eq, and } = await import("drizzle-orm");
        const assets = await db.select()
          .from(assetInventory)
          .where(and(
            eq(assetInventory.id, existingAssetId),
            eq(assetInventory.organizationId, report.organizationId),
            eq(assetInventory.propertyId, report.propertyId)
          ))
          .limit(1);
        if (assets.length > 0) {
          matchedAsset = assets[0];
          verifiedAssetId = existingAssetId;
        }
      }

      // Determine item type purely from server-side data - tenant cannot influence this
      const actualItemType = matchedAsset ? "inventory" : "maintenance";

      // Process based on actual (verified) item type
      if (actualItemType === "inventory" && matchedAsset) {
        // Inventory item - use depreciated value
        costMethod = "depreciation";

        const asset = matchedAsset;
        const purchasePrice = parseFloat(asset.purchasePrice || "0");
        const currentValue = parseFloat(asset.currentValue || "0");
        const depreciationPerYear = parseFloat(asset.depreciationPerYear || "0");
        const expectedLifespan = asset.expectedLifespanYears || 5;

        // Calculate depreciated value if not already set
        let depreciatedValue = currentValue;
        if (depreciatedValue === 0 && purchasePrice > 0 && asset.datePurchased) {
          const purchaseDate = new Date(asset.datePurchased);
          const yearsOwned = Math.max(0, (Date.now() - purchaseDate.getTime()) / (1000 * 60 * 60 * 24 * 365));
          const totalDepreciation = depreciationPerYear > 0
            ? depreciationPerYear * yearsOwned
            : (purchasePrice / expectedLifespan) * yearsOwned;
          depreciatedValue = Math.max(0, purchasePrice - totalDepreciation);
        }

        calculatedCost = depreciatedValue.toFixed(2);
        calculatedDepreciation = (purchasePrice - depreciatedValue).toFixed(2);
        calculatedFinalCost = depreciatedValue.toFixed(2);

        aiCostNotes = `DEPRECIATION-BASED COST CALCULATION:
Asset: ${asset.name}
Category: ${asset.category || "N/A"}
Original Purchase Price: Â£${purchasePrice.toFixed(2)}
Purchase Date: ${asset.datePurchased ? format(new Date(asset.datePurchased), "MMM d, yyyy") : "Unknown"}
Expected Lifespan: ${expectedLifespan} years
Annual Depreciation: Â£${depreciationPerYear.toFixed(2)}
Current Depreciated Value: Â£${depreciatedValue.toFixed(2)}
Total Depreciation Applied: Â£${(purchasePrice - depreciatedValue).toFixed(2)}

The repair/replacement cost has been calculated using the asset's depreciated value rather than the original purchase price. This reflects fair wear and tear over the item's lifetime.`;
      } else {
        // Maintenance issue - search for local repair costs
        costMethod = "local_market_search";

        const location = `${(property as any).city || ""}, ${property.address || ""}`.trim();
        const itemDescription = item.itemRef || item.sectionRef || item.fieldKey;

        // Use AI to search for local repair costs
        try {
          const openaiApiKey = process.env.OPENAI_API_KEY || process.env.AI_INTEGRATIONS_OPENAI_API_KEY;
          if (openaiApiKey) {
            const openai = new OpenAI({ apiKey: openaiApiKey });

            const searchPrompt = `You are a property maintenance cost estimator. Based on the location and issue described, provide an estimated cost range for repair in the UK market.

Location: ${location}
Issue/Item: ${itemDescription}
${item.aiSummary ? `Description: ${item.aiSummary}` : ""}

Please provide:
1. Average cost range for this type of repair in this area
2. Factors that affect the price (e.g., labor rates, materials)
3. Recommendation for next steps

Format your response as a brief, professional cost assessment note. Include specific price ranges in GBP (Â£).`;

            const response = await openai.chat.completions.create({
              model: "gpt-4o",
              messages: [
                { role: "system", content: "You are a property maintenance cost expert with knowledge of UK repair costs." },
                { role: "user", content: searchPrompt }
              ],
              max_tokens: 500,
              temperature: 0.3,
            });

            aiCostNotes = `LOCAL MARKET REPAIR COST ANALYSIS:
Location: ${location}
Issue: ${itemDescription}

${response.choices[0]?.message?.content || "Unable to retrieve cost estimate."}

Note: This is an AI-generated estimate based on typical market rates. Actual costs may vary based on specific contractor quotes and property conditions.`;
          } else {
            aiCostNotes = `LOCAL MARKET ANALYSIS UNAVAILABLE:
OpenAI API key not configured. Original cost estimate retained.
Please obtain quotes from local contractors for accurate pricing.`;
          }
        } catch (aiError) {
          console.error("Error getting AI cost estimate:", aiError);
          aiCostNotes = `LOCAL MARKET ANALYSIS ERROR:
Unable to retrieve local market pricing. Original cost estimate retained.
Recommendation: Obtain quotes from local contractors for ${itemDescription}.`;
        }
      }

      // Update the comparison report item with dispute information
      const updatedItem = await db.update(comparisonReportItems)
        .set({
          status: "disputed",
          disputeReason: reason.trim(),
          disputedAt: new Date(),
          aiCostCalculationNotes: aiCostNotes,
          costCalculationMethod: costMethod || null,
          assetInventoryId: verifiedAssetId,
          estimatedCost: calculatedCost,
          depreciation: calculatedDepreciation,
          finalCost: calculatedFinalCost,
          updatedAt: new Date(),
        })
        .where(eq(comparisonReportItems.id, itemId))
        .returning();

      // Also add a comment to the report for visibility
      await storage.createComparisonComment({
        comparisonReportId: reportId,
        comparisonReportItemId: itemId,
        userId: user.id,
        authorName: [user.firstName, user.lastName].filter(Boolean).join(" ") || user.email,
        authorRole: "tenant",
        content: `DISPUTE RAISED: ${reason.trim()}\n\n${aiCostNotes}`,
        isInternal: false,
      });

      res.json({
        item: updatedItem[0],
        message: "Item disputed successfully",
        aiCostNotes,
      });
    } catch (error) {
      console.error("Error disputing comparison report item:", error);
      res.status(500).json({ message: "Failed to dispute item" });
    }
  });

  // ==================== REPORTS ====================

  // Branding info type for reports
  interface ReportTrademarkInfo {
    imageUrl: string;
    altText?: string | null;
  }

  interface ReportBrandingInfo {
    logoUrl?: string | null;
    brandingName?: string | null;
    brandingEmail?: string | null;
    brandingPhone?: string | null;
    brandingWebsite?: string | null;
    trademarks?: ReportTrademarkInfo[];
  }

  // Sanitize URL for use in HTML attributes
  function sanitizeReportUrl(url: string): string {
    if (typeof url !== 'string' || !url.trim()) return '';
    const trimmed = url.trim();
    const lower = trimmed.toLowerCase();
    const safeProtocols = ['https://', 'http://'];
    const isSafeProtocol = safeProtocols.some(protocol => lower.startsWith(protocol));
    if (!isSafeProtocol) return '';
    return trimmed.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#039;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }

  // Helper function to generate Inspections Report HTML
  function generateInspectionsReportHTML(
    inspections: any[],
    properties: any[],
    blocks: any[],
    users: any[],
    filters: any,
    branding?: ReportBrandingInfo
  ): string {
    const escapeHtml = (str: string) => {
      if (!str) return '';
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    };

    const formatDate = (date: string | null) => {
      if (!date) return "N/A";
      return format(new Date(date), "MMM d, yyyy");
    };

    const getStatusBadge = (status: string) => {
      const statusMap: Record<string, { bg: string; color: string }> = {
        scheduled: { bg: "#f3f4f6", color: "#374151" },
        in_progress: { bg: "#dbeafe", color: "#1e40af" },
        completed: { bg: "#dcfce7", color: "#166534" },
        cancelled: { bg: "#fee2e2", color: "#991b1b" },
      };
      const config = statusMap[status] || { bg: "#f3f4f6", color: "#374151" };
      return `<span style="background: ${config.bg}; color: ${config.color}; padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: 600; text-transform: capitalize;">${escapeHtml(status.replace(/_/g, " "))}</span>`;
    };

    const totalInspections = inspections.length;
    const completedCount = inspections.filter(i => i.status === "completed").length;
    const inProgressCount = inspections.filter(i => i.status === "in_progress").length;
    const scheduledCount = inspections.filter(i => i.status === "scheduled").length;

    const filterSummary = [];
    if (filters.status && filters.status !== "all") filterSummary.push(`Status: ${filters.status}`);
    if (filters.type && filters.type !== "all") filterSummary.push(`Type: ${filters.type}`);
    if (filters.dateFrom) filterSummary.push(`From: ${formatDate(filters.dateFrom)}`);
    if (filters.dateTo) filterSummary.push(`To: ${formatDate(filters.dateTo)}`);

    // Branding for cover page
    const companyName = branding?.brandingName || "Inspect360";
    const hasLogo = !!branding?.logoUrl;
    const logoHtml = hasLogo
      ? `<img src="${sanitizeReportUrl(branding.logoUrl!)}" alt="${escapeHtml(companyName)}" class="cover-logo-img" />`
      : `<div class="cover-logo-text">${escapeHtml(companyName)}</div>`;
    const companyNameHtml = hasLogo
      ? `<div class="cover-company-name">${escapeHtml(companyName)}</div>`
      : '';
    const contactParts: string[] = [];
    if (branding?.brandingEmail) contactParts.push(escapeHtml(branding.brandingEmail));
    if (branding?.brandingPhone) contactParts.push(escapeHtml(branding.brandingPhone));
    if (branding?.brandingWebsite) contactParts.push(escapeHtml(branding.brandingWebsite));
    const contactInfoHtml = contactParts.length > 0
      ? `<div class="cover-contact">${contactParts.join(' &nbsp;|&nbsp; ')}</div>`
      : '';

    const tableRows = inspections.map((inspection) => {
      const property = properties.find(p => p.id === inspection.propertyId);
      const block = blocks.find(b => b.id === property?.blockId);
      const inspector = users.find(u => u.id === inspection.inspectorId);
      const inspectorName = inspector
        ? `${inspector.firstName || ""} ${inspector.lastName || ""}`.trim() || inspector.email
        : "Unassigned";

      return `
        <tr style="border-bottom: 1px solid #e5e7eb;">
          <td style="padding: 10px 12px;">${formatDate(inspection.scheduledDate || inspection.createdAt)}</td>
          <td style="padding: 10px 12px; font-weight: 500;">${escapeHtml(property?.name || "Unknown")}</td>
          <td style="padding: 10px 12px;">${escapeHtml(block?.name || "N/A")}</td>
          <td style="padding: 10px 12px; text-transform: capitalize;">${escapeHtml(inspection.type?.replace(/-/g, " ") || "N/A")}</td>
          <td style="padding: 10px 12px;">${escapeHtml(inspectorName)}</td>
          <td style="padding: 10px 12px;">${getStatusBadge(inspection.status)}</td>
        </tr>
      `;
    }).join("");

    return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.5;
      color: #333;
      background: white;
    }
    /* Cover Page - Landscape optimized */
    .cover-page {
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      background: linear-gradient(135deg, #00D5CC 0%, #3B7A8C 100%);
      color: white;
      page-break-after: always;
      position: relative;
      overflow: hidden;
    }
    .cover-page::before {
      content: '';
      position: absolute;
      top: -50%;
      right: -20%;
      width: 60%;
      height: 200%;
      background: rgba(255, 255, 255, 0.03);
      transform: rotate(15deg);
    }
    .cover-content {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .cover-logo-container { margin-bottom: 32px; }
    .cover-logo-img {
      max-height: 100px;
      max-width: 280px;
      width: auto;
      height: auto;
      object-fit: contain;
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.15));
    }
    .cover-logo-text {
      font-size: 56px;
      font-weight: 800;
      letter-spacing: -2px;
      text-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    .cover-company-name {
      font-size: 24px;
      font-weight: 600;
      margin-top: 12px;
      opacity: 0.95;
    }
    .cover-divider {
      width: 100px;
      height: 3px;
      background: rgba(255, 255, 255, 0.5);
      margin: 28px 0;
      border-radius: 2px;
    }
    .cover-title { font-size: 38px; font-weight: 700; margin-bottom: 12px; }
    .cover-date { font-size: 16px; opacity: 0.9; margin-top: 16px; }
    .cover-filters { margin-top: 16px; font-size: 14px; opacity: 0.85; }
    .cover-contact {
      position: absolute;
      bottom: 32px;
      font-size: 13px;
      opacity: 0.8;
      z-index: 1;
    }
    /* Content area - Landscape optimized */
    .content { padding: 28px 36px; }
    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 3px solid #00D5CC;
      padding-bottom: 16px;
      margin-bottom: 24px;
    }
    .page-title { font-size: 26px; font-weight: 800; color: #00D5CC; }
    .page-date { font-size: 13px; color: #666; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 13px; }
    th { background: #f9fafb; padding: 10px 12px; text-align: left; font-weight: 600; color: #374151; border-bottom: 2px solid #e5e7eb; }
    .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin: 24px 0; }
    .stat-card { background: #f9fafb; padding: 16px; border-radius: 8px; border-left: 4px solid #00D5CC; }
    .stat-label { font-size: 11px; color: #666; text-transform: uppercase; margin-bottom: 6px; font-weight: 600; }
    .stat-value { font-size: 28px; font-weight: 700; color: #00D5CC; }
    .section-title { font-size: 20px; font-weight: 700; color: #1a1a1a; margin-top: 32px; margin-bottom: 14px; }
  </style>
</head>
<body>
  <div class="cover-page">
    <div class="cover-content">
      <div class="cover-logo-container">
        ${logoHtml}
        ${companyNameHtml}
      </div>
      <div class="cover-divider"></div>
      <div class="cover-title">Inspections Report</div>
      <div class="cover-date">Generated on ${format(new Date(), "MMMM d, yyyy 'at' h:mm a")}</div>
      ${filterSummary.length > 0 ? `<div class="cover-filters">Filters: ${escapeHtml(filterSummary.join(" | "))}</div>` : ""}
    </div>
    ${contactInfoHtml}
  </div>

  <div class="content">
    <div class="page-header">
      <div class="page-title">Inspections Summary</div>
      <div class="page-date">${format(new Date(), "MMMM d, yyyy")}</div>
    </div>

    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">Total Inspections</div>
        <div class="stat-value">${totalInspections}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Completed</div>
        <div class="stat-value">${completedCount}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">In Progress</div>
        <div class="stat-value">${inProgressCount}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Scheduled</div>
        <div class="stat-value">${scheduledCount}</div>
      </div>
    </div>

    <h2 class="section-title">Inspection Records</h2>
    
    ${inspections.length > 0 ? `
      <table>
        <thead>
          <tr>
            <th>Date</th>
            <th>Property</th>
            <th>Block</th>
            <th>Type</th>
            <th>Inspector</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody>
          ${tableRows}
        </tbody>
      </table>
    ` : `
      <div style="text-align: center; padding: 40px; color: #999;">
        No inspections found matching the selected filters
      </div>
    `}
  </div>
</body>
</html>
    `;
  }

  // Helper function to generate Blocks Report HTML
  function generateBlocksReportHTML(
    blocks: any[],
    properties: any[],
    tenantAssignments: any[],
    branding?: ReportBrandingInfo
  ): string {
    const escapeHtml = (str: string) => {
      if (!str) return '';
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    };

    // Branding for cover page
    const companyName = branding?.brandingName || "Inspect360";
    const hasLogo = !!branding?.logoUrl;
    const logoHtml = hasLogo
      ? `<img src="${sanitizeReportUrl(branding.logoUrl!)}" alt="${escapeHtml(companyName)}" class="cover-logo-img" />`
      : `<div class="cover-logo-text">${escapeHtml(companyName)}</div>`;
    const companyNameHtml = hasLogo
      ? `<div class="cover-company-name">${escapeHtml(companyName)}</div>`
      : '';
    const contactParts: string[] = [];
    if (branding?.brandingEmail) contactParts.push(escapeHtml(branding.brandingEmail));
    if (branding?.brandingPhone) contactParts.push(escapeHtml(branding.brandingPhone));
    if (branding?.brandingWebsite) contactParts.push(escapeHtml(branding.brandingWebsite));
    const contactInfoHtml = contactParts.length > 0
      ? `<div class="cover-contact">${contactParts.join(' &nbsp;|&nbsp; ')}</div>`
      : '';

    // Calculate block statistics
    const blocksWithStats = blocks.map(block => {
      const blockProperties = properties.filter(p => p.blockId === block.id);
      const totalUnits = blockProperties.length;

      const occupiedUnits = blockProperties.filter(property => {
        return tenantAssignments.some(
          assignment =>
            assignment.propertyId === property.id &&
            (assignment.status === "active" || assignment.status === "current" || assignment.status === "notice_served")
        );
      }).length;

      const occupancyRate = totalUnits > 0
        ? Math.round((occupiedUnits / totalUnits) * 100)
        : 0;

      return {
        ...block,
        totalUnits,
        occupiedUnits,
        vacantUnits: totalUnits - occupiedUnits,
        occupancyRate,
      };
    });

    const totalProperties = properties.length;
    const avgOccupancyRate = blocksWithStats.length > 0
      ? Math.round(
        blocksWithStats.reduce((sum, block) => sum + block.occupancyRate, 0) /
        blocksWithStats.length
      )
      : 0;
    const totalActiveTenants = tenantAssignments.filter(a =>
      a.status === "active" || a.status === "current" || a.status === "notice_served"
    ).length;

    const getOccupancyColor = (rate: number) => {
      if (rate >= 90) return { bg: "#dcfce7", color: "#166534" };
      if (rate >= 70) return { bg: "#fef3c7", color: "#92400e" };
      return { bg: "#fee2e2", color: "#991b1b" };
    };

    const tableRows = blocksWithStats.map((block) => {
      const colors = getOccupancyColor(block.occupancyRate);
      return `
        <tr style="border-bottom: 1px solid #e5e7eb;">
          <td style="padding: 10px 12px; font-weight: 500;">${escapeHtml(block.name)}</td>
          <td style="padding: 10px 12px;">
            <div>${escapeHtml(block.address || "N/A")}</div>
            ${block.postcode ? `<div style="color: #666; font-size: 12px;">${escapeHtml(block.postcode)}</div>` : ""}
          </td>
          <td style="padding: 10px 12px; text-align: center;">${block.totalUnits}</td>
          <td style="padding: 10px 12px; text-align: center;">${block.occupiedUnits}</td>
          <td style="padding: 10px 12px; text-align: center;">${block.vacantUnits}</td>
          <td style="padding: 10px 12px; text-align: center;">
            <span style="background: ${colors.bg}; color: ${colors.color}; padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: 600;">
              ${block.occupancyRate}%
            </span>
          </td>
        </tr>
      `;
    }).join("");

    return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.5;
      color: #333;
      background: white;
    }
    /* Cover Page - Landscape optimized */
    .cover-page {
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      background: linear-gradient(135deg, #00D5CC 0%, #3B7A8C 100%);
      color: white;
      page-break-after: always;
      position: relative;
      overflow: hidden;
    }
    .cover-page::before {
      content: '';
      position: absolute;
      top: -50%;
      right: -20%;
      width: 60%;
      height: 200%;
      background: rgba(255, 255, 255, 0.03);
      transform: rotate(15deg);
    }
    .cover-content {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .cover-logo-container { margin-bottom: 32px; }
    .cover-logo-img {
      max-height: 100px;
      max-width: 280px;
      width: auto;
      height: auto;
      object-fit: contain;
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.15));
    }
    .cover-logo-text {
      font-size: 56px;
      font-weight: 800;
      letter-spacing: -2px;
      text-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    .cover-company-name {
      font-size: 24px;
      font-weight: 600;
      margin-top: 12px;
      opacity: 0.95;
    }
    .cover-divider {
      width: 100px;
      height: 3px;
      background: rgba(255, 255, 255, 0.5);
      margin: 28px 0;
      border-radius: 2px;
    }
    .cover-title { font-size: 38px; font-weight: 700; margin-bottom: 12px; }
    .cover-date { font-size: 16px; opacity: 0.9; margin-top: 16px; }
    .cover-contact {
      position: absolute;
      bottom: 32px;
      font-size: 13px;
      opacity: 0.8;
      z-index: 1;
    }
    /* Content area - Landscape optimized */
    .content { padding: 28px 36px; }
    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 3px solid #3B7A8C;
      padding-bottom: 16px;
      margin-bottom: 24px;
    }
    .page-title { font-size: 26px; font-weight: 800; color: #3B7A8C; }
    .page-date { font-size: 13px; color: #666; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 13px; }
    th { background: #f9fafb; padding: 10px 12px; text-align: left; font-weight: 600; color: #374151; border-bottom: 2px solid #e5e7eb; }
    .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin: 24px 0; }
    .stat-card { background: #f9fafb; padding: 16px; border-radius: 8px; border-left: 4px solid #3B7A8C; }
    .stat-label { font-size: 11px; color: #666; text-transform: uppercase; margin-bottom: 6px; font-weight: 600; }
    .stat-value { font-size: 28px; font-weight: 700; color: #3B7A8C; }
    .section-title { font-size: 20px; font-weight: 700; color: #1a1a1a; margin-top: 32px; margin-bottom: 14px; }
  </style>
</head>
<body>
  <div class="cover-page">
    <div class="cover-content">
      <div class="cover-logo-container">
        ${logoHtml}
        ${companyNameHtml}
      </div>
      <div class="cover-divider"></div>
      <div class="cover-title">Blocks Report</div>
      <div class="cover-date">Generated on ${format(new Date(), "MMMM d, yyyy 'at' h:mm a")}</div>
    </div>
    ${contactInfoHtml}
  </div>

  <div class="content">
    <div class="page-header">
      <div class="page-title">Blocks Overview</div>
      <div class="page-date">${format(new Date(), "MMMM d, yyyy")}</div>
    </div>

    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">Total Blocks</div>
        <div class="stat-value">${blocksWithStats.length}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Total Properties</div>
        <div class="stat-value">${totalProperties}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Avg Occupancy</div>
        <div class="stat-value">${avgOccupancyRate}%</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Active Tenants</div>
        <div class="stat-value">${totalActiveTenants}</div>
      </div>
    </div>

    <h2 class="section-title">Block Details</h2>
    
    ${blocksWithStats.length > 0 ? `
      <table>
        <thead>
          <tr>
            <th>Block Name</th>
            <th>Address</th>
            <th style="text-align: center;">Total Units</th>
            <th style="text-align: center;">Occupied</th>
            <th style="text-align: center;">Vacant</th>
            <th style="text-align: center;">Occupancy Rate</th>
          </tr>
        </thead>
        <tbody>
          ${tableRows}
        </tbody>
      </table>
    ` : `
      <div style="text-align: center; padding: 40px; color: #999;">
        No blocks found
      </div>
    `}
  </div>
</body>
</html>
    `;
  }

  // Generate Blocks Report PDF
  app.post("/api/reports/blocks/pdf", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user || !user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const blocks = await storage.getBlocksByOrganization(user.organizationId);
      const properties = await storage.getPropertiesByOrganization(user.organizationId);
      const tenantAssignments = await storage.getTenantAssignmentsByOrganization(user.organizationId);

      // Fetch organization branding and trademarks
      const organization = await storage.getOrganization(user.organizationId);
      const organizationTrademarks = await storage.getOrganizationTrademarks(user.organizationId);
      const trademarksArray = organizationTrademarks.map(tm => ({
        imageUrl: tm.imageUrl,
        altText: tm.altText,
      }));

      const branding: ReportBrandingInfo = organization ? {
        logoUrl: organization.logoUrl,
        brandingName: organization.brandingName,
        brandingEmail: organization.brandingEmail,
        brandingPhone: organization.brandingPhone,
        brandingWebsite: organization.brandingWebsite,
        trademarks: trademarksArray,
      } : {};

      const html = generateBlocksReportHTML(blocks, properties, tenantAssignments, branding);

      let browser;
      try {
        browser = await launchPuppeteerBrowser();

        const page = await browser.newPage();
        await page.setContent(html, {
          waitUntil: "networkidle0",
        });

        const pdf = await page.pdf({
          format: "A4",
          landscape: true,
          printBackground: true,
          margin: {
            top: "15mm",
            right: "12mm",
            bottom: "15mm",
            left: "12mm",
          },
        });

        res.contentType("application/pdf");
        res.send(Buffer.from(pdf));
      } finally {
        if (browser) {
          await browser.close();
        }
      }
    } catch (error) {
      console.error("Error generating blocks report PDF:", error);
      res.status(500).json({ message: "Failed to generate report" });
    }
  });

  // Generate Inspections Report PDF
  app.post("/api/reports/inspections/pdf", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user || !user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { status, type, propertyId, blockId, dateFrom, dateTo } = req.body;

      // Get all inspections for the organization
      let inspections = await storage.getInspectionsByOrganization(user.organizationId);

      // Apply filters
      if (status && status !== "all") {
        inspections = inspections.filter(i => i.status === status);
      }

      if (type && type !== "all") {
        inspections = inspections.filter(i => i.type === type);
      }

      if (propertyId && propertyId !== "all") {
        inspections = inspections.filter(i => i.propertyId === propertyId);
      }

      if (blockId && blockId !== "all") {
        const properties = await storage.getPropertiesByOrganization(user.organizationId);
        const blockProperties = properties.filter(p => p.blockId === blockId);
        const blockPropertyIds = blockProperties.map(p => p.id);
        inspections = inspections.filter(i => blockPropertyIds.includes(i.propertyId));
      }

      if (dateFrom) {
        inspections = inspections.filter(i => {
          const inspectionDate = new Date(i.scheduledDate || i.createdAt);
          return inspectionDate >= new Date(dateFrom);
        });
      }

      if (dateTo) {
        inspections = inspections.filter(i => {
          const inspectionDate = new Date(i.scheduledDate || i.createdAt);
          return inspectionDate <= new Date(dateTo);
        });
      }

      // Sort by date
      inspections.sort((a, b) => {
        const dateA = new Date(a.scheduledDate || a.createdAt);
        const dateB = new Date(b.scheduledDate || b.createdAt);
        return dateB.getTime() - dateA.getTime();
      });

      // Get related data for the PDF
      const properties = await storage.getPropertiesByOrganization(user.organizationId);
      const blocks = await storage.getBlocksByOrganization(user.organizationId);
      const users = await storage.getUsersByOrganization(user.organizationId);

      // Fetch organization branding
      const organization = await storage.getOrganization(user.organizationId);
      const branding: ReportBrandingInfo = organization ? {
        logoUrl: organization.logoUrl,
        brandingName: organization.brandingName,
        brandingEmail: organization.brandingEmail,
        brandingPhone: organization.brandingPhone,
        brandingWebsite: organization.brandingWebsite,
      } : {};

      // Generate HTML for PDF
      const html = generateInspectionsReportHTML(inspections, properties, blocks, users, req.body, branding);

      // Generate PDF using Puppeteer
      let browser;
      try {
        browser = await launchPuppeteerBrowser();

        const page = await browser.newPage();
        await page.setContent(html, {
          waitUntil: "networkidle0",
        });

        const pdf = await page.pdf({
          format: "A4",
          landscape: true,
          printBackground: true,
          margin: {
            top: "15mm",
            right: "12mm",
            bottom: "15mm",
            left: "12mm",
          },
        });

        res.contentType("application/pdf");
        res.send(Buffer.from(pdf));
      } finally {
        if (browser) {
          await browser.close();
        }
      }
    } catch (error) {
      console.error("Error generating inspections report PDF:", error);
      res.status(500).json({ message: "Failed to generate report" });
    }
  });

  // HTML generation function for Properties Report
  function generatePropertiesReportHTML(properties: any[], blocks: any[], inspections: any[], tenantAssignments: any[], maintenanceRequests: any[], branding?: ReportBrandingInfo) {
    const escapeHtml = (str: string) => {
      if (!str) return '';
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    };

    // Branding for cover page
    const companyName = branding?.brandingName || "Inspect360";
    const hasLogo = !!branding?.logoUrl;
    const logoHtml = hasLogo
      ? `<img src="${sanitizeReportUrl(branding.logoUrl!)}" alt="${escapeHtml(companyName)}" class="cover-logo-img" />`
      : `<div class="cover-logo-text">${escapeHtml(companyName)}</div>`;
    const companyNameHtml = hasLogo
      ? `<div class="cover-company-name">${escapeHtml(companyName)}</div>`
      : '';
    const contactParts: string[] = [];
    if (branding?.brandingEmail) contactParts.push(escapeHtml(branding.brandingEmail));
    if (branding?.brandingPhone) contactParts.push(escapeHtml(branding.brandingPhone));
    if (branding?.brandingWebsite) contactParts.push(escapeHtml(branding.brandingWebsite));
    const contactInfoHtml = contactParts.length > 0
      ? `<div class="cover-contact">${contactParts.join(' &nbsp;|&nbsp; ')}</div>`
      : '';

    const propertiesWithStats = properties.map(property => {
      const propertyInspections = inspections.filter(i => i.propertyId === property.id);
      const latestInspection = propertyInspections.sort((a, b) =>
        new Date(b.scheduledDate || b.createdAt).getTime() -
        new Date(a.scheduledDate || a.createdAt).getTime()
      )[0];

      const tenantAssignment = tenantAssignments.find(
        t => t.propertyId === property.id && t.status === "active"
      );

      const propertyMaintenance = maintenanceRequests.filter(
        m => m.propertyId === property.id
      );
      const openMaintenance = propertyMaintenance.filter(
        m => m.status === "open" || m.status === "in_progress"
      ).length;

      const block = blocks.find(b => b.id === property.blockId);

      return {
        ...property,
        block,
        totalInspections: propertyInspections.length,
        lastInspection: latestInspection,
        isOccupied: !!tenantAssignment,
        tenant: tenantAssignment,
        openMaintenanceCount: openMaintenance,
        totalMaintenanceCount: propertyMaintenance.length,
      };
    });

    const totalProperties = propertiesWithStats.length;
    const occupiedProperties = propertiesWithStats.filter(p => p.isOccupied).length;
    const vacantProperties = propertiesWithStats.filter(p => !p.isOccupied).length;
    const totalOpenMaintenance = propertiesWithStats.reduce((sum, p) => sum + p.openMaintenanceCount, 0);

    const tableRows = propertiesWithStats.map(property => `
      <tr>
        <td style="padding: 10px 12px;">${escapeHtml(property.block?.name || "N/A")}</td>
        <td style="padding: 10px 12px;">${escapeHtml(property.name || "N/A")}</td>
        <td style="padding: 10px 12px;">${escapeHtml(property.address || "")}</td>
        <td style="padding: 10px 12px; text-align: center;">
          <span style="padding: 3px 10px; border-radius: 4px; background: ${property.isOccupied ? '#00D5CC' : '#e5e7eb'}; color: ${property.isOccupied ? 'white' : '#374151'}; font-size: 11px;">
            ${property.isOccupied ? 'Occupied' : 'Vacant'}
          </span>
        </td>
        <td style="padding: 10px 12px;">${property.tenant ? escapeHtml(`${property.tenant.tenantFirstName} ${property.tenant.tenantLastName}`) : '-'}</td>
        <td style="padding: 10px 12px; text-align: center;">${property.totalInspections}</td>
        <td style="padding: 10px 12px; text-align: center;">${property.openMaintenanceCount}</td>
        <td style="padding: 10px 12px;">${property.lastInspection ? new Date(property.lastInspection.scheduledDate || property.lastInspection.createdAt).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' }) : 'Never'}</td>
      </tr>
    `).join('');

    return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.5;
      color: #333;
      background: white;
    }
    /* Cover Page - Landscape optimized */
    .cover-page {
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      background: linear-gradient(135deg, #00D5CC 0%, #3B7A8C 100%);
      color: white;
      page-break-after: always;
      position: relative;
      overflow: hidden;
    }
    .cover-page::before {
      content: '';
      position: absolute;
      top: -50%;
      right: -20%;
      width: 60%;
      height: 200%;
      background: rgba(255, 255, 255, 0.03);
      transform: rotate(15deg);
    }
    .cover-content {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .cover-logo-container { margin-bottom: 32px; }
    .cover-logo-img {
      max-height: 100px;
      max-width: 280px;
      width: auto;
      height: auto;
      object-fit: contain;
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.15));
    }
    .cover-logo-text {
      font-size: 56px;
      font-weight: 800;
      letter-spacing: -2px;
      text-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    .cover-company-name {
      font-size: 24px;
      font-weight: 600;
      margin-top: 12px;
      opacity: 0.95;
    }
    .cover-divider {
      width: 100px;
      height: 3px;
      background: rgba(255, 255, 255, 0.5);
      margin: 28px 0;
      border-radius: 2px;
    }
    .cover-title { font-size: 38px; font-weight: 700; margin-bottom: 12px; }
    .cover-date { font-size: 16px; opacity: 0.9; margin-top: 16px; }
    .cover-contact {
      position: absolute;
      bottom: 32px;
      font-size: 13px;
      opacity: 0.8;
      z-index: 1;
    }
    /* Content area - Landscape optimized */
    .content { padding: 28px 36px; }
    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 3px solid #00D5CC;
      padding-bottom: 16px;
      margin-bottom: 24px;
    }
    .page-title { font-size: 26px; font-weight: 800; color: #00D5CC; }
    .page-date { font-size: 13px; color: #666; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 12px; }
    th { background: #f9fafb; padding: 10px 12px; text-align: left; font-weight: 600; color: #374151; border-bottom: 2px solid #e5e7eb; }
    td { border-bottom: 1px solid #e5e7eb; }
    .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin: 24px 0; }
    .stat-card { background: #f9fafb; padding: 16px; border-radius: 8px; border-left: 4px solid #00D5CC; }
    .stat-label { font-size: 11px; color: #666; text-transform: uppercase; margin-bottom: 6px; font-weight: 600; }
    .stat-value { font-size: 28px; font-weight: 700; color: #00D5CC; }
    .section-title { font-size: 20px; font-weight: 700; color: #1a1a1a; margin-top: 32px; margin-bottom: 14px; }
    .footer { margin-top: 24px; padding-top: 12px; border-top: 1px solid #e5e7eb; font-size: 11px; color: #6b7280; text-align: center; }
  </style>
</head>
<body>
  <div class="cover-page">
    <div class="cover-content">
      <div class="cover-logo-container">
        ${logoHtml}
        ${companyNameHtml}
      </div>
      <div class="cover-divider"></div>
      <div class="cover-title">Properties Report</div>
      <div class="cover-date">Generated on ${format(new Date(), "MMMM d, yyyy 'at' h:mm a")}</div>
    </div>
    ${contactInfoHtml}
  </div>

  <div class="content">
    <div class="page-header">
      <div class="page-title">Properties Summary</div>
      <div class="page-date">${format(new Date(), "MMMM d, yyyy")}</div>
    </div>

    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">Total Properties</div>
        <div class="stat-value">${totalProperties}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Occupied</div>
        <div class="stat-value">${occupiedProperties}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Vacant</div>
        <div class="stat-value">${vacantProperties}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Open Maintenance</div>
        <div class="stat-value">${totalOpenMaintenance}</div>
      </div>
    </div>

    <h2 class="section-title">Property Records</h2>
    
    ${properties.length > 0 ? `
      <table>
        <thead>
          <tr>
            <th>Block</th>
            <th>Unit</th>
            <th>Address</th>
            <th style="text-align: center;">Status</th>
            <th>Tenant</th>
            <th style="text-align: center;">Inspections</th>
            <th style="text-align: center;">Open Maint.</th>
            <th>Last Inspection</th>
          </tr>
        </thead>
        <tbody>
          ${tableRows}
        </tbody>
      </table>
    ` : `
      <div style="text-align: center; padding: 40px; color: #999;">
        No properties found
      </div>
    `}

    <div class="footer">
      <p>Report generated by ${escapeHtml(companyName)}</p>
    </div>
  </div>
</body>
</html>
    `;
  }

  // Generate Properties Report PDF
  app.post("/api/reports/properties/pdf", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user || !user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { blockId, status, searchTerm } = req.body;

      let properties = await storage.getPropertiesByOrganization(user.organizationId);
      const blocks = await storage.getBlocksByOrganization(user.organizationId);
      const inspections = await storage.getInspectionsByOrganization(user.organizationId);
      const tenantAssignments = await storage.getTenantAssignmentsByOrganization(user.organizationId);
      const maintenanceRequests = await storage.getMaintenanceByOrganization(user.organizationId);

      // Apply filters
      if (blockId && blockId !== "all") {
        properties = properties.filter(p => p.blockId === blockId);
      }

      if (status && status !== "all") {
        if (status === "occupied") {
          const occupiedPropertyIds = tenantAssignments
            .filter(t => t.status === "active")
            .map(t => t.propertyId);
          properties = properties.filter(p => occupiedPropertyIds.includes(p.id));
        } else if (status === "vacant") {
          const occupiedPropertyIds = tenantAssignments
            .filter(t => t.status === "active")
            .map(t => t.propertyId);
          properties = properties.filter(p => !occupiedPropertyIds.includes(p.id));
        }
      }

      if (searchTerm) {
        const searchLower = searchTerm.toLowerCase();
        properties = properties.filter(p =>
          p.address?.toLowerCase().includes(searchLower) ||
          p.name?.toLowerCase().includes(searchLower)
        );
      }

      // Fetch organization branding
      const organization = await storage.getOrganization(user.organizationId);
      const branding: ReportBrandingInfo = organization ? {
        logoUrl: organization.logoUrl,
        brandingName: organization.brandingName,
        brandingEmail: organization.brandingEmail,
        brandingPhone: organization.brandingPhone,
        brandingWebsite: organization.brandingWebsite,
      } : {};

      const html = generatePropertiesReportHTML(properties, blocks, inspections, tenantAssignments, maintenanceRequests, branding);

      let browser;
      try {
        browser = await launchPuppeteerBrowser();

        const page = await browser.newPage();
        await page.setContent(html, {
          waitUntil: "networkidle0",
        });

        const pdf = await page.pdf({
          format: "A4",
          landscape: true,
          printBackground: true,
          margin: {
            top: "15mm",
            right: "12mm",
            bottom: "15mm",
            left: "12mm",
          },
        });

        res.contentType("application/pdf");
        res.send(Buffer.from(pdf));
      } finally {
        if (browser) {
          await browser.close();
        }
      }
    } catch (error) {
      console.error("Error generating properties report PDF:", error);
      res.status(500).json({ message: "Failed to generate report" });
    }
  });

  // HTML generation function for Tenants Report
  function generateTenantsReportHTML(tenantAssignments: any[], properties: any[], blocks: any[], branding?: ReportBrandingInfo) {
    const escapeHtml = (str: string) => {
      if (!str) return '';
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    };

    // Branding for cover page
    const companyName = branding?.brandingName || "Inspect360";
    const hasLogo = !!branding?.logoUrl;
    const logoHtml = hasLogo
      ? `<img src="${sanitizeReportUrl(branding.logoUrl!)}" alt="${escapeHtml(companyName)}" class="cover-logo-img" />`
      : `<div class="cover-logo-text">${escapeHtml(companyName)}</div>`;
    const companyNameHtml = hasLogo
      ? `<div class="cover-company-name">${escapeHtml(companyName)}</div>`
      : '';
    const contactParts: string[] = [];
    if (branding?.brandingEmail) contactParts.push(escapeHtml(branding.brandingEmail));
    if (branding?.brandingPhone) contactParts.push(escapeHtml(branding.brandingPhone));
    if (branding?.brandingWebsite) contactParts.push(escapeHtml(branding.brandingWebsite));
    const contactInfoHtml = contactParts.length > 0
      ? `<div class="cover-contact">${contactParts.join(' &nbsp;|&nbsp; ')}</div>`
      : '';

    const enrichedTenants = tenantAssignments.map(tenant => {
      const property = properties.find(p => p.id === tenant.propertyId);
      const block = property ? blocks.find(b => b.id === property.blockId) : null;

      const leaseEndDate = tenant.leaseEndDate ? new Date(tenant.leaseEndDate) : null;
      const daysUntilExpiry = leaseEndDate ? Math.floor((leaseEndDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)) : null;

      return {
        ...tenant,
        property,
        block,
        daysUntilExpiry,
        monthlyRent: tenant.monthlyRent ? parseFloat(tenant.monthlyRent) : 0,
      };
    });

    const totalTenants = enrichedTenants.length;
    const activeTenants = enrichedTenants.filter(t => t.status === "active").length;
    const expiringSoon = enrichedTenants.filter(t => t.daysUntilExpiry !== null && t.daysUntilExpiry >= 0 && t.daysUntilExpiry <= 60).length;
    const totalMonthlyRent = enrichedTenants
      .filter(t => t.status === "active")
      .reduce((sum, t) => sum + t.monthlyRent, 0);

    const tableRows = enrichedTenants.map(tenant => `
      <tr>
        <td style="padding: 10px 12px;">${escapeHtml(`${tenant.tenantFirstName} ${tenant.tenantLastName}`)}</td>
        <td style="padding: 10px 12px;">${escapeHtml(tenant.tenantEmail || 'N/A')}</td>
        <td style="padding: 10px 12px;">${escapeHtml(tenant.block?.name || 'N/A')}</td>
        <td style="padding: 10px 12px;">${escapeHtml(tenant.property?.unitNumber || 'N/A')}</td>
        <td style="padding: 10px 12px;">${tenant.leaseStartDate ? new Date(tenant.leaseStartDate).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' }) : '-'}</td>
        <td style="padding: 10px 12px;">${tenant.leaseEndDate ? new Date(tenant.leaseEndDate).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' }) : '-'}${tenant.daysUntilExpiry !== null && tenant.daysUntilExpiry >= 0 ? ` (${tenant.daysUntilExpiry} days)` : ''}</td>
        <td style="padding: 10px 12px; text-align: right;">${tenant.monthlyRent > 0 ? 'Â£' + tenant.monthlyRent.toLocaleString() : '-'}</td>
        <td style="padding: 10px 12px; text-align: center;">
          <span style="padding: 3px 10px; border-radius: 4px; background: ${tenant.status === 'active' ? '#00D5CC' : '#e5e7eb'}; color: ${tenant.status === 'active' ? 'white' : '#374151'}; font-size: 11px;">
            ${tenant.status === 'active' ? 'Active' : 'Inactive'}
          </span>
        </td>
      </tr>
    `).join('');

    return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.5;
      color: #333;
      background: white;
    }
    /* Cover Page - Landscape optimized */
    .cover-page {
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      background: linear-gradient(135deg, #00D5CC 0%, #3B7A8C 100%);
      color: white;
      page-break-after: always;
      position: relative;
      overflow: hidden;
    }
    .cover-page::before {
      content: '';
      position: absolute;
      top: -50%;
      right: -20%;
      width: 60%;
      height: 200%;
      background: rgba(255, 255, 255, 0.03);
      transform: rotate(15deg);
    }
    .cover-content {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .cover-logo-container { margin-bottom: 32px; }
    .cover-logo-img {
      max-height: 100px;
      max-width: 280px;
      width: auto;
      height: auto;
      object-fit: contain;
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.15));
    }
    .cover-logo-text {
      font-size: 56px;
      font-weight: 800;
      letter-spacing: -2px;
      text-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    .cover-company-name {
      font-size: 24px;
      font-weight: 600;
      margin-top: 12px;
      opacity: 0.95;
    }
    .cover-divider {
      width: 100px;
      height: 3px;
      background: rgba(255, 255, 255, 0.5);
      margin: 28px 0;
      border-radius: 2px;
    }
    .cover-title { font-size: 38px; font-weight: 700; margin-bottom: 12px; }
    .cover-date { font-size: 16px; opacity: 0.9; margin-top: 16px; }
    .cover-contact {
      position: absolute;
      bottom: 32px;
      font-size: 13px;
      opacity: 0.8;
      z-index: 1;
    }
    /* Content area - Landscape optimized */
    .content { padding: 28px 36px; }
    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 3px solid #00D5CC;
      padding-bottom: 16px;
      margin-bottom: 24px;
    }
    .page-title { font-size: 26px; font-weight: 800; color: #00D5CC; }
    .page-date { font-size: 13px; color: #666; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 12px; }
    th { background: #f9fafb; padding: 10px 12px; text-align: left; font-weight: 600; color: #374151; border-bottom: 2px solid #e5e7eb; }
    td { border-bottom: 1px solid #e5e7eb; }
    .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin: 24px 0; }
    .stat-card { background: #f9fafb; padding: 16px; border-radius: 8px; border-left: 4px solid #00D5CC; }
    .stat-label { font-size: 11px; color: #666; text-transform: uppercase; margin-bottom: 6px; font-weight: 600; }
    .stat-value { font-size: 28px; font-weight: 700; color: #00D5CC; }
    .section-title { font-size: 20px; font-weight: 700; color: #1a1a1a; margin-top: 32px; margin-bottom: 14px; }
    .footer { margin-top: 24px; padding-top: 12px; border-top: 1px solid #e5e7eb; font-size: 11px; color: #6b7280; text-align: center; }
  </style>
</head>
<body>
  <div class="cover-page">
    <div class="cover-content">
      <div class="cover-logo-container">
        ${logoHtml}
        ${companyNameHtml}
      </div>
      <div class="cover-divider"></div>
      <div class="cover-title">Tenants Report</div>
      <div class="cover-date">Generated on ${format(new Date(), "MMMM d, yyyy 'at' h:mm a")}</div>
    </div>
    ${contactInfoHtml}
  </div>

  <div class="content">
    <div class="page-header">
      <div class="page-title">Tenants Summary</div>
      <div class="page-date">${format(new Date(), "MMMM d, yyyy")}</div>
    </div>

    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">Total Tenants</div>
        <div class="stat-value">${totalTenants}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Active</div>
        <div class="stat-value">${activeTenants}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Expiring Soon</div>
        <div class="stat-value">${expiringSoon}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Total Monthly Rent</div>
        <div class="stat-value">Â£${totalMonthlyRent.toLocaleString()}</div>
      </div>
    </div>

    <h2 class="section-title">Tenant Records</h2>
    
    ${tenantAssignments.length > 0 ? `
      <table>
        <thead>
          <tr>
            <th>Tenant Name</th>
            <th>Email</th>
            <th>Block</th>
            <th>Property</th>
            <th>Lease Start</th>
            <th>Lease End</th>
            <th style="text-align: right;">Monthly Rent</th>
            <th style="text-align: center;">Status</th>
          </tr>
        </thead>
        <tbody>
          ${tableRows}
        </tbody>
      </table>
    ` : `
      <div style="text-align: center; padding: 40px; color: #999;">
        No tenants found
      </div>
    `}

    <div class="footer">
      <p>Report generated by ${escapeHtml(companyName)}</p>
    </div>
  </div>
</body>
</html>
    `;
  }

  // Generate Tenants Report PDF
  app.post("/api/reports/tenants/pdf", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user || !user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { blockId, propertyId, status, searchTerm } = req.body;

      let tenantAssignments = await storage.getTenantAssignmentsByOrganization(user.organizationId);
      const properties = await storage.getPropertiesByOrganization(user.organizationId);
      const blocks = await storage.getBlocksByOrganization(user.organizationId);

      // Apply filters
      if (blockId && blockId !== "all") {
        tenantAssignments = tenantAssignments.filter(t => {
          const property = properties.find(p => p.id === t.propertyId);
          return property?.blockId === blockId;
        });
      }

      if (propertyId && propertyId !== "all") {
        tenantAssignments = tenantAssignments.filter(t => t.propertyId === propertyId);
      }

      if (status && status !== "all") {
        if (status === "active") {
          tenantAssignments = tenantAssignments.filter(t => t.status === "active");
        } else if (status === "expiring") {
          tenantAssignments = tenantAssignments.filter(t => {
            const leaseEndDate = t.leaseEndDate ? new Date(t.leaseEndDate) : null;
            const daysUntilExpiry = leaseEndDate ? Math.floor((leaseEndDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)) : null;
            return daysUntilExpiry !== null && daysUntilExpiry >= 0 && daysUntilExpiry <= 60;
          });
        } else if (status === "expired") {
          tenantAssignments = tenantAssignments.filter(t => {
            const leaseEndDate = t.leaseEndDate ? new Date(t.leaseEndDate) : null;
            const daysUntilExpiry = leaseEndDate ? Math.floor((leaseEndDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)) : null;
            return daysUntilExpiry !== null && daysUntilExpiry < 0;
          });
        }
      }

      if (searchTerm) {
        const searchLower = searchTerm.toLowerCase();
        tenantAssignments = tenantAssignments.filter(t =>
          t.tenantFirstName?.toLowerCase().includes(searchLower) ||
          t.tenantLastName?.toLowerCase().includes(searchLower) ||
          t.tenantEmail?.toLowerCase().includes(searchLower)
        );
      }

      // Fetch organization branding
      const organization = await storage.getOrganization(user.organizationId);
      const branding: ReportBrandingInfo = organization ? {
        logoUrl: organization.logoUrl,
        brandingName: organization.brandingName,
        brandingEmail: organization.brandingEmail,
        brandingPhone: organization.brandingPhone,
        brandingWebsite: organization.brandingWebsite,
      } : {};

      const html = generateTenantsReportHTML(tenantAssignments, properties, blocks, branding);

      let browser;
      try {
        browser = await launchPuppeteerBrowser();

        const page = await browser.newPage();
        await page.setContent(html, {
          waitUntil: "networkidle0",
        });

        const pdf = await page.pdf({
          format: "A4",
          landscape: true,
          printBackground: true,
          margin: {
            top: "15mm",
            right: "12mm",
            bottom: "15mm",
            left: "12mm",
          },
        });

        res.contentType("application/pdf");
        res.send(Buffer.from(pdf));
      } finally {
        if (browser) {
          await browser.close();
        }
      }
    } catch (error) {
      console.error("Error generating tenants report PDF:", error);
      res.status(500).json({ message: "Failed to generate report" });
    }
  });

  // HTML generation function for Inventory Report
  function generateInventoryReportHTML(assetInventory: any[], properties: any[], blocks: any[], branding?: ReportBrandingInfo) {
    const escapeHtml = (str: string) => {
      if (!str) return '';
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    };

    // Branding for cover page
    const companyName = branding?.brandingName || "Inspect360";
    const hasLogo = !!branding?.logoUrl;
    const logoHtml = hasLogo
      ? `<img src="${sanitizeReportUrl(branding.logoUrl!)}" alt="${escapeHtml(companyName)}" class="cover-logo-img" />`
      : `<div class="cover-logo-text">${escapeHtml(companyName)}</div>`;
    const companyNameHtml = hasLogo
      ? `<div class="cover-company-name">${escapeHtml(companyName)}</div>`
      : '';
    const contactParts: string[] = [];
    if (branding?.brandingEmail) contactParts.push(escapeHtml(branding.brandingEmail));
    if (branding?.brandingPhone) contactParts.push(escapeHtml(branding.brandingPhone));
    if (branding?.brandingWebsite) contactParts.push(escapeHtml(branding.brandingWebsite));
    const contactInfoHtml = contactParts.length > 0
      ? `<div class="cover-contact">${contactParts.join(' &nbsp;|&nbsp; ')}</div>`
      : '';

    const enrichedInventory = assetInventory.map(asset => {
      const property = properties.find(p => p.id === asset.propertyId);
      const block = property ? blocks.find(b => b.id === property.blockId) :
        blocks.find(b => b.id === asset.blockId);

      return {
        ...asset,
        property,
        block,
      };
    });

    const totalAssets = enrichedInventory.length;
    const blockAssets = enrichedInventory.filter(i => i.blockId && !i.propertyId).length;
    const propertyAssets = enrichedInventory.filter(i => i.propertyId).length;
    const damagedAssets = enrichedInventory.filter(i =>
      i.condition === "poor" || i.condition === "damaged"
    ).length;

    const tableRows = enrichedInventory.map(asset => `
      <tr>
        <td style="padding: 10px 12px;">${escapeHtml(asset.name || '')}</td>
        <td style="padding: 10px 12px;">
          <span style="padding: 3px 10px; border-radius: 4px; background: #f3f4f6; color: #374151; font-size: 11px;">
            ${escapeHtml(asset.category || 'Uncategorized')}
          </span>
        </td>
        <td style="padding: 10px 12px;">${escapeHtml(asset.location || 'N/A')}</td>
        <td style="padding: 10px 12px;">${asset.block ? escapeHtml(asset.block.name) : '-'}</td>
        <td style="padding: 10px 12px;">${asset.property ? escapeHtml(asset.property.name) : '-'}</td>
        <td style="padding: 10px 12px; text-align: center;">
          <span style="padding: 3px 10px; border-radius: 4px; background: ${asset.condition === 'excellent' || asset.condition === 'good' ? '#00D5CC' :
        asset.condition === 'fair' ? '#e5e7eb' : '#ef4444'
      }; color: ${asset.condition === 'excellent' || asset.condition === 'good' ? 'white' :
        asset.condition === 'fair' ? '#374151' : 'white'
      }; font-size: 11px;">
            ${escapeHtml(asset.condition || 'Unknown')}
          </span>
        </td>
        <td style="padding: 10px 12px; font-family: monospace; font-size: 11px;">${escapeHtml(asset.serialNumber || '-')}</td>
        <td style="padding: 10px 12px;">${asset.createdAt ? new Date(asset.createdAt).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' }) : '-'}</td>
      </tr>
    `).join('');

    return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.5;
      color: #333;
      background: white;
    }
    /* Cover Page - Landscape optimized */
    .cover-page {
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      background: linear-gradient(135deg, #00D5CC 0%, #3B7A8C 100%);
      color: white;
      page-break-after: always;
      position: relative;
      overflow: hidden;
    }
    .cover-page::before {
      content: '';
      position: absolute;
      top: -50%;
      right: -20%;
      width: 60%;
      height: 200%;
      background: rgba(255, 255, 255, 0.03);
      transform: rotate(15deg);
    }
    .cover-content {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .cover-logo-container { margin-bottom: 32px; }
    .cover-logo-img {
      max-height: 100px;
      max-width: 280px;
      width: auto;
      height: auto;
      object-fit: contain;
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.15));
    }
    .cover-logo-text {
      font-size: 56px;
      font-weight: 800;
      letter-spacing: -2px;
      text-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    .cover-company-name {
      font-size: 24px;
      font-weight: 600;
      margin-top: 12px;
      opacity: 0.95;
    }
    .cover-divider {
      width: 100px;
      height: 3px;
      background: rgba(255, 255, 255, 0.5);
      margin: 28px 0;
      border-radius: 2px;
    }
    .cover-title { font-size: 38px; font-weight: 700; margin-bottom: 12px; }
    .cover-date { font-size: 16px; opacity: 0.9; margin-top: 16px; }
    .cover-contact {
      position: absolute;
      bottom: 32px;
      font-size: 13px;
      opacity: 0.8;
      z-index: 1;
    }
    /* Content area - Landscape optimized */
    .content { padding: 28px 36px; }
    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 3px solid #00D5CC;
      padding-bottom: 16px;
      margin-bottom: 24px;
    }
    .page-title { font-size: 26px; font-weight: 800; color: #00D5CC; }
    .page-date { font-size: 13px; color: #666; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 12px; }
    th { background: #f9fafb; padding: 10px 12px; text-align: left; font-weight: 600; color: #374151; border-bottom: 2px solid #e5e7eb; }
    td { border-bottom: 1px solid #e5e7eb; }
    .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin: 24px 0; }
    .stat-card { background: #f9fafb; padding: 16px; border-radius: 8px; border-left: 4px solid #00D5CC; }
    .stat-label { font-size: 11px; color: #666; text-transform: uppercase; margin-bottom: 6px; font-weight: 600; }
    .stat-value { font-size: 28px; font-weight: 700; color: #00D5CC; }
    .section-title { font-size: 20px; font-weight: 700; color: #1a1a1a; margin-top: 32px; margin-bottom: 14px; }
    .footer { margin-top: 24px; padding-top: 12px; border-top: 1px solid #e5e7eb; font-size: 11px; color: #6b7280; text-align: center; }
  </style>
</head>
<body>
  <div class="cover-page">
    <div class="cover-content">
      <div class="cover-logo-container">
        ${logoHtml}
        ${companyNameHtml}
      </div>
      <div class="cover-divider"></div>
      <div class="cover-title">Inventory Report</div>
      <div class="cover-date">Generated on ${format(new Date(), "MMMM d, yyyy 'at' h:mm a")}</div>
    </div>
    ${contactInfoHtml}
  </div>

  <div class="content">
    <div class="page-header">
      <div class="page-title">Inventory Summary</div>
      <div class="page-date">${format(new Date(), "MMMM d, yyyy")}</div>
    </div>

    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">Total Assets</div>
        <div class="stat-value">${totalAssets}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Block Assets</div>
        <div class="stat-value">${blockAssets}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Property Assets</div>
        <div class="stat-value">${propertyAssets}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Needs Attention</div>
        <div class="stat-value">${damagedAssets}</div>
      </div>
    </div>

    <h2 class="section-title">Asset Records</h2>
    
    ${assetInventory.length > 0 ? `
      <table>
        <thead>
          <tr>
            <th>Asset Name</th>
            <th>Category</th>
            <th>Location</th>
            <th>Block</th>
            <th>Property</th>
            <th style="text-align: center;">Condition</th>
            <th>Serial Number</th>
            <th>Added</th>
          </tr>
        </thead>
        <tbody>
          ${tableRows}
        </tbody>
      </table>
    ` : `
      <div style="text-align: center; padding: 40px; color: #999;">
        No inventory items found
      </div>
    `}

    <div class="footer">
      <p>Report generated by ${escapeHtml(companyName)}</p>
    </div>
  </div>
</body>
</html>
    `;
  }

  // Generate Inventory Report PDF
  app.post("/api/reports/inventory/pdf", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user || !user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { blockId, propertyId, category, condition, searchTerm } = req.body;

      let assetInventory = await storage.getAssetInventoryByOrganization(user.organizationId);
      const properties = await storage.getPropertiesByOrganization(user.organizationId);
      const blocks = await storage.getBlocksByOrganization(user.organizationId);

      // Apply filters
      if (blockId && blockId !== "all") {
        assetInventory = assetInventory.filter(i =>
          i.blockId === blockId || properties.find(p => p.id === i.propertyId)?.blockId === blockId
        );
      }

      if (propertyId && propertyId !== "all") {
        assetInventory = assetInventory.filter(i => i.propertyId === propertyId);
      }

      if (category && category !== "all") {
        assetInventory = assetInventory.filter(i => i.category === category);
      }

      if (condition && condition !== "all") {
        assetInventory = assetInventory.filter(i => i.condition === condition);
      }

      if (searchTerm) {
        const searchLower = searchTerm.toLowerCase();
        assetInventory = assetInventory.filter(i =>
          i.name?.toLowerCase().includes(searchLower) ||
          i.description?.toLowerCase().includes(searchLower) ||
          i.serialNumber?.toLowerCase().includes(searchLower) ||
          i.location?.toLowerCase().includes(searchLower)
        );
      }

      // Fetch organization branding
      const organization = await storage.getOrganization(user.organizationId);
      const branding: ReportBrandingInfo = organization ? {
        logoUrl: organization.logoUrl,
        brandingName: organization.brandingName,
        brandingEmail: organization.brandingEmail,
        brandingPhone: organization.brandingPhone,
        brandingWebsite: organization.brandingWebsite,
      } : {};

      const html = generateInventoryReportHTML(assetInventory, properties, blocks, branding);

      let browser;
      try {
        browser = await launchPuppeteerBrowser();

        const page = await browser.newPage();
        await page.setContent(html, {
          waitUntil: "networkidle0",
        });

        const pdf = await page.pdf({
          format: "A4",
          landscape: true,
          printBackground: true,
          margin: {
            top: "15mm",
            right: "12mm",
            bottom: "15mm",
            left: "12mm",
          },
        });

        res.contentType("application/pdf");
        res.send(Buffer.from(pdf));
      } finally {
        if (browser) {
          await browser.close();
        }
      }
    } catch (error) {
      console.error("Error generating inventory report PDF:", error);
      res.status(500).json({ message: "Failed to generate report" });
    }
  });

  // HTML generation function for Compliance Report
  function generateComplianceReportHTML(complianceDocuments: any[], properties: any[], blocks: any[], branding?: ReportBrandingInfo) {
    const escapeHtml = (str: string) => {
      if (!str) return '';
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    };

    // Branding for cover page
    const companyName = branding?.brandingName || "Inspect360";
    const hasLogo = !!branding?.logoUrl;
    const logoHtml = hasLogo
      ? `<img src="${sanitizeReportUrl(branding.logoUrl!)}" alt="${escapeHtml(companyName)}" class="cover-logo-img" />`
      : `<div class="cover-logo-text">${escapeHtml(companyName)}</div>`;
    const companyNameHtml = hasLogo
      ? `<div class="cover-company-name">${escapeHtml(companyName)}</div>`
      : '';
    const contactParts: string[] = [];
    if (branding?.brandingEmail) contactParts.push(escapeHtml(branding.brandingEmail));
    if (branding?.brandingPhone) contactParts.push(escapeHtml(branding.brandingPhone));
    if (branding?.brandingWebsite) contactParts.push(escapeHtml(branding.brandingWebsite));
    const contactInfoHtml = contactParts.length > 0
      ? `<div class="cover-contact">${contactParts.join(' &nbsp;|&nbsp; ')}</div>`
      : '';

    const enrichedDocuments = complianceDocuments.map(doc => {
      const property = properties.find(p => p.id === doc.propertyId);
      const block = property ? blocks.find(b => b.id === property.blockId) :
        blocks.find(b => b.id === doc.blockId);

      let status = "current";
      let daysUntilExpiry = null;

      if (doc.expiryDate) {
        const expiryDate = new Date(doc.expiryDate);
        daysUntilExpiry = Math.floor((expiryDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24));

        if (daysUntilExpiry < 0) {
          status = "expired";
        } else if (daysUntilExpiry <= 30) {
          status = "expiring-soon";
        } else {
          status = "current";
        }
      }

      return {
        ...doc,
        property,
        block,
        status,
        daysUntilExpiry,
      };
    });

    const totalDocuments = enrichedDocuments.length;
    const currentDocuments = enrichedDocuments.filter(d => d.status === "current").length;
    const expiringSoon = enrichedDocuments.filter(d => d.status === "expiring-soon").length;
    const expired = enrichedDocuments.filter(d => d.status === "expired").length;

    const tableRows = enrichedDocuments.map(doc => `
      <tr>
        <td style="padding: 10px 12px;">${escapeHtml(doc.documentType)}</td>
        <td style="padding: 10px 12px;">
          <span style="padding: 3px 10px; border-radius: 4px; background: #f3f4f6; color: #374151; font-size: 11px;">
            ${doc.blockId && !doc.propertyId ? 'Block-Level' : 'Property-Level'}
          </span>
        </td>
        <td style="padding: 10px 12px;">${doc.block ? escapeHtml(doc.block.name) : '-'}</td>
        <td style="padding: 10px 12px;">${doc.property ? escapeHtml(doc.property.name) : '-'}</td>
        <td style="padding: 10px 12px;">
          ${doc.expiryDate ? new Date(doc.expiryDate).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' }) : 'No expiry'}
          ${doc.daysUntilExpiry !== null && doc.daysUntilExpiry >= 0 ? `<br><span style="font-size: 10px; color: #6b7280;">${doc.daysUntilExpiry} days left</span>` : ''}
          ${doc.daysUntilExpiry !== null && doc.daysUntilExpiry < 0 ? `<br><span style="font-size: 10px; color: #ef4444;">${Math.abs(doc.daysUntilExpiry)} days overdue</span>` : ''}
        </td>
        <td style="padding: 10px 12px; text-align: center;">
          <span style="padding: 3px 10px; border-radius: 4px; background: ${doc.status === 'expired' ? '#ef4444' :
        doc.status === 'expiring-soon' ? '#f59e0b' : '#00D5CC'
      }; color: white; font-size: 11px;">
            ${doc.status === 'expired' ? 'Expired' : doc.status === 'expiring-soon' ? 'Expiring Soon' : 'Current'}
          </span>
        </td>
        <td style="padding: 10px 12px;">${doc.createdAt ? new Date(doc.createdAt).toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' }) : '-'}</td>
      </tr>
    `).join('');

    return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.5;
      color: #333;
      background: white;
    }
    /* Cover Page - Landscape optimized */
    .cover-page {
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      background: linear-gradient(135deg, #00D5CC 0%, #3B7A8C 100%);
      color: white;
      page-break-after: always;
      position: relative;
      overflow: hidden;
    }
    .cover-page::before {
      content: '';
      position: absolute;
      top: -50%;
      right: -20%;
      width: 60%;
      height: 200%;
      background: rgba(255, 255, 255, 0.03);
      transform: rotate(15deg);
    }
    .cover-content {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .cover-logo-container { margin-bottom: 32px; }
    .cover-logo-img {
      max-height: 100px;
      max-width: 280px;
      width: auto;
      height: auto;
      object-fit: contain;
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.15));
    }
    .cover-logo-text {
      font-size: 56px;
      font-weight: 800;
      letter-spacing: -2px;
      text-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    .cover-company-name {
      font-size: 24px;
      font-weight: 600;
      margin-top: 12px;
      opacity: 0.95;
    }
    .cover-divider {
      width: 100px;
      height: 3px;
      background: rgba(255, 255, 255, 0.5);
      margin: 28px 0;
      border-radius: 2px;
    }
    .cover-title { font-size: 38px; font-weight: 700; margin-bottom: 12px; }
    .cover-date { font-size: 16px; opacity: 0.9; margin-top: 16px; }
    .cover-contact {
      position: absolute;
      bottom: 32px;
      font-size: 13px;
      opacity: 0.8;
      z-index: 1;
    }
    /* Content area - Landscape optimized */
    .content { padding: 28px 36px; }
    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 3px solid #00D5CC;
      padding-bottom: 16px;
      margin-bottom: 24px;
    }
    .page-title { font-size: 26px; font-weight: 800; color: #00D5CC; }
    .page-date { font-size: 13px; color: #666; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 12px; }
    th { background: #f9fafb; padding: 10px 12px; text-align: left; font-weight: 600; color: #374151; border-bottom: 2px solid #e5e7eb; }
    td { border-bottom: 1px solid #e5e7eb; }
    .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin: 24px 0; }
    .stat-card { background: #f9fafb; padding: 16px; border-radius: 8px; border-left: 4px solid #00D5CC; }
    .stat-label { font-size: 11px; color: #666; text-transform: uppercase; margin-bottom: 6px; font-weight: 600; }
    .stat-value { font-size: 28px; font-weight: 700; color: #00D5CC; }
    .section-title { font-size: 20px; font-weight: 700; color: #1a1a1a; margin-top: 32px; margin-bottom: 14px; }
    .footer { margin-top: 24px; padding-top: 12px; border-top: 1px solid #e5e7eb; font-size: 11px; color: #6b7280; text-align: center; }
  </style>
</head>
<body>
  <div class="cover-page">
    <div class="cover-content">
      <div class="cover-logo-container">
        ${logoHtml}
        ${companyNameHtml}
      </div>
      <div class="cover-divider"></div>
      <div class="cover-title">Compliance Report</div>
      <div class="cover-date">Generated on ${format(new Date(), "MMMM d, yyyy 'at' h:mm a")}</div>
    </div>
    ${contactInfoHtml}
  </div>

  <div class="content">
    <div class="page-header">
      <div class="page-title">Compliance Summary</div>
      <div class="page-date">${format(new Date(), "MMMM d, yyyy")}</div>
    </div>

    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">Total Documents</div>
        <div class="stat-value">${totalDocuments}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Current</div>
        <div class="stat-value">${currentDocuments}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Expiring Soon</div>
        <div class="stat-value">${expiringSoon}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Expired</div>
        <div class="stat-value">${expired}</div>
      </div>
    </div>

    <h2 class="section-title">Compliance Records</h2>
    
    ${complianceDocuments.length > 0 ? `
      <table>
        <thead>
          <tr>
            <th>Document Type</th>
            <th>Location</th>
            <th>Block</th>
            <th>Property</th>
            <th>Expiry Date</th>
            <th style="text-align: center;">Status</th>
            <th>Uploaded</th>
          </tr>
        </thead>
        <tbody>
          ${tableRows}
        </tbody>
      </table>
    ` : `
      <div style="text-align: center; padding: 40px; color: #999;">
        No compliance documents found
      </div>
    `}

    <div class="footer">
      <p>Report generated by ${escapeHtml(companyName)}</p>
    </div>
  </div>
</body>
</html>
    `;
  }

  // Generate Compliance Report PDF
  app.post("/api/reports/compliance/pdf", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user || !user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { blockId, propertyId, documentType, status, searchTerm } = req.body;

      let complianceDocuments = await storage.getComplianceDocuments(user.organizationId);
      const properties = await storage.getPropertiesByOrganization(user.organizationId);
      const blocks = await storage.getBlocksByOrganization(user.organizationId);

      // Apply filters
      if (blockId && blockId !== "all") {
        complianceDocuments = complianceDocuments.filter(d =>
          d.blockId === blockId || properties.find(p => p.id === d.propertyId)?.blockId === blockId
        );
      }

      if (propertyId && propertyId !== "all") {
        complianceDocuments = complianceDocuments.filter(d => d.propertyId === propertyId);
      }

      if (documentType && documentType !== "all") {
        complianceDocuments = complianceDocuments.filter(d => d.documentType === documentType);
      }

      if (status && status !== "all") {
        complianceDocuments = complianceDocuments.filter(d => {
          let docStatus = "current";
          if (d.expiryDate) {
            const expiryDate = new Date(d.expiryDate);
            const daysUntilExpiry = Math.floor((expiryDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24));

            if (daysUntilExpiry < 0) {
              docStatus = "expired";
            } else if (daysUntilExpiry <= 30) {
              docStatus = "expiring-soon";
            } else {
              docStatus = "current";
            }
          }
          return docStatus === status;
        });
      }

      if (searchTerm) {
        const searchLower = searchTerm.toLowerCase();
        complianceDocuments = complianceDocuments.filter(d =>
          d.documentType?.toLowerCase().includes(searchLower)
        );
      }

      // Fetch organization branding
      const organization = await storage.getOrganization(user.organizationId);
      const branding: ReportBrandingInfo = organization ? {
        logoUrl: organization.logoUrl,
        brandingName: organization.brandingName,
        brandingEmail: organization.brandingEmail,
        brandingPhone: organization.brandingPhone,
        brandingWebsite: organization.brandingWebsite,
      } : {};

      const html = generateComplianceReportHTML(complianceDocuments, properties, blocks, branding);

      let browser;
      try {
        browser = await launchPuppeteerBrowser();

        const page = await browser.newPage();
        await page.setContent(html, {
          waitUntil: "networkidle0",
        });

        const pdf = await page.pdf({
          format: "A4",
          landscape: true,
          printBackground: true,
          margin: {
            top: "15mm",
            right: "12mm",
            bottom: "15mm",
            left: "12mm",
          },
        });

        res.contentType("application/pdf");
        res.send(Buffer.from(pdf));
      } finally {
        if (browser) {
          await browser.close();
        }
      }
    } catch (error) {
      console.error("Error generating compliance report PDF:", error);
      res.status(500).json({ message: "Failed to generate report" });
    }
  });

  // ==================== DASHBOARD PDF REPORT ====================

  // Generate Dashboard PDF Report
  app.post("/api/reports/dashboard/pdf", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user || !user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { blockId, propertyId } = req.body;

      // Fetch organization branding
      const organization = await storage.getOrganization(user.organizationId);
      const branding: ReportBrandingInfo = organization ? {
        logoUrl: organization.logoUrl,
        brandingName: organization.brandingName,
        brandingEmail: organization.brandingEmail,
        brandingPhone: organization.brandingPhone,
        brandingWebsite: organization.brandingWebsite,
      } : {};

      // Fetch all data
      const allBlocks = await storage.getBlocksByOrganization(user.organizationId);
      const allProperties = await storage.getPropertiesByOrganization(user.organizationId);
      const allInspections = await storage.getInspectionsByOrganization(user.organizationId);
      const allMaintenance = await storage.getMaintenanceByOrganization(user.organizationId);
      const allCompliance = await storage.getComplianceDocuments(user.organizationId);
      const allTenantAssignments = await storage.getTenantAssignmentsByOrganization(user.organizationId);

      // Apply filters
      let blocks = allBlocks;
      let properties = allProperties;
      let inspections = allInspections;
      let maintenance = allMaintenance;
      let compliance = allCompliance;
      let tenantAssignments = allTenantAssignments;

      if (propertyId) {
        properties = properties.filter((p: any) => p.id === propertyId);
        inspections = inspections.filter((i: any) => i.propertyId === propertyId);
        compliance = compliance.filter((c: any) => c.propertyId === propertyId);
        maintenance = maintenance.filter((m: any) => m.propertyId === propertyId);
        tenantAssignments = tenantAssignments.filter((t: any) => t.propertyId === propertyId);
        const propertyBlock = allProperties.find((p: any) => p.id === propertyId);
        if (propertyBlock?.blockId) {
          blocks = blocks.filter((b: any) => b.id === propertyBlock.blockId);
        }
      } else if (blockId) {
        const blockPropertyIds = new Set(allProperties.filter((p: any) => p.blockId === blockId).map((p: any) => p.id));
        blocks = blocks.filter((b: any) => b.id === blockId);
        properties = properties.filter((p: any) => p.blockId === blockId);
        inspections = inspections.filter((i: any) => i.blockId === blockId || (i.propertyId && blockPropertyIds.has(i.propertyId)));
        compliance = compliance.filter((c: any) => c.blockId === blockId || (c.propertyId && blockPropertyIds.has(c.propertyId)));
        maintenance = maintenance.filter((m: any) => blockPropertyIds.has(m.propertyId));
        tenantAssignments = tenantAssignments.filter((t: any) => blockPropertyIds.has(t.propertyId));
      }

      // Get dashboard stats
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const days7Future = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);
      const days30Future = new Date(today.getTime() + 30 * 24 * 60 * 60 * 1000);
      const days90Ago = new Date(today.getTime() - 90 * 24 * 60 * 60 * 1000);

      const overdueInspections = inspections.filter((i: any) => {
        if (i.status === 'completed' || i.status === 'cancelled') return false;
        if (!i.scheduledDate) return false;
        return new Date(i.scheduledDate) < today;
      });

      const overdueCompliance = compliance.filter((c: any) => {
        if (!c.expiryDate) return false;
        return new Date(c.expiryDate) < today;
      });

      const urgentMaintenance = maintenance.filter((m: any) => {
        if (m.status === 'completed' || m.status === 'closed') return false;
        if (m.priority === 'urgent' || m.priority === 'high') return true;
        if (m.dueDate) {
          const dueDate = new Date(m.dueDate);
          const dueDateOnly = new Date(dueDate.getFullYear(), dueDate.getMonth(), dueDate.getDate());
          return dueDateOnly < today;
        }
        return false;
      });

      const activeAssignments = tenantAssignments.filter((t: any) => {
        const isActive = t.isActive !== undefined ? t.isActive : (t as any).is_active;
        return isActive === true;
      });
      const occupiedProperties = new Set(activeAssignments.map((t: any) => t.propertyId || (t as any).property_id));
      const occupancyRate = properties.length > 0
        ? Math.round((occupiedProperties.size / properties.length) * 100)
        : 0;

      const validCompliance = compliance.filter((c: any) => {
        if (!c.expiryDate) return true;
        return new Date(c.expiryDate) >= today;
      });
      const complianceRate = compliance.length > 0
        ? Math.round((validCompliance.length / compliance.length) * 100)
        : 100;

      const recentInspections = inspections.filter((i: any) => {
        if (!i.createdAt) return false;
        return new Date(i.createdAt) >= days90Ago;
      });
      const completedRecentInspections = recentInspections.filter((i: any) => i.status === 'completed');
      const inspectionCompletionRate = recentInspections.length > 0
        ? Math.round((completedRecentInspections.length / recentInspections.length) * 100)
        : 0;

      const completedMaintenance = maintenance.filter((m: any) => {
        if (m.status !== 'completed') return false;
        if (!m.completedAt) return false;
        return new Date(m.completedAt) >= days90Ago;
      });

      let avgResolutionDays = 0;
      if (completedMaintenance.length > 0) {
        const totalDays = completedMaintenance.reduce((sum: number, m: any) => {
          if (!m.createdAt || !m.completedAt) return sum;
          const created = new Date(m.createdAt);
          const completed = new Date(m.completedAt);
          return sum + Math.ceil((completed.getTime() - created.getTime()) / (1000 * 60 * 60 * 24));
        }, 0);
        avgResolutionDays = Math.round(totalDays / completedMaintenance.length * 10) / 10;
      }

      const openMaintenance = maintenance.filter((m: any) => m.status === 'open' || m.status === 'in_progress');
      const inProgressMaintenance = maintenance.filter((m: any) => m.status === 'in_progress');

      const inspectionsDueNext7Days = inspections.filter((i: any) => {
        if (i.status === 'completed' || i.status === 'cancelled') return false;
        if (!i.scheduledDate) return false;
        const scheduled = new Date(i.scheduledDate);
        return scheduled >= today && scheduled <= days7Future;
      });

      const inspectionsDueNext30Days = inspections.filter((i: any) => {
        if (i.status === 'completed' || i.status === 'cancelled') return false;
        if (!i.scheduledDate) return false;
        const scheduled = new Date(i.scheduledDate);
        return scheduled >= today && scheduled <= days30Future;
      });

      const complianceExpiringNext30Days = compliance.filter((c: any) => {
        if (!c.expiryDate) return false;
        const expiry = new Date(c.expiryDate);
        return expiry >= today && expiry <= days30Future;
      });

      const complianceExpiringNext90Days = compliance.filter((c: any) => {
        if (!c.expiryDate) return false;
        const expiry = new Date(c.expiryDate);
        return expiry >= today && expiry <= new Date(today.getTime() + 90 * 24 * 60 * 60 * 1000);
      });

      const stats = {
        totals: {
          properties: properties.length,
          blocks: blocks.length,
          inspections: inspections.length,
          maintenance: maintenance.length,
          compliance: compliance.length,
        },
        alerts: {
          overdueInspections: overdueInspections.length,
          overdueInspectionsList: overdueInspections.map((i: any) => ({
            id: i.id,
            propertyId: i.propertyId,
            blockId: i.blockId,
            type: i.type,
            scheduledDate: i.scheduledDate,
            daysOverdue: Math.floor((today.getTime() - new Date(i.scheduledDate).getTime()) / (1000 * 60 * 60 * 24)),
          })),
          overdueCompliance: overdueCompliance.length,
          overdueComplianceList: overdueCompliance.map((c: any) => ({
            id: c.id,
            propertyId: c.propertyId,
            blockId: c.blockId,
            documentType: c.documentType,
            expiryDate: c.expiryDate,
            daysOverdue: Math.floor((today.getTime() - new Date(c.expiryDate).getTime()) / (1000 * 60 * 60 * 24)),
          })),
          urgentMaintenance: urgentMaintenance.length,
          urgentMaintenanceList: urgentMaintenance.map((m: any) => ({
            id: m.id,
            title: m.title,
            propertyId: m.propertyId,
            priority: m.priority,
            dueDate: m.dueDate,
            daysOverdue: m.dueDate ? Math.floor((today.getTime() - new Date(m.dueDate).getTime()) / (1000 * 60 * 60 * 24)) : null,
            createdAt: m.createdAt,
          })),
        },
        upcoming: {
          inspectionsDueNext7Days: inspectionsDueNext7Days.length,
          inspectionsDueNext30Days: inspectionsDueNext30Days.length,
          complianceExpiringNext30Days: complianceExpiringNext30Days.length,
          complianceExpiringNext90Days: complianceExpiringNext90Days.length,
        },
        kpis: {
          occupancyRate,
          complianceRate,
          inspectionCompletionRate,
          avgMaintenanceResolutionDays: avgResolutionDays,
          openMaintenanceCount: openMaintenance.length,
          inProgressMaintenanceCount: inProgressMaintenance.length,
        },
      };

      const baseUrl = getBaseUrl(req);
      const html = generateDashboardReportHTML(
        properties,
        blocks,
        inspections,
        compliance,
        maintenance,
        tenantAssignments,
        blockId || undefined,
        propertyId || undefined,
        branding,
        baseUrl
      );

      let browser;
      try {
        browser = await launchPuppeteerBrowser();

        const page = await browser.newPage();
        await page.setContent(html, {
          waitUntil: "networkidle0",
        });

        const pdf = await page.pdf({
          format: "A4",
          landscape: true,
          printBackground: true,
          margin: {
            top: "15mm",
            right: "12mm",
            bottom: "15mm",
            left: "12mm",
          },
        });

        res.contentType("application/pdf");
        const filterText = blockId ? `-block-${blocks.find((b: any) => b.id === blockId)?.name || 'filtered'}` :
          propertyId ? `-property-${properties.find((p: any) => p.id === propertyId)?.name || 'filtered'}` :
            '-all';
        res.setHeader("Content-Disposition", `attachment; filename="dashboard-report${filterText}-${new Date().toISOString().split('T')[0]}.pdf"`);
        res.send(Buffer.from(pdf));
      } finally {
        if (browser) {
          await browser.close();
        }
      }
    } catch (error) {
      console.error("Error generating dashboard report PDF:", error);
      res.status(500).json({ message: "Failed to generate report" });
    }
  });

  // ==================== COMPREHENSIVE EXCEL REPORT ====================

  // Generate comprehensive Excel report
  app.get("/api/reports/comprehensive/excel", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user || !user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Fetch all data
      const blocks = await storage.getBlocksByOrganization(user.organizationId);
      const properties = await storage.getPropertiesByOrganization(user.organizationId);
      const inspections = await storage.getInspectionsByOrganization(user.organizationId);
      const maintenanceRequests = await storage.getMaintenanceByOrganization(user.organizationId);
      const complianceDocuments = await storage.getComplianceDocuments(user.organizationId);
      const assetInventory = await storage.getAssetInventoryByOrganization(user.organizationId);
      const tenantAssignments = await storage.getTenantAssignmentsByOrganization(user.organizationId);
      const organization = await storage.getOrganization(user.organizationId);

      // Create workbook
      const workbook = new ExcelJS.Workbook();
      workbook.creator = organization?.name || "Inspect360";
      workbook.created = new Date();
      workbook.modified = new Date();

      // Define styles
      const headerStyle = {
        font: { bold: true, color: { argb: 'FFFFFFFF' }, size: 12 },
        fill: { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF00D5CC' } },
        alignment: { vertical: 'middle', horizontal: 'center', wrapText: true },
        border: {
          top: { style: 'thin', color: { argb: 'FF000000' } },
          left: { style: 'thin', color: { argb: 'FF000000' } },
          bottom: { style: 'thin', color: { argb: 'FF000000' } },
          right: { style: 'thin', color: { argb: 'FF000000' } }
        }
      };

      const subHeaderStyle = {
        font: { bold: true, color: { argb: 'FF000000' }, size: 11 },
        fill: { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE5E7EB' } },
        alignment: { vertical: 'middle', horizontal: 'left', wrapText: true },
        border: {
          top: { style: 'thin', color: { argb: 'FF000000' } },
          left: { style: 'thin', color: { argb: 'FF000000' } },
          bottom: { style: 'thin', color: { argb: 'FF000000' } },
          right: { style: 'thin', color: { argb: 'FF000000' } }
        }
      };

      const cellStyle = {
        alignment: { vertical: 'middle', horizontal: 'left', wrapText: true },
        border: {
          top: { style: 'thin', color: { argb: 'FFCCCCCC' } },
          left: { style: 'thin', color: { argb: 'FFCCCCCC' } },
          bottom: { style: 'thin', color: { argb: 'FFCCCCCC' } },
          right: { style: 'thin', color: { argb: 'FFCCCCCC' } }
        }
      };

      // Summary Sheet
      const summarySheet = workbook.addWorksheet('Summary');
      summarySheet.columns = [
        { width: 30 },
        { width: 20 }
      ];

      let summaryRow = 1;
      summarySheet.getCell(summaryRow, 1).value = 'Comprehensive Report';
      summarySheet.getCell(summaryRow, 1).font = { bold: true, size: 16 };
      summarySheet.mergeCells(summaryRow, 1, summaryRow, 2);
      summaryRow += 2;

      summarySheet.getCell(summaryRow, 1).value = 'Organization:';
      summarySheet.getCell(summaryRow, 2).value = organization?.name || 'N/A';
      summaryRow++;

      summarySheet.getCell(summaryRow, 1).value = 'Report Date:';
      summarySheet.getCell(summaryRow, 2).value = new Date().toLocaleDateString();
      summaryRow += 2;

      // Statistics
      const totalBlocks = blocks.length;
      const totalProperties = properties.length;
      const totalInspections = inspections.length;
      const totalMaintenance = maintenanceRequests.length;
      const openMaintenance = maintenanceRequests.filter(m => m.status === 'open' || m.status === 'in_progress').length;
      const totalAssets = assetInventory.length;
      const totalCompliance = complianceDocuments.length;
      const expiringCompliance = complianceDocuments.filter(doc => {
        if (!doc.expiryDate) return false;
        const expiry = new Date(doc.expiryDate);
        const daysUntil = Math.floor((expiry.getTime() - Date.now()) / (1000 * 60 * 60 * 24));
        return daysUntil > 0 && daysUntil <= 30;
      }).length;
      const expiredCompliance = complianceDocuments.filter(doc => {
        if (!doc.expiryDate) return false;
        const expiry = new Date(doc.expiryDate);
        return expiry.getTime() < Date.now();
      }).length;

      const stats = [
        ['Total Blocks', totalBlocks],
        ['Total Properties', totalProperties],
        ['Total Inspections', totalInspections],
        ['Total Maintenance Requests', totalMaintenance],
        ['Open Maintenance Requests', openMaintenance],
        ['Total Assets', totalAssets],
        ['Total Compliance Documents', totalCompliance],
        ['Expiring Soon (â‰¤30 days)', expiringCompliance],
        ['Expired Documents', expiredCompliance]
      ];

      summarySheet.getCell(summaryRow, 1).value = 'Statistics';
      summarySheet.getCell(summaryRow, 1).font = { bold: true, size: 14 };
      summarySheet.mergeCells(summaryRow, 1, summaryRow, 2);
      summaryRow++;

      stats.forEach(([label, value]) => {
        summarySheet.getCell(summaryRow, 1).value = label;
        summarySheet.getCell(summaryRow, 1).font = { bold: true };
        summarySheet.getCell(summaryRow, 2).value = value;
        summaryRow++;
      });

      // Blocks Sheet with nested data
      const blocksSheet = workbook.addWorksheet('Blocks & Properties');
      blocksSheet.columns = [
        { width: 25 }, // Block Name
        { width: 30 }, // Block Address
        { width: 25 }, // Property Name
        { width: 30 }, // Property Address
        { width: 15 }, // Property Type
        { width: 20 }, // Tenant Status
        { width: 15 }, // Monthly Rent
        { width: 15 }, // Inspections
        { width: 15 }, // Maintenance
        { width: 15 }, // Assets
        { width: 15 }  // Compliance
      ];

      let row = 1;
      // Header
      const headers = ['Block Name', 'Block Address', 'Property Name', 'Property Address', 'Property Type', 'Tenant Status', 'Monthly Rent', 'Inspections', 'Maintenance', 'Assets', 'Compliance'];
      headers.forEach((header, idx) => {
        const cell = blocksSheet.getCell(row, idx + 1);
        cell.value = header;
        Object.assign(cell, headerStyle);
      });
      row++;

      // Group properties by block
      const propertiesByBlock = new Map<string, any[]>();
      properties.forEach(prop => {
        const blockId = prop.blockId || 'no-block';
        if (!propertiesByBlock.has(blockId)) {
          propertiesByBlock.set(blockId, []);
        }
        propertiesByBlock.get(blockId)!.push(prop);
      });

      blocks.forEach(block => {
        const blockProperties = propertiesByBlock.get(block.id) || [];

        if (blockProperties.length === 0) {
          // Block with no properties
          blocksSheet.getCell(row, 1).value = block.name;
          blocksSheet.getCell(row, 1).font = { bold: true };
          blocksSheet.getCell(row, 2).value = block.address || '';
          row++;
        } else {
          blockProperties.forEach((property, propIdx) => {
            // Get related data for this property
            const propertyInspections = inspections.filter(i => i.propertyId === property.id);
            const propertyMaintenance = maintenanceRequests.filter(m => m.propertyId === property.id);
            const propertyAssets = assetInventory.filter(a => a.propertyId === property.id);
            const propertyCompliance = complianceDocuments.filter(c => c.propertyId === property.id);
            const tenantAssignment = tenantAssignments.find(ta => ta.propertyId === property.id && (ta.status === 'active' || ta.status === 'current'));

            // Block name (only on first property)
            if (propIdx === 0) {
              blocksSheet.getCell(row, 1).value = block.name;
              blocksSheet.getCell(row, 1).font = { bold: true };
              blocksSheet.getCell(row, 2).value = block.address || '';
            }

            // Property data
            blocksSheet.getCell(row, 3).value = property.name || '';
            blocksSheet.getCell(row, 4).value = property.address || '';
            // Property Type - access from property object
            const propertyTypeValue = (property as any).propertyType || '';
            blocksSheet.getCell(row, 5).value = propertyTypeValue;
            blocksSheet.getCell(row, 6).value = tenantAssignment ? 'Occupied' : 'Vacant';
            blocksSheet.getCell(row, 7).value = tenantAssignment?.monthlyRent || '';
            blocksSheet.getCell(row, 8).value = propertyInspections.length;
            blocksSheet.getCell(row, 9).value = propertyMaintenance.length;
            blocksSheet.getCell(row, 10).value = propertyAssets.length;
            blocksSheet.getCell(row, 11).value = propertyCompliance.length;

            // Apply cell styles
            for (let col = 1; col <= 11; col++) {
              Object.assign(blocksSheet.getCell(row, col), cellStyle);
            }

            row++;
          });
        }
      });

      // Inspections Sheet
      const inspectionsSheet = workbook.addWorksheet('Inspections');
      inspectionsSheet.columns = [
        { width: 20 }, // Date
        { width: 25 }, // Block
        { width: 25 }, // Property
        { width: 15 }, // Type
        { width: 15 }, // Status
        { width: 25 }, // Inspector
        { width: 20 }, // Scheduled Date
        { width: 20 }, // Completed Date
        { width: 15 }  // Tenant Approval
      ];

      row = 1;
      const inspectionHeaders = ['Date', 'Block', 'Property', 'Type', 'Status', 'Inspector', 'Scheduled Date', 'Completed Date', 'Tenant Approval'];
      inspectionHeaders.forEach((header, idx) => {
        const cell = inspectionsSheet.getCell(row, idx + 1);
        cell.value = header;
        Object.assign(cell, headerStyle);
      });
      row++;

      inspections.forEach(inspection => {
        const block = blocks.find(b => b.id === (inspection.blockId || inspection.property?.blockId));
        const property = properties.find(p => p.id === inspection.propertyId) || inspection.property;

        inspectionsSheet.getCell(row, 1).value = inspection.completedDate
          ? new Date(inspection.completedDate).toLocaleDateString()
          : inspection.scheduledDate
            ? new Date(inspection.scheduledDate).toLocaleDateString()
            : '';
        inspectionsSheet.getCell(row, 2).value = block?.name || '';
        inspectionsSheet.getCell(row, 3).value = property?.name || '';
        inspectionsSheet.getCell(row, 4).value = inspection.type || '';
        inspectionsSheet.getCell(row, 5).value = inspection.status || '';
        inspectionsSheet.getCell(row, 6).value = inspection.clerk
          ? `${inspection.clerk.firstName || ''} ${inspection.clerk.lastName || ''}`.trim() || inspection.clerk.email
          : '';
        inspectionsSheet.getCell(row, 7).value = inspection.scheduledDate
          ? new Date(inspection.scheduledDate).toLocaleDateString()
          : '';
        inspectionsSheet.getCell(row, 8).value = inspection.completedDate
          ? new Date(inspection.completedDate).toLocaleDateString()
          : '';

        // Tenant approval status for check-in inspections
        if (inspection.type === 'check_in') {
          if (inspection.tenantApprovalStatus === 'approved') {
            inspectionsSheet.getCell(row, 9).value = 'Approved';
            inspectionsSheet.getCell(row, 9).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFDCFCE7' } };
          } else if (inspection.tenantApprovalStatus === 'disputed') {
            inspectionsSheet.getCell(row, 9).value = 'Disputed';
            inspectionsSheet.getCell(row, 9).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFF3CD' } };
          } else if (inspection.tenantApprovalStatus === 'pending' || !inspection.tenantApprovalStatus) {
            inspectionsSheet.getCell(row, 9).value = 'Pending';
            inspectionsSheet.getCell(row, 9).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFE5CC' } };
          }
        }

        for (let col = 1; col <= 9; col++) {
          Object.assign(inspectionsSheet.getCell(row, col), cellStyle);
        }
        row++;
      });

      // Maintenance Sheet
      const maintenanceSheet = workbook.addWorksheet('Maintenance');
      maintenanceSheet.columns = [
        { width: 20 }, // Date
        { width: 25 }, // Block
        { width: 25 }, // Property
        { width: 30 }, // Title
        { width: 15 }, // Status
        { width: 15 }, // Priority
        { width: 25 }, // Reported By
        { width: 25 }, // Assigned To
        { width: 20 }  // Due Date
      ];

      row = 1;
      const maintenanceHeaders = ['Date', 'Block', 'Property', 'Title', 'Status', 'Priority', 'Reported By', 'Assigned To', 'Due Date'];
      maintenanceHeaders.forEach((header, idx) => {
        const cell = maintenanceSheet.getCell(row, idx + 1);
        cell.value = header;
        Object.assign(cell, headerStyle);
      });
      row++;

      maintenanceRequests.forEach(maintenance => {
        const block = blocks.find(b => b.id === (maintenance.blockId || maintenance.property?.blockId));
        const property = properties.find(p => p.id === maintenance.propertyId) || maintenance.property;

        maintenanceSheet.getCell(row, 1).value = maintenance.createdAt
          ? new Date(maintenance.createdAt).toLocaleDateString()
          : '';
        maintenanceSheet.getCell(row, 2).value = block?.name || maintenance.block?.name || '';
        maintenanceSheet.getCell(row, 3).value = property?.name || maintenance.property?.name || '';
        maintenanceSheet.getCell(row, 4).value = maintenance.title || '';
        maintenanceSheet.getCell(row, 5).value = maintenance.status || '';

        // Color code status
        if (maintenance.status === 'open') {
          maintenanceSheet.getCell(row, 5).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFE5CC' } };
        } else if (maintenance.status === 'in_progress') {
          maintenanceSheet.getCell(row, 5).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE3F2FD' } };
        } else if (maintenance.status === 'completed') {
          maintenanceSheet.getCell(row, 5).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFDCFCE7' } };
        }

        maintenanceSheet.getCell(row, 6).value = maintenance.priority || '';
        maintenanceSheet.getCell(row, 7).value = maintenance.reportedByUser
          ? `${maintenance.reportedByUser.firstName || ''} ${maintenance.reportedByUser.lastName || ''}`.trim()
          : '';
        maintenanceSheet.getCell(row, 8).value = maintenance.assignedToUser
          ? `${maintenance.assignedToUser.firstName || ''} ${maintenance.assignedToUser.lastName || ''}`.trim()
          : '';
        maintenanceSheet.getCell(row, 9).value = maintenance.dueDate
          ? new Date(maintenance.dueDate).toLocaleDateString()
          : '';

        for (let col = 1; col <= 9; col++) {
          Object.assign(maintenanceSheet.getCell(row, col), cellStyle);
        }
        row++;
      });

      // Assets Sheet
      const assetsSheet = workbook.addWorksheet('Assets');
      assetsSheet.columns = [
        { width: 25 }, // Block
        { width: 25 }, // Property
        { width: 30 }, // Asset Name
        { width: 20 }, // Category
        { width: 15 }, // Purchase Price
        { width: 15 }, // Current Value
        { width: 20 }, // Purchase Date
        { width: 15 }, // Condition
        { width: 20 }  // Location
      ];

      row = 1;
      const assetHeaders = ['Block', 'Property', 'Asset Name', 'Category', 'Purchase Price', 'Current Value', 'Purchase Date', 'Condition', 'Location'];
      assetHeaders.forEach((header, idx) => {
        const cell = assetsSheet.getCell(row, idx + 1);
        cell.value = header;
        Object.assign(cell, headerStyle);
      });
      row++;

      assetInventory.forEach(asset => {
        const property = properties.find(p => p.id === asset.propertyId);
        const block = property ? blocks.find(b => b.id === property.blockId) : null;

        assetsSheet.getCell(row, 1).value = block?.name || '';
        assetsSheet.getCell(row, 2).value = property?.name || '';
        assetsSheet.getCell(row, 3).value = asset.name || '';
        assetsSheet.getCell(row, 4).value = asset.category || '';
        assetsSheet.getCell(row, 5).value = asset.purchasePrice ? parseFloat(asset.purchasePrice) : '';
        assetsSheet.getCell(row, 6).value = asset.currentValue ? parseFloat(asset.currentValue) : '';
        assetsSheet.getCell(row, 7).value = asset.datePurchased
          ? new Date(asset.datePurchased).toLocaleDateString()
          : '';
        assetsSheet.getCell(row, 8).value = asset.condition || '';
        assetsSheet.getCell(row, 9).value = asset.location || '';

        for (let col = 1; col <= 9; col++) {
          Object.assign(assetsSheet.getCell(row, col), cellStyle);
        }
        row++;
      });

      // Compliance Sheet
      const complianceSheet = workbook.addWorksheet('Compliance');
      complianceSheet.columns = [
        { width: 25 }, // Block
        { width: 25 }, // Property
        { width: 25 }, // Document Type
        { width: 30 }, // Document Name
        { width: 20 }, // Issue Date
        { width: 20 }, // Expiry Date
        { width: 15 }, // Status
        { width: 30 }  // Notes
      ];

      row = 1;
      const complianceHeaders = ['Block', 'Property', 'Document Type', 'Document Name', 'Issue Date', 'Expiry Date', 'Status', 'Notes'];
      complianceHeaders.forEach((header, idx) => {
        const cell = complianceSheet.getCell(row, idx + 1);
        cell.value = header;
        Object.assign(cell, headerStyle);
      });
      row++;

      complianceDocuments.forEach(doc => {
        const property = properties.find(p => p.id === doc.propertyId);
        const block = property ? blocks.find(b => b.id === property.blockId) : blocks.find(b => b.id === doc.blockId);

        let status = 'Current';
        let statusColor = 'FFDCFCE7'; // Green
        if (doc.expiryDate) {
          const expiry = new Date(doc.expiryDate);
          const daysUntil = Math.floor((expiry.getTime() - Date.now()) / (1000 * 60 * 60 * 24));
          if (daysUntil < 0) {
            status = 'Expired';
            statusColor = 'FFFFE5CC'; // Red
          } else if (daysUntil <= 30) {
            status = 'Expiring Soon';
            statusColor = 'FFFFF3CD'; // Yellow
          }
        }

        complianceSheet.getCell(row, 1).value = block?.name || '';
        complianceSheet.getCell(row, 2).value = property?.name || '';
        complianceSheet.getCell(row, 3).value = doc.documentType || '';
        complianceSheet.getCell(row, 4).value = (doc as any).documentName || '';
        complianceSheet.getCell(row, 5).value = (doc as any).issueDate
          ? new Date((doc as any).issueDate).toLocaleDateString()
          : '';
        complianceSheet.getCell(row, 6).value = doc.expiryDate
          ? new Date(doc.expiryDate).toLocaleDateString()
          : '';
        complianceSheet.getCell(row, 7).value = status;
        complianceSheet.getCell(row, 7).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: statusColor } };
        complianceSheet.getCell(row, 8).value = (doc as any).notes || '';

        for (let col = 1; col <= 8; col++) {
          Object.assign(complianceSheet.getCell(row, col), cellStyle);
        }
        row++;
      });

      // Tenants Sheet
      const tenantsSheet = workbook.addWorksheet('Tenants');
      tenantsSheet.columns = [
        { width: 25 }, // Block
        { width: 25 }, // Property
        { width: 30 }, // Tenant Name
        { width: 30 }, // Email
        { width: 20 }, // Lease Start
        { width: 20 }, // Lease End
        { width: 15 }, // Monthly Rent
        { width: 15 }, // Deposit
        { width: 15 }  // Status
      ];

      row = 1;
      const tenantHeaders = ['Block', 'Property', 'Tenant Name', 'Email', 'Lease Start', 'Lease End', 'Monthly Rent', 'Deposit', 'Status'];
      tenantHeaders.forEach((header, idx) => {
        const cell = tenantsSheet.getCell(row, idx + 1);
        cell.value = header;
        Object.assign(cell, headerStyle);
      });
      row++;

      tenantAssignments.forEach(assignment => {
        const property = properties.find(p => p.id === assignment.propertyId);
        const block = property ? blocks.find(b => b.id === property.blockId) : null;

        // Get tenant name from firstName and lastName
        const tenantFirstName = assignment.tenantFirstName || '';
        const tenantLastName = assignment.tenantLastName || '';
        const tenantFullName = [tenantFirstName, tenantLastName].filter(Boolean).join(' ') || '';
        const tenantEmail = assignment.tenantEmail || '';

        tenantsSheet.getCell(row, 1).value = block?.name || '';
        tenantsSheet.getCell(row, 2).value = property?.name || '';
        tenantsSheet.getCell(row, 3).value = tenantFullName;
        tenantsSheet.getCell(row, 4).value = tenantEmail;
        tenantsSheet.getCell(row, 5).value = assignment.leaseStartDate
          ? new Date(assignment.leaseStartDate).toLocaleDateString()
          : '';
        tenantsSheet.getCell(row, 6).value = assignment.leaseEndDate
          ? new Date(assignment.leaseEndDate).toLocaleDateString()
          : '';
        tenantsSheet.getCell(row, 7).value = assignment.monthlyRent || '';
        tenantsSheet.getCell(row, 8).value = assignment.depositAmount || '';
        tenantsSheet.getCell(row, 9).value = assignment.isActive ? 'active' : 'inactive';

        for (let col = 1; col <= 9; col++) {
          Object.assign(tenantsSheet.getCell(row, col), cellStyle);
        }
        row++;
      });

      // At Risk Sheet
      const atRiskSheet = workbook.addWorksheet('At Risk Items');
      atRiskSheet.columns = [
        { width: 20 }, // Type
        { width: 25 }, // Block
        { width: 25 }, // Property
        { width: 30 }, // Item Name
        { width: 20 }, // Status
        { width: 20 }, // Due/Expiry Date
        { width: 15 }, // Days Overdue
        { width: 40 }  // Notes
      ];

      row = 1;
      const atRiskHeaders = ['Type', 'Block', 'Property', 'Item Name', 'Status', 'Due/Expiry Date', 'Days Overdue', 'Notes'];
      atRiskHeaders.forEach((header, idx) => {
        const cell = atRiskSheet.getCell(row, idx + 1);
        cell.value = header;
        Object.assign(cell, headerStyle);
      });
      row++;

      const now = new Date();

      // Expired compliance documents
      complianceDocuments.forEach(doc => {
        if (doc.expiryDate) {
          const expiry = new Date(doc.expiryDate);
          if (expiry < now) {
            const property = properties.find(p => p.id === doc.propertyId);
            const block = property ? blocks.find(b => b.id === property.blockId) : blocks.find(b => b.id === doc.blockId);
            const daysOverdue = Math.floor((now.getTime() - expiry.getTime()) / (1000 * 60 * 60 * 24));

            atRiskSheet.getCell(row, 1).value = 'Compliance Document';
            atRiskSheet.getCell(row, 1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFE5CC' } };
            atRiskSheet.getCell(row, 2).value = block?.name || '';
            atRiskSheet.getCell(row, 3).value = property?.name || '';
            atRiskSheet.getCell(row, 4).value = (doc as any).documentName || doc.documentType || '';
            atRiskSheet.getCell(row, 5).value = 'Expired';
            atRiskSheet.getCell(row, 5).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFE5CC' } };
            atRiskSheet.getCell(row, 6).value = expiry.toLocaleDateString();
            atRiskSheet.getCell(row, 7).value = daysOverdue;
            atRiskSheet.getCell(row, 7).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFE5CC' } };
            atRiskSheet.getCell(row, 8).value = (doc as any).notes || '';

            for (let col = 1; col <= 8; col++) {
              Object.assign(atRiskSheet.getCell(row, col), cellStyle);
            }
            row++;
          }
        }
      });

      // Overdue maintenance
      maintenanceRequests.forEach(maintenance => {
        if (maintenance.dueDate) {
          const dueDate = new Date(maintenance.dueDate);
          if (dueDate < now && (maintenance.status === 'open' || maintenance.status === 'in_progress')) {
            const property = properties.find(p => p.id === maintenance.propertyId) || maintenance.property;
            const block = property ? blocks.find(b => b.id === property.blockId) : blocks.find(b => b.id === maintenance.blockId) || maintenance.block;
            const daysOverdue = Math.floor((now.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24));

            atRiskSheet.getCell(row, 1).value = 'Maintenance Request';
            atRiskSheet.getCell(row, 1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFE5CC' } };
            atRiskSheet.getCell(row, 2).value = block?.name || '';
            atRiskSheet.getCell(row, 3).value = property?.name || '';
            atRiskSheet.getCell(row, 4).value = maintenance.title || '';
            atRiskSheet.getCell(row, 5).value = maintenance.status || '';
            atRiskSheet.getCell(row, 6).value = dueDate.toLocaleDateString();
            atRiskSheet.getCell(row, 7).value = daysOverdue;
            atRiskSheet.getCell(row, 7).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFE5CC' } };
            atRiskSheet.getCell(row, 8).value = maintenance.description || '';

            for (let col = 1; col <= 8; col++) {
              Object.assign(atRiskSheet.getCell(row, col), cellStyle);
            }
            row++;
          }
        }
      });

      // Overdue inspections
      inspections.forEach(inspection => {
        if (inspection.scheduledDate && inspection.status !== 'completed') {
          const scheduled = new Date(inspection.scheduledDate);
          if (scheduled < now) {
            const property = properties.find(p => p.id === inspection.propertyId) || inspection.property;
            const block = property ? blocks.find(b => b.id === property.blockId) : blocks.find(b => b.id === inspection.blockId);
            const daysOverdue = Math.floor((now.getTime() - scheduled.getTime()) / (1000 * 60 * 60 * 24));

            atRiskSheet.getCell(row, 1).value = 'Inspection';
            atRiskSheet.getCell(row, 1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFE5CC' } };
            atRiskSheet.getCell(row, 2).value = block?.name || '';
            atRiskSheet.getCell(row, 3).value = property?.name || '';
            atRiskSheet.getCell(row, 4).value = `${inspection.type || 'Inspection'} - ${inspection.status || 'Pending'}`;
            atRiskSheet.getCell(row, 5).value = inspection.status || '';
            atRiskSheet.getCell(row, 6).value = scheduled.toLocaleDateString();
            atRiskSheet.getCell(row, 7).value = daysOverdue;
            atRiskSheet.getCell(row, 7).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFE5CC' } };
            atRiskSheet.getCell(row, 8).value = inspection.notes || '';

            for (let col = 1; col <= 8; col++) {
              Object.assign(atRiskSheet.getCell(row, col), cellStyle);
            }
            row++;
          }
        }
      });

      // Upcoming Sheet
      const upcomingSheet = workbook.addWorksheet('Upcoming Items');
      upcomingSheet.columns = [
        { width: 20 }, // Type
        { width: 25 }, // Block
        { width: 25 }, // Property
        { width: 30 }, // Item Name
        { width: 20 }, // Due Date
        { width: 15 }, // Days Until
        { width: 40 }  // Notes
      ];

      row = 1;
      const upcomingHeaders = ['Type', 'Block', 'Property', 'Item Name', 'Due Date', 'Days Until', 'Notes'];
      upcomingHeaders.forEach((header, idx) => {
        const cell = upcomingSheet.getCell(row, idx + 1);
        cell.value = header;
        Object.assign(cell, headerStyle);
      });
      row++;

      // Compliance documents expiring soon (within 30 days)
      complianceDocuments.forEach(doc => {
        if (doc.expiryDate) {
          const expiry = new Date(doc.expiryDate);
          const daysUntil = Math.floor((expiry.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
          if (daysUntil > 0 && daysUntil <= 30) {
            const property = properties.find(p => p.id === doc.propertyId);
            const block = property ? blocks.find(b => b.id === property.blockId) : blocks.find(b => b.id === doc.blockId);

            upcomingSheet.getCell(row, 1).value = 'Compliance Document';
            upcomingSheet.getCell(row, 1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFF3CD' } };
            upcomingSheet.getCell(row, 2).value = block?.name || '';
            upcomingSheet.getCell(row, 3).value = property?.name || '';
            upcomingSheet.getCell(row, 4).value = doc.documentType || '';
            upcomingSheet.getCell(row, 5).value = expiry.toLocaleDateString();
            upcomingSheet.getCell(row, 6).value = daysUntil;
            upcomingSheet.getCell(row, 6).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFF3CD' } };
            upcomingSheet.getCell(row, 7).value = ''; // Notes field not available in schema

            for (let col = 1; col <= 7; col++) {
              Object.assign(upcomingSheet.getCell(row, col), cellStyle);
            }
            row++;
          }
        }
      });

      // Upcoming maintenance due dates
      maintenanceRequests.forEach(maintenance => {
        if (maintenance.dueDate) {
          const dueDate = new Date(maintenance.dueDate);
          const daysUntil = Math.floor((dueDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
          if (daysUntil > 0 && daysUntil <= 30 && (maintenance.status === 'open' || maintenance.status === 'in_progress')) {
            const property = properties.find(p => p.id === maintenance.propertyId) || maintenance.property;
            const block = property ? blocks.find(b => b.id === property.blockId) : blocks.find(b => b.id === maintenance.blockId) || maintenance.block;

            upcomingSheet.getCell(row, 1).value = 'Maintenance Request';
            upcomingSheet.getCell(row, 1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFF3CD' } };
            upcomingSheet.getCell(row, 2).value = block?.name || '';
            upcomingSheet.getCell(row, 3).value = property?.name || '';
            upcomingSheet.getCell(row, 4).value = maintenance.title || '';
            upcomingSheet.getCell(row, 5).value = dueDate.toLocaleDateString();
            upcomingSheet.getCell(row, 6).value = daysUntil;
            upcomingSheet.getCell(row, 6).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFF3CD' } };
            upcomingSheet.getCell(row, 7).value = maintenance.description || '';

            for (let col = 1; col <= 7; col++) {
              Object.assign(upcomingSheet.getCell(row, col), cellStyle);
            }
            row++;
          }
        }
      });

      // Upcoming inspections
      inspections.forEach(inspection => {
        if (inspection.scheduledDate && inspection.status !== 'completed') {
          const scheduled = new Date(inspection.scheduledDate);
          const daysUntil = Math.floor((scheduled.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
          if (daysUntil > 0 && daysUntil <= 30) {
            const property = properties.find(p => p.id === inspection.propertyId) || inspection.property;
            const block = property ? blocks.find(b => b.id === property.blockId) : blocks.find(b => b.id === inspection.blockId);

            upcomingSheet.getCell(row, 1).value = 'Inspection';
            upcomingSheet.getCell(row, 1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFF3CD' } };
            upcomingSheet.getCell(row, 2).value = block?.name || '';
            upcomingSheet.getCell(row, 3).value = property?.name || '';
            upcomingSheet.getCell(row, 4).value = `${inspection.type || 'Inspection'} - ${inspection.status || 'Scheduled'}`;
            upcomingSheet.getCell(row, 5).value = scheduled.toLocaleDateString();
            upcomingSheet.getCell(row, 6).value = daysUntil;
            upcomingSheet.getCell(row, 6).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFF3CD' } };
            upcomingSheet.getCell(row, 7).value = inspection.notes || '';

            for (let col = 1; col <= 7; col++) {
              Object.assign(upcomingSheet.getCell(row, col), cellStyle);
            }
            row++;
          }
        }
      });

      // Upcoming lease expirations
      tenantAssignments.forEach(assignment => {
        if (assignment.leaseEndDate && (assignment.status === 'active' || assignment.status === 'current')) {
          const leaseEnd = new Date(assignment.leaseEndDate);
          const daysUntil = Math.floor((leaseEnd.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
          if (daysUntil > 0 && daysUntil <= 90) {
            const property = properties.find(p => p.id === assignment.propertyId);
            const block = property ? blocks.find(b => b.id === property.blockId) : null;
            const tenant = assignment.tenant || assignment.tenants?.[0];

            upcomingSheet.getCell(row, 1).value = 'Lease Expiration';
            upcomingSheet.getCell(row, 1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFF3CD' } };
            upcomingSheet.getCell(row, 2).value = block?.name || '';
            upcomingSheet.getCell(row, 3).value = property?.name || '';
            upcomingSheet.getCell(row, 4).value = tenant?.fullName || 'Unknown Tenant';
            upcomingSheet.getCell(row, 5).value = leaseEnd.toLocaleDateString();
            upcomingSheet.getCell(row, 6).value = daysUntil;
            upcomingSheet.getCell(row, 6).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFF3CD' } };
            upcomingSheet.getCell(row, 7).value = `Monthly Rent: ${assignment.monthlyRent || 'N/A'}`;

            for (let col = 1; col <= 7; col++) {
              Object.assign(upcomingSheet.getCell(row, col), cellStyle);
            }
            row++;
          }
        }
      });

      // Validate workbook has sheets
      if (workbook.worksheets.length === 0) {
        throw new Error("Workbook has no worksheets");
      }

      // Generate Excel buffer
      let buffer: Buffer;
      try {
        const result = await workbook.xlsx.writeBuffer();
        // ExcelJS writeBuffer returns a Buffer or ArrayBuffer depending on environment
        if (Buffer.isBuffer(result)) {
          buffer = result;
        } else if (result instanceof ArrayBuffer) {
          buffer = Buffer.from(result);
        } else {
          buffer = Buffer.from(result as any);
        }
      } catch (writeError: any) {
        console.error("Error writing Excel buffer:", writeError);
        throw new Error(`Failed to generate Excel file buffer: ${writeError.message || writeError}`);
      }

      if (!buffer || buffer.length === 0) {
        throw new Error("Generated Excel buffer is empty");
      }

      console.log(`Excel report generated successfully: ${buffer.length} bytes, ${workbook.worksheets.length} sheets`);

      res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
      res.setHeader('Content-Disposition', `attachment; filename="comprehensive-report-${new Date().toISOString().split('T')[0]}.xlsx"`);
      res.setHeader('Content-Length', buffer.length.toString());
      res.setHeader('Cache-Control', 'no-cache');
      res.send(buffer);
    } catch (error: any) {
      console.error("Error generating comprehensive Excel report:", error);
      res.status(500).json({ message: error.message || "Failed to generate Excel report" });
    }
  });

  // ==================== FEEDBACK SYSTEM ROUTES ====================

  // User: Submit feedback
  app.post("/api/feedback", isAuthenticated, async (req: any, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user) {
        return res.status(401).json({ message: "User not found" });
      }

      const { title, description, priority, category } = req.body;

      if (!title || !description) {
        return res.status(400).json({ message: "Title and description are required" });
      }

      let organizationName = null;
      if (user.organizationId) {
        const org = await storage.getOrganization(user.organizationId);
        organizationName = org?.name;
      }

      const feedback = await storage.createFeedback({
        title,
        description,
        priority: priority || "medium",
        category: category || "feature",
        userId: user.id,
        userEmail: user.email,
        userName: `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.username,
        organizationId: user.organizationId || null,
        organizationName,
      });

      // Send notification emails to central team
      try {
        const teamConfig = await storage.getCentralTeamConfig();
        const activeEmails = teamConfig.filter(c => c.isActive).map(c => c.notificationEmail);

        if (activeEmails.length > 0) {
          const { sendEmail } = await import("./resend");
          const priorityLabel = priority === "high" ? "HIGH" : priority === "medium" ? "Medium" : "Low";
          const categoryLabel = category === "bug" ? "Bug Report" : category === "improvement" ? "Improvement" : "Feature Request";

          for (const email of activeEmails) {
            await sendEmail({
              to: email,
              subject: `[${priorityLabel}] New ${categoryLabel}: ${title}`,
              html: `
                <h2>New Feedback Submission</h2>
                <p><strong>Title:</strong> ${title}</p>
                <p><strong>Category:</strong> ${categoryLabel}</p>
                <p><strong>Priority:</strong> ${priorityLabel}</p>
                <p><strong>From:</strong> ${feedback.userName} (${feedback.userEmail})</p>
                <p><strong>Organization:</strong> ${organizationName || 'N/A'}</p>
                <hr />
                <p><strong>Description:</strong></p>
                <p>${description}</p>
                <hr />
                <p><small>View all feedback in the Eco-Admin panel.</small></p>
              `,
            });
          }
        }
      } catch (emailError) {
        console.error("Error sending feedback notification emails:", emailError);
      }

      res.json(feedback);
    } catch (error: any) {
      console.error("Error submitting feedback:", error);
      res.status(500).json({ message: "Failed to submit feedback" });
    }
  });

  // User: Get own feedback submissions
  app.get("/api/feedback/my", isAuthenticated, async (req: any, res) => {
    try {
      const feedback = await storage.getFeedbackByUser(req.user.id);
      res.json(feedback);
    } catch (error: any) {
      console.error("Error fetching user feedback:", error);
      res.status(500).json({ message: "Failed to fetch feedback" });
    }
  });

  // Admin: Get all feedback
  app.get("/api/admin/feedback", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { status, category, priority } = req.query;
      const filters: { status?: string; category?: string; priority?: string } = {};

      if (status && status !== "all") filters.status = status as string;
      if (category && category !== "all") filters.category = category as string;
      if (priority && priority !== "all") filters.priority = priority as string;

      const feedback = await storage.getAllFeedback(filters);
      res.json(feedback);
    } catch (error: any) {
      console.error("Error fetching all feedback:", error);
      res.status(500).json({ message: "Failed to fetch feedback" });
    }
  });

  // Admin: Get single feedback
  app.get("/api/admin/feedback/:id", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const feedback = await storage.getFeedbackById(req.params.id);
      if (!feedback) {
        return res.status(404).json({ message: "Feedback not found" });
      }
      res.json(feedback);
    } catch (error: any) {
      console.error("Error fetching feedback:", error);
      res.status(500).json({ message: "Failed to fetch feedback" });
    }
  });

  // Admin: Update feedback status/assignment
  app.patch("/api/admin/feedback/:id", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { status, assignedTo, assignedDepartment, resolutionNotes } = req.body;
      const updates: any = {};

      if (status) updates.status = status;
      if (assignedTo !== undefined) updates.assignedTo = assignedTo;
      if (assignedDepartment !== undefined) updates.assignedDepartment = assignedDepartment;
      if (resolutionNotes !== undefined) updates.resolutionNotes = resolutionNotes;

      const feedback = await storage.updateFeedback(req.params.id, updates);
      res.json(feedback);
    } catch (error: any) {
      console.error("Error updating feedback:", error);
      res.status(500).json({ message: "Failed to update feedback" });
    }
  });

  // Admin: Get central team config
  app.get("/api/admin/feedback-team", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const team = await storage.getCentralTeamConfig();
      res.json(team);
    } catch (error: any) {
      console.error("Error fetching feedback team:", error);
      res.status(500).json({ message: "Failed to fetch team" });
    }
  });

  // Admin: Add central team email
  app.post("/api/admin/feedback-team", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ message: "Email is required" });
      }

      const config = await storage.addCentralTeamEmail(email);
      res.json(config);
    } catch (error: any) {
      console.error("Error adding team email:", error);
      res.status(500).json({ message: "Failed to add team email" });
    }
  });

  // Admin: Update central team email status
  app.patch("/api/admin/feedback-team/:id", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      const { isActive } = req.body;
      const config = await storage.updateCentralTeamEmail(req.params.id, isActive);
      res.json(config);
    } catch (error: any) {
      console.error("Error updating team email:", error);
      res.status(500).json({ message: "Failed to update team email" });
    }
  });

  // Admin: Remove central team email
  app.delete("/api/admin/feedback-team/:id", isAuthenticated, async (req: any, res) => {
    try {
      const adminUser = await storage.getAdminByEmail(req.user.email);
      if (!adminUser) {
        return res.status(403).json({ message: "Access denied" });
      }

      await storage.removeCentralTeamEmail(req.params.id);
      res.json({ success: true });
    } catch (error: any) {
      console.error("Error removing team email:", error);
      res.status(500).json({ message: "Failed to remove team email" });
    }
  });

  // ==================== NOTIFICATION ROUTES ====================

  // Get notifications for current user
  app.get("/api/notifications", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const unreadOnly = req.query.unreadOnly === "true";

      const notifications = await storage.getNotificationsByUser(userId, unreadOnly);
      res.json(notifications);
    } catch (error: any) {
      console.error("Error fetching notifications:", error);
      res.status(500).json({ message: "Failed to fetch notifications" });
    }
  });

  // Get unread notification count
  app.get("/api/notifications/unread-count", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const count = await storage.getUnreadNotificationCount(userId);
      res.json({ count });
    } catch (error: any) {
      console.error("Error fetching unread count:", error);
      res.status(500).json({ message: "Failed to fetch unread count" });
    }
  });

  // Mark notification as read
  app.patch("/api/notifications/:id/read", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;
      const notificationId = req.params.id;

      // Verify notification belongs to user
      const notifications = await storage.getNotificationsByUser(userId);
      const notification = notifications.find(n => n.id === notificationId);

      if (!notification) {
        return res.status(404).json({ message: "Notification not found" });
      }

      const updated = await storage.markNotificationAsRead(notificationId);

      // Update unread count via WebSocket
      const unreadCount = await storage.getUnreadNotificationCount(userId);
      const { updateUnreadCount } = await import("./websocket");
      updateUnreadCount(userId, unreadCount);

      res.json(updated);
    } catch (error: any) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ message: "Failed to mark notification as read" });
    }
  });

  // Mark all notifications as read
  app.patch("/api/notifications/read-all", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.id;

      await storage.markAllNotificationsAsRead(userId);

      // Update unread count via WebSocket
      const { updateUnreadCount } = await import("./websocket");
      updateUnreadCount(userId, 0);

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error marking all notifications as read:", error);
      res.status(500).json({ message: "Failed to mark all notifications as read" });
    }
  });

  // ==================== EXCEL IMPORT ROUTES ====================

  // Download Excel template for entity type
  app.get("/api/imports/templates/:entity", isAuthenticated, async (req: any, res) => {
    try {
      const { entity } = req.params;
      const XLSX = await import("xlsx");

      let headers: string[] = [];
      let exampleRow: any[] = [];
      let filename = "";

      switch (entity) {
        case "tenants":
          headers = ["firstName*", "lastName*", "email*", "phone", "propertyName", "leaseStartDate", "leaseEndDate", "notes"];
          exampleRow = ["John", "Doe", "john.doe@example.com", "+44 7123 456789", "Flat 1A, Oak House", "2024-01-01", "2025-01-01", "Example tenant notes"];
          filename = "tenants_import_template.xlsx";
          break;
        case "properties":
          headers = ["name*", "address*", "blockName", "propertyType", "sqft", "notes"];
          exampleRow = ["Flat 1A", "123 High Street, London, SW1A 1AA", "Oak House", "apartment", "850", "Ground floor unit"];
          filename = "properties_import_template.xlsx";
          break;
        case "blocks":
          headers = ["name*", "address*", "totalUnits", "notes"];
          exampleRow = ["Oak House", "100 High Street, London, SW1A 1AA", "24", "Main residential block"];
          filename = "blocks_import_template.xlsx";
          break;
        case "assets":
          headers = ["propertyName*", "name*", "category", "location", "condition*", "cleanliness", "serialNumber", "modelNumber", "supplier", "purchasePrice", "notes"];
          exampleRow = ["Flat 1A, Oak House", "Samsung Refrigerator", "Appliances", "Kitchen", "5", "5", "RF123456", "RS27T5200SR", "Currys", "799.99", "Under warranty"];
          filename = "assets_import_template.xlsx";
          break;
        default:
          return res.status(400).json({ message: "Invalid entity type. Valid types: tenants, properties, blocks, assets" });
      }

      const ws = XLSX.utils.aoa_to_sheet([headers, exampleRow]);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Import Data");

      // Add instructions sheet
      const instructions = [
        ["Import Instructions"],
        [""],
        ["1. Fields marked with * are required"],
        ["2. Delete the example row before importing your data"],
        ["3. Dates should be in YYYY-MM-DD format"],
        ["4. Condition and cleanliness ratings: 1=Very Poor, 2=Poor, 3=Fair, 4=Good, 5=Excellent"],
        ["5. Property and block names must match existing records exactly (for reference fields)"],
        ["6. Email addresses must be unique for tenant imports"],
      ];
      const wsInstructions = XLSX.utils.aoa_to_sheet(instructions);
      XLSX.utils.book_append_sheet(wb, wsInstructions, "Instructions");

      const buffer = XLSX.write(wb, { type: "buffer", bookType: "xlsx" });

      res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
      res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
      res.send(buffer);
    } catch (error: any) {
      console.error("Error generating template:", error);
      res.status(500).json({ message: "Failed to generate template" });
    }
  });

  // Validate and preview Excel import
  app.post("/api/imports/:entity/validate", isAuthenticated, upload.single("file"), async (req: any, res) => {
    try {
      const { entity } = req.params;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }

      const XLSX = await import("xlsx");
      const workbook = XLSX.read(req.file.buffer, { type: "buffer" });
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      const data: any[][] = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

      if (data.length < 2) {
        return res.status(400).json({ message: "File must have at least a header row and one data row" });
      }

      const headers = data[0].map((h: string) => String(h).replace("*", "").trim().toLowerCase());
      const rows = data.slice(1).filter((row: any[]) => row.some(cell => cell !== undefined && cell !== ""));

      const validRows: any[] = [];
      const errors: { row: number; column: string; message: string }[] = [];

      // Get existing data for reference validation
      const existingProperties = await storage.getPropertiesByOrganization(user.organizationId);
      const existingBlocks = await storage.getBlocksByOrganization(user.organizationId);

      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        const rowNum = i + 2; // Account for 0-index and header row
        const rowData: any = {};

        // Map row values to headers
        headers.forEach((header: string, idx: number) => {
          rowData[header] = row[idx];
        });

        let hasError = false;

        switch (entity) {
          case "tenants":
            if (!rowData.firstname) {
              errors.push({ row: rowNum, column: "firstName", message: "First name is required" });
              hasError = true;
            }
            if (!rowData.lastname) {
              errors.push({ row: rowNum, column: "lastName", message: "Last name is required" });
              hasError = true;
            }
            if (!rowData.email) {
              errors.push({ row: rowNum, column: "email", message: "Email is required" });
              hasError = true;
            } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(rowData.email)) {
              errors.push({ row: rowNum, column: "email", message: "Invalid email format" });
              hasError = true;
            }
            if (rowData.propertyname) {
              const prop = existingProperties.find((p: any) =>
                p.name.toLowerCase() === rowData.propertyname.toLowerCase()
              );
              if (!prop) {
                errors.push({ row: rowNum, column: "propertyName", message: `Property "${rowData.propertyname}" not found` });
                hasError = true;
              } else {
                rowData.propertyId = prop.id;
              }
            }
            break;

          case "properties":
            if (!rowData.name) {
              errors.push({ row: rowNum, column: "name", message: "Property name is required" });
              hasError = true;
            }
            if (!rowData.address) {
              errors.push({ row: rowNum, column: "address", message: "Address is required" });
              hasError = true;
            }
            if (rowData.blockname) {
              const block = existingBlocks.find((b: any) =>
                b.name.toLowerCase() === rowData.blockname.toLowerCase()
              );
              if (!block) {
                errors.push({ row: rowNum, column: "blockName", message: `Block "${rowData.blockname}" not found` });
                hasError = true;
              } else {
                rowData.blockId = block.id;
              }
            }
            break;

          case "blocks":
            if (!rowData.name) {
              errors.push({ row: rowNum, column: "name", message: "Block name is required" });
              hasError = true;
            }
            if (!rowData.address) {
              errors.push({ row: rowNum, column: "address", message: "Address is required" });
              hasError = true;
            }
            break;

          case "assets":
            if (!rowData.propertyname) {
              errors.push({ row: rowNum, column: "propertyName", message: "Property name is required" });
              hasError = true;
            } else {
              const prop = existingProperties.find((p: any) =>
                p.name.toLowerCase() === rowData.propertyname.toLowerCase()
              );
              if (!prop) {
                errors.push({ row: rowNum, column: "propertyName", message: `Property "${rowData.propertyname}" not found` });
                hasError = true;
              } else {
                rowData.propertyId = prop.id;
              }
            }
            if (!rowData.name) {
              errors.push({ row: rowNum, column: "name", message: "Asset name is required" });
              hasError = true;
            }
            if (!rowData.condition || !["1", "2", "3", "4", "5"].includes(String(rowData.condition))) {
              errors.push({ row: rowNum, column: "condition", message: "Condition must be 1-5" });
              hasError = true;
            }
            break;
        }

        if (!hasError) {
          validRows.push({ rowNum, data: rowData });
        }
      }

      res.json({
        totalRows: rows.length,
        validRows: validRows.length,
        errorCount: errors.length,
        errors: errors.slice(0, 100), // Limit to first 100 errors
        preview: validRows.slice(0, 10), // Preview first 10 valid rows
      });
    } catch (error: any) {
      console.error("Error validating import:", error);
      res.status(500).json({ message: "Failed to validate import file" });
    }
  });

  // Commit Excel import
  app.post("/api/imports/:entity/commit", isAuthenticated, upload.single("file"), async (req: any, res) => {
    try {
      const { entity } = req.params;
      const userId = req.user.id;
      const user = await storage.getUser(userId);

      if (!user?.organizationId) {
        return res.status(403).json({ message: "User not in organization" });
      }

      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      }

      const XLSX = await import("xlsx");
      const workbook = XLSX.read(req.file.buffer, { type: "buffer" });
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      const data: any[][] = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

      const headers = data[0].map((h: string) => String(h).replace("*", "").trim().toLowerCase());
      const rows = data.slice(1).filter((row: any[]) => row.some(cell => cell !== undefined && cell !== ""));

      const existingProperties = await storage.getPropertiesByOrganization(user.organizationId);
      const existingBlocks = await storage.getBlocksByOrganization(user.organizationId);

      let successCount = 0;
      let errorCount = 0;
      const errors: { row: number; message: string }[] = [];

      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        const rowNum = i + 2;
        const rowData: any = {};

        headers.forEach((header: string, idx: number) => {
          rowData[header] = row[idx];
        });

        try {
          switch (entity) {
            case "tenants":
              if (!rowData.firstname || !rowData.lastname || !rowData.email) {
                throw new Error("Missing required fields");
              }

              // Create tenant user
              const bcrypt = await import("bcryptjs");
              const tempPassword = await bcrypt.hash("TempPassword123!", 10);
              const tenantUser = await storage.createUser({
                username: rowData.email,
                email: rowData.email,
                password: tempPassword,
                firstName: rowData.firstname,
                lastName: rowData.lastname,
                phone: rowData.phone || null,
                role: "tenant",
                organizationId: user.organizationId,
                isActive: true,
                onboardingCompleted: false,
              });

              // Create tenant assignment if property specified
              if (rowData.propertyid) {
                await storage.createTenantAssignment({
                  organizationId: user.organizationId,
                  tenantId: tenantUser.id,
                  propertyId: rowData.propertyid,
                  leaseStartDate: rowData.leasestartdate ? new Date(rowData.leasestartdate) : null,
                  leaseEndDate: rowData.leaseenddate ? new Date(rowData.leaseenddate) : null,
                  notes: rowData.notes || null,
                  isActive: true,
                });
              }
              successCount++;
              break;

            case "properties":
              if (!rowData.name || !rowData.address) {
                throw new Error("Missing required fields");
              }

              let blockId = null;
              if (rowData.blockname) {
                const block = existingBlocks.find((b: any) =>
                  b.name.toLowerCase() === rowData.blockname.toLowerCase()
                );
                if (block) blockId = block.id;
              }

              await storage.createProperty({
                organizationId: user.organizationId,
                name: rowData.name,
                address: rowData.address,
                blockId,
                propertyType: rowData.propertytype || null,
                sqft: rowData.sqft ? parseInt(rowData.sqft) : null,
              });
              successCount++;
              break;

            case "blocks":
              if (!rowData.name || !rowData.address) {
                throw new Error("Missing required fields");
              }

              await storage.createBlock({
                organizationId: user.organizationId,
                name: rowData.name,
                address: rowData.address,
                notes: rowData.notes || null,
              });
              successCount++;
              break;

            case "assets":
              if (!rowData.name || !rowData.condition) {
                throw new Error("Missing required fields");
              }

              let assetPropertyId = null;
              if (rowData.propertyname) {
                const prop = existingProperties.find((p: any) =>
                  p.name.toLowerCase() === rowData.propertyname.toLowerCase()
                );
                if (prop) assetPropertyId = prop.id;
              }

              const conditionMap: { [key: string]: string } = {
                "1": "very_poor", "2": "poor", "3": "fair", "4": "good", "5": "excellent"
              };
              const cleanlinessMap: { [key: string]: string } = {
                "1": "very_dirty", "2": "dirty", "3": "acceptable", "4": "clean", "5": "spotless"
              };

              await storage.createAssetInventory({
                organizationId: user.organizationId,
                propertyId: assetPropertyId,
                name: rowData.name,
                category: rowData.category || null,
                location: rowData.location || null,
                condition: (conditionMap[String(rowData.condition)] as any) || ("fair" as const),
                cleanliness: rowData.cleanliness ? (cleanlinessMap[String(rowData.cleanliness)] as any) : null,
                serialNumber: rowData.serialnumber || null,
                modelNumber: rowData.modelnumber || null,
                supplier: rowData.supplier || null,
                purchasePrice: rowData.purchaseprice ? String(rowData.purchaseprice) : null,
                description: rowData.notes || null,
              });
              successCount++;
              break;
          }
        } catch (err: any) {
          errorCount++;
          errors.push({ row: rowNum, message: err.message });
        }
      }

      res.json({
        success: true,
        imported: successCount,
        failed: errorCount,
        errors: errors.slice(0, 50),
      });
    } catch (error: any) {
      console.error("Error committing import:", error);
      res.status(500).json({ message: "Failed to import data" });
    }
  });

  // ==================== COMMUNITY DISCUSSION ROUTES ====================

  // Get community rules for tenant
  app.get("/api/tenant-portal/community/rules", async (req, res) => {
    if (!req.isAuthenticated() || req.user?.role !== "tenant") {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const tenancy = await storage.getTenancyByTenantId(user.id);
      if (!tenancy) {
        return res.status(404).json({ message: "Tenant assignment not found" });
      }

      const rules = await storage.getCommunityRules(tenancy.organizationId);
      const hasAccepted = await storage.hasAcceptedLatestRules(user.id, tenancy.organizationId);

      res.json({
        rules: rules?.rulesText || null,
        version: rules?.version || 0,
        hasAccepted,
      });
    } catch (error: any) {
      console.error("Error fetching community rules:", error);
      res.status(500).json({ message: "Failed to fetch community rules" });
    }
  });

  // Accept community rules
  app.post("/api/tenant-portal/community/rules/accept", async (req, res) => {
    if (!req.isAuthenticated() || req.user?.role !== "tenant") {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const tenancy = await storage.getTenancyByTenantId(user.id);
      if (!tenancy) {
        return res.status(404).json({ message: "Tenant assignment not found" });
      }

      const currentVersion = await storage.getActiveRuleVersion(tenancy.organizationId);
      if (currentVersion === 0) {
        return res.status(400).json({ message: "No community rules configured" });
      }

      await storage.acceptCommunityRules({
        tenantId: user.id,
        organizationId: tenancy.organizationId,
        ruleVersion: currentVersion,
      });

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error accepting community rules:", error);
      res.status(500).json({ message: "Failed to accept community rules" });
    }
  });

  // Get community groups for tenant's block
  app.get("/api/tenant-portal/community/groups", async (req, res) => {
    if (!req.isAuthenticated() || req.user?.role !== "tenant") {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const tenancy = await storage.getTenancyByTenantId(user.id);

      // If tenant has no block assignment, return empty array (not an error)
      if (!tenancy || !tenancy.blockId) {
        console.log(`[Community] Tenant ${user.id} has no block assignment`);
        return res.json([]);
      }

      // Only show approved groups to tenants
      const groups = await storage.getCommunityGroups(tenancy.blockId, "approved");

      // Add membership status for each group
      const groupsWithMembership = await Promise.all(groups.map(async (group) => ({
        ...group,
        isMember: await storage.isGroupMember(group.id, user.id),
      })));

      res.json(groupsWithMembership);
    } catch (error: any) {
      console.error("Error fetching community groups:", error);
      res.status(500).json({ message: "Failed to fetch community groups" });
    }
  });

  // Get a single community group
  app.get("/api/tenant-portal/community/groups/:id", async (req, res) => {
    if (!req.isAuthenticated() || req.user?.role !== "tenant") {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const group = await storage.getCommunityGroup(req.params.id);
      if (!group) {
        return res.status(404).json({ message: "Group not found" });
      }

      // Verify tenant has access to this block
      const tenancy = await storage.getTenancyByTenantId(user.id);
      if (!tenancy || tenancy.blockId !== group.blockId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const isMember = await storage.isGroupMember(group.id, user.id);
      res.json({ ...group, isMember });
    } catch (error: any) {
      console.error("Error fetching community group:", error);
      res.status(500).json({ message: "Failed to fetch community group" });
    }
  });

  // Create a new community group (requires rule acceptance)
  app.post("/api/tenant-portal/community/groups", async (req, res) => {
    if (!req.isAuthenticated() || req.user?.role !== "tenant") {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const tenancy = await storage.getTenancyByTenantId(user.id);
      if (!tenancy || !tenancy.blockId) {
        return res.status(404).json({ message: "Block assignment not found" });
      }

      // Check if user has accepted latest rules
      const hasAccepted = await storage.hasAcceptedLatestRules(user.id, tenancy.organizationId);
      if (!hasAccepted) {
        return res.status(403).json({ message: "You must accept community rules before creating a group" });
      }

      const ruleVersion = await storage.getActiveRuleVersion(tenancy.organizationId);

      // Get organization for logo
      const organization = await storage.getOrganization(tenancy.organizationId);

      const group = await storage.createCommunityGroup({
        organizationId: tenancy.organizationId,
        blockId: tenancy.blockId,
        name: req.body.name,
        description: req.body.description || null,
        coverImageUrl: null, // Will be updated with AI-generated banner
        createdBy: user.id,
        ruleVersionAgreedAt: ruleVersion || undefined,
        status: "pending", // Requires operator approval
      });

      // Auto-join creator to the group
      await storage.joinGroup({ groupId: group.id, tenantId: user.id });

      // Automatically add all active tenants from this block to the community group
      // Note: This happens even for pending groups, so when approved, all tenants are already members
      try {
        const tenantAssignments = await storage.getTenantAssignmentsByBlock(tenancy.blockId);
        const activeTenants = tenantAssignments
          .filter(ta => ta.assignment.isActive === true)
          .map(ta => ta.user.id);

        // Add each active tenant to the group (skip if already a member, including creator)
        for (const tenantId of activeTenants) {
          const isMember = await storage.isGroupMember(group.id, tenantId);
          if (!isMember) {
            await storage.joinGroup({ groupId: group.id, tenantId });
          }
        }
        console.log(`[Community] Auto-added ${activeTenants.length} active tenants to pending group ${group.id}`);
      } catch (error) {
        console.error(`[Community] Error auto-adding tenants to group ${group.id}:`, error);
        // Don't fail the request if auto-adding tenants fails
      }

      // Generate AI banner in the background (don't block the response)
      const objectStorageService = new ObjectStorageService();
      generateGroupBanner(
        req.body.name,
        req.body.description || null,
        organization?.logoUrl || null,
        objectStorageService
      ).then(async (bannerUrl) => {
        if (bannerUrl) {
          await storage.updateCommunityGroup(group.id, { coverImageUrl: bannerUrl });
          console.log(`[BannerGen] Updated group ${group.id} with banner: ${bannerUrl}`);
        }
      }).catch((error) => {
        console.error(`[BannerGen] Failed to generate banner for group ${group.id}:`, error);
      });

      res.status(201).json(group);
    } catch (error: any) {
      console.error("Error creating community group:", error);
      res.status(500).json({ message: "Failed to create community group" });
    }
  });

  // Join a community group
  app.post("/api/tenant-portal/community/groups/:id/join", async (req, res) => {
    if (!req.isAuthenticated() || req.user?.role !== "tenant") {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const group = await storage.getCommunityGroup(req.params.id);
      if (!group || group.status !== "approved") {
        return res.status(404).json({ message: "Group not found" });
      }

      const tenancy = await storage.getTenancyByTenantId(user.id);
      if (!tenancy || tenancy.blockId !== group.blockId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const hasAccepted = await storage.hasAcceptedLatestRules(user.id, tenancy.organizationId);
      if (!hasAccepted) {
        return res.status(403).json({ message: "You must accept community rules first" });
      }

      const isAlreadyMember = await storage.isGroupMember(group.id, user.id);
      if (isAlreadyMember) {
        return res.status(400).json({ message: "Already a member" });
      }

      await storage.joinGroup({ groupId: group.id, tenantId: user.id });
      res.json({ success: true });
    } catch (error: any) {
      console.error("Error joining group:", error);
      res.status(500).json({ message: "Failed to join group" });
    }
  });

  // Leave a community group
  app.post("/api/tenant-portal/community/groups/:id/leave", async (req, res) => {
    if (!req.isAuthenticated() || req.user?.role !== "tenant") {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      await storage.leaveGroup(req.params.id, user.id);
      res.json({ success: true });
    } catch (error: any) {
      console.error("Error leaving group:", error);
      res.status(500).json({ message: "Failed to leave group" });
    }
  });

  // Get threads in a group
  app.get("/api/tenant-portal/community/groups/:id/threads", async (req, res) => {
    if (!req.isAuthenticated() || req.user?.role !== "tenant") {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const group = await storage.getCommunityGroup(req.params.id);
      if (!group || group.status !== "approved") {
        return res.status(404).json({ message: "Group not found" });
      }

      const tenancy = await storage.getTenancyByTenantId(user.id);
      if (!tenancy || tenancy.blockId !== group.blockId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const threads = await storage.getCommunityThreads(group.id);

      // Filter out hidden/removed threads for regular tenants, get creator info
      const visibleThreads = threads.filter(t => t.status === "visible" || t.createdBy === user.id);

      // Get user info for each thread creator
      const threadsWithCreators = await Promise.all(visibleThreads.map(async (thread) => {
        const creator = await storage.getUser(thread.createdBy);
        return {
          ...thread,
          creatorName: creator ? `${creator.firstName || ''} ${creator.lastName || ''}`.trim() || creator.username : 'Unknown',
        };
      }));

      res.json(threadsWithCreators);
    } catch (error: any) {
      console.error("Error fetching threads:", error);
      res.status(500).json({ message: "Failed to fetch threads" });
    }
  });

  // Get a single thread with its posts
  app.get("/api/tenant-portal/community/threads/:id", async (req, res) => {
    if (!req.isAuthenticated() || req.user?.role !== "tenant") {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const thread = await storage.getCommunityThread(req.params.id);
      if (!thread) {
        return res.status(404).json({ message: "Thread not found" });
      }

      const group = await storage.getCommunityGroup(thread.groupId);
      if (!group || group.status !== "approved") {
        return res.status(404).json({ message: "Group not found" });
      }

      const tenancy = await storage.getTenancyByTenantId(user.id);
      if (!tenancy || tenancy.blockId !== group.blockId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Increment view count
      await storage.incrementThreadViewCount(thread.id);

      // Get posts
      const posts = await storage.getCommunityPosts(thread.id);
      const visiblePosts = posts.filter(p => p.status === "visible" || p.createdBy === user.id);

      // Get attachments
      const threadAttachments = await storage.getThreadAttachments(thread.id);

      // Get user info for thread creator
      const creator = await storage.getUser(thread.createdBy);

      // Get user info and attachments for each post
      const postsWithDetails = await Promise.all(visiblePosts.map(async (post) => {
        const postCreator = await storage.getUser(post.createdBy);
        const postAttachments = await storage.getPostAttachments(post.id);
        return {
          ...post,
          creatorName: postCreator ? `${postCreator.firstName || ''} ${postCreator.lastName || ''}`.trim() || postCreator.username : 'Unknown',
          attachments: postAttachments,
        };
      }));

      res.json({
        ...thread,
        creatorName: creator ? `${creator.firstName || ''} ${creator.lastName || ''}`.trim() || creator.username : 'Unknown',
        attachments: threadAttachments,
        posts: postsWithDetails,
        group,
      });
    } catch (error: any) {
      console.error("Error fetching thread:", error);
      res.status(500).json({ message: "Failed to fetch thread" });
    }
  });

  // Create a new thread
  app.post("/api/tenant-portal/community/groups/:id/threads", async (req, res) => {
    if (!req.isAuthenticated() || req.user?.role !== "tenant") {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const group = await storage.getCommunityGroup(req.params.id);
      if (!group || group.status !== "approved") {
        return res.status(404).json({ message: "Group not found" });
      }

      const tenancy = await storage.getTenancyByTenantId(user.id);
      if (!tenancy || tenancy.blockId !== group.blockId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const hasAccepted = await storage.hasAcceptedLatestRules(user.id, tenancy.organizationId);
      if (!hasAccepted) {
        return res.status(403).json({ message: "You must accept community rules first" });
      }

      // Check if tenant is blocked from community
      const isBlocked = await storage.isTenantBlocked(tenancy.organizationId, user.id);
      if (isBlocked) {
        return res.status(403).json({ message: "You have been blocked from participating in the community" });
      }

      // Must be a member to post
      const isMember = await storage.isGroupMember(group.id, user.id);
      if (!isMember) {
        return res.status(403).json({ message: "You must join the group to post" });
      }

      const thread = await storage.createCommunityThread({
        groupId: group.id,
        title: req.body.title,
        content: req.body.content,
        createdBy: user.id,
      });

      // Handle attachments
      if (req.body.attachments && Array.isArray(req.body.attachments)) {
        for (const attachment of req.body.attachments) {
          await storage.createCommunityAttachment({
            threadId: thread.id,
            fileUrl: attachment.fileUrl,
            fileName: attachment.fileName,
            mimeType: attachment.mimeType,
            fileSize: attachment.fileSize,
          });
        }
      }

      res.status(201).json(thread);
    } catch (error: any) {
      console.error("Error creating thread:", error);
      res.status(500).json({ message: "Failed to create thread" });
    }
  });

  // Create a post (reply) in a thread
  app.post("/api/tenant-portal/community/threads/:id/posts", async (req, res) => {
    if (!req.isAuthenticated() || req.user?.role !== "tenant") {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const thread = await storage.getCommunityThread(req.params.id);
      if (!thread || thread.isLocked) {
        return res.status(404).json({ message: "Thread not found or locked" });
      }

      const group = await storage.getCommunityGroup(thread.groupId);
      if (!group || group.status !== "approved") {
        return res.status(404).json({ message: "Group not found" });
      }

      const tenancy = await storage.getTenancyByTenantId(user.id);
      if (!tenancy || tenancy.blockId !== group.blockId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const hasAccepted = await storage.hasAcceptedLatestRules(user.id, tenancy.organizationId);
      if (!hasAccepted) {
        return res.status(403).json({ message: "You must accept community rules first" });
      }

      // Check if tenant is blocked from community
      const isBlocked = await storage.isTenantBlocked(tenancy.organizationId, user.id);
      if (isBlocked) {
        return res.status(403).json({ message: "You have been blocked from participating in the community" });
      }

      const isMember = await storage.isGroupMember(group.id, user.id);
      if (!isMember) {
        return res.status(403).json({ message: "You must join the group to post" });
      }

      const post = await storage.createCommunityPost({
        threadId: thread.id,
        content: req.body.content,
        createdBy: user.id,
      });

      // Handle attachments
      if (req.body.attachments && Array.isArray(req.body.attachments)) {
        for (const attachment of req.body.attachments) {
          await storage.createCommunityAttachment({
            postId: post.id,
            fileUrl: attachment.fileUrl,
            fileName: attachment.fileName,
            mimeType: attachment.mimeType,
            fileSize: attachment.fileSize,
          });
        }
      }

      res.status(201).json(post);
    } catch (error: any) {
      console.error("Error creating post:", error);
      res.status(500).json({ message: "Failed to create post" });
    }
  });

  // Flag content
  app.post("/api/tenant-portal/community/flag", async (req, res) => {
    if (!req.isAuthenticated() || req.user?.role !== "tenant") {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const { threadId, postId, reason, details } = req.body;

      if (!threadId && !postId) {
        return res.status(400).json({ message: "Must specify threadId or postId" });
      }

      await storage.createCommunityFlag({
        threadId: threadId || undefined,
        postId: postId || undefined,
        flaggedBy: user.id,
        reason,
        details: details || undefined,
      });

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error flagging content:", error);
      res.status(500).json({ message: "Failed to flag content" });
    }
  });

  // ==================== OPERATOR COMMUNITY MODERATION ROUTES ====================

  // Get/update community rules (operator)
  app.get("/api/community/rules", async (req, res) => {
    if (!req.isAuthenticated() || !["owner", "clerk"].includes(req.user?.role || "")) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const rules = await storage.getCommunityRules(user.organizationId!);
      res.json(rules || null);
    } catch (error: any) {
      console.error("Error fetching community rules:", error);
      res.status(500).json({ message: "Failed to fetch community rules" });
    }
  });

  app.post("/api/community/rules", async (req, res) => {
    if (!req.isAuthenticated() || req.user?.role !== "owner") {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const rules = await storage.createCommunityRules({
        organizationId: user.organizationId!,
        rulesText: req.body.rulesText,
        createdBy: user.id,
      });
      res.status(201).json(rules);
    } catch (error: any) {
      console.error("Error creating community rules:", error);
      res.status(500).json({ message: "Failed to create community rules" });
    }
  });

  // Get pending groups count for operator dashboard
  app.get("/api/community/pending-count", async (req, res) => {
    if (!req.isAuthenticated() || !["owner", "clerk"].includes(req.user?.role || "")) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const count = await storage.getPendingGroupsCount(user.organizationId!);
      res.json({ count });
    } catch (error: any) {
      console.error("Error fetching pending count:", error);
      res.status(500).json({ message: "Failed to fetch pending count" });
    }
  });

  // Get all groups for moderation (operator)
  app.get("/api/community/groups", async (req, res) => {
    if (!req.isAuthenticated() || !["owner", "clerk"].includes(req.user?.role || "")) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const status = req.query.status as string | undefined;
      const groups = await storage.getCommunityGroupsByOrganization(user.organizationId!, status);

      // Get block names and creator info
      const groupsWithDetails = await Promise.all(groups.map(async (group) => {
        const block = await storage.getBlock(group.blockId);
        const creator = await storage.getUser(group.createdBy);
        return {
          ...group,
          blockName: block?.name || 'Unknown',
          creatorName: creator ? `${creator.firstName || ''} ${creator.lastName || ''}`.trim() || creator.username : 'Unknown',
        };
      }));

      res.json(groupsWithDetails);
    } catch (error: any) {
      console.error("Error fetching groups:", error);
      res.status(500).json({ message: "Failed to fetch groups" });
    }
  });

  // Approve/reject a group (operator)
  app.patch("/api/community/groups/:id", async (req, res) => {
    if (!req.isAuthenticated() || !["owner", "clerk"].includes(req.user?.role || "")) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const group = await storage.getCommunityGroup(req.params.id);
      if (!group || group.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Group not found" });
      }

      const updates: any = {};
      if (req.body.status) {
        updates.status = req.body.status;
        if (req.body.status === 'approved') {
          updates.approvedBy = user.id;
        }
        if (req.body.status === 'rejected' && req.body.rejectionReason) {
          updates.rejectionReason = req.body.rejectionReason;
        }
      }

      const updated = await storage.updateCommunityGroup(req.params.id, updates);

      // When approving a group, ensure all active tenants from the block are members
      if (req.body.status === 'approved') {
        try {
          const tenantAssignments = await storage.getTenantAssignmentsByBlock(group.blockId);
          const activeTenants = tenantAssignments
            .filter(ta => ta.assignment.isActive === true)
            .map(ta => ta.user.id);

          // Add each active tenant to the group (skip if already a member)
          for (const tenantId of activeTenants) {
            const isMember = await storage.isGroupMember(group.id, tenantId);
            if (!isMember) {
              await storage.joinGroup({ groupId: group.id, tenantId });
            }
          }
          console.log(`[Community] Auto-added ${activeTenants.length} active tenants to approved group ${group.id}`);
        } catch (error) {
          console.error(`[Community] Error auto-adding tenants to approved group ${group.id}:`, error);
          // Don't fail the request if auto-adding tenants fails
        }
      }

      // Log moderation action
      await storage.createCommunityModerationLog({
        organizationId: user.organizationId!,
        moderatorId: user.id,
        action: req.body.status === 'approved' ? 'approved' : 'rejected',
        targetType: 'group',
        targetId: group.id,
        reason: req.body.rejectionReason || null,
      });

      res.json(updated);
    } catch (error: any) {
      console.error("Error updating group:", error);
      res.status(500).json({ message: "Failed to update group" });
    }
  });

  // Get flagged content (operator)
  app.get("/api/community/flags", async (req, res) => {
    if (!req.isAuthenticated() || !["owner", "clerk"].includes(req.user?.role || "")) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const unresolvedOnly = req.query.unresolved !== 'false';
      const flags = await storage.getCommunityFlags(user.organizationId!, unresolvedOnly);

      // Get content details for each flag
      const flagsWithDetails = await Promise.all(flags.map(async (flag) => {
        let content = null;
        if (flag.threadId) {
          const thread = await storage.getCommunityThread(flag.threadId);
          content = { type: 'thread', title: thread?.title, content: thread?.content };
        } else if (flag.postId) {
          const post = await storage.getCommunityPost(flag.postId);
          content = { type: 'post', content: post?.content };
        }

        const reporter = await storage.getUser(flag.flaggedBy);
        return {
          ...flag,
          content,
          reporterName: reporter ? `${reporter.firstName || ''} ${reporter.lastName || ''}`.trim() || reporter.username : 'Unknown',
        };
      }));

      res.json(flagsWithDetails);
    } catch (error: any) {
      console.error("Error fetching flags:", error);
      res.status(500).json({ message: "Failed to fetch flags" });
    }
  });

  // Resolve a flag (operator)
  app.post("/api/community/flags/:id/resolve", async (req, res) => {
    if (!req.isAuthenticated() || !["owner", "clerk"].includes(req.user?.role || "")) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const { action, notes } = req.body;

      const flag = await storage.resolveCommunityFlag(req.params.id, user.id, notes || '');

      // If action is to hide/remove content, update the content status
      if (action === 'hide' || action === 'remove') {
        if (flag.threadId) {
          await storage.updateCommunityThread(flag.threadId, { status: action === 'hide' ? 'hidden' : 'removed' });
        } else if (flag.postId) {
          await storage.updateCommunityPost(flag.postId, { status: action === 'hide' ? 'hidden' : 'removed' });
        }

        // Log moderation action
        await storage.createCommunityModerationLog({
          organizationId: user.organizationId!,
          moderatorId: user.id,
          action: action === 'hide' ? 'hidden' : 'removed',
          targetType: flag.threadId ? 'thread' : 'post',
          targetId: (flag.threadId || flag.postId)!,
          reason: notes || null,
        });
      }

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error resolving flag:", error);
      res.status(500).json({ message: "Failed to resolve flag" });
    }
  });

  // Moderate thread/post directly (operator)
  app.patch("/api/community/threads/:id/moderate", async (req, res) => {
    if (!req.isAuthenticated() || !["owner", "clerk"].includes(req.user?.role || "")) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const { status, isPinned, isLocked, reason } = req.body;

      const thread = await storage.getCommunityThread(req.params.id);
      if (!thread) {
        return res.status(404).json({ message: "Thread not found" });
      }

      const group = await storage.getCommunityGroup(thread.groupId);
      if (!group || group.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const updates: any = {};
      if (status) updates.status = status;
      if (isPinned !== undefined) updates.isPinned = isPinned;
      if (isLocked !== undefined) updates.isLocked = isLocked;

      const updated = await storage.updateCommunityThread(req.params.id, updates);

      // Log moderation action
      if (status) {
        await storage.createCommunityModerationLog({
          organizationId: user.organizationId!,
          moderatorId: user.id,
          action: status === 'hidden' ? 'hidden' : status === 'removed' ? 'removed' : 'restored',
          targetType: 'thread',
          targetId: thread.id,
          reason: reason || null,
        });
      }

      res.json(updated);
    } catch (error: any) {
      console.error("Error moderating thread:", error);
      res.status(500).json({ message: "Failed to moderate thread" });
    }
  });

  app.patch("/api/community/posts/:id/moderate", async (req, res) => {
    if (!req.isAuthenticated() || !["owner", "clerk"].includes(req.user?.role || "")) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const { status, reason } = req.body;

      const post = await storage.getCommunityPost(req.params.id);
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }

      const thread = await storage.getCommunityThread(post.threadId);
      if (!thread) {
        return res.status(404).json({ message: "Thread not found" });
      }

      const group = await storage.getCommunityGroup(thread.groupId);
      if (!group || group.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const updated = await storage.updateCommunityPost(req.params.id, { status });

      // Log moderation action
      await storage.createCommunityModerationLog({
        organizationId: user.organizationId!,
        moderatorId: user.id,
        action: status === 'hidden' ? 'hidden' : status === 'removed' ? 'removed' : 'restored',
        targetType: 'post',
        targetId: post.id,
        reason: reason || null,
      });

      res.json(updated);
    } catch (error: any) {
      console.error("Error moderating post:", error);
      res.status(500).json({ message: "Failed to moderate post" });
    }
  });

  // Operator create group (auto-approved)
  app.post("/api/community/groups", async (req, res) => {
    if (!req.isAuthenticated() || !["owner", "clerk"].includes(req.user?.role || "")) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const { name, description, blockId } = req.body;

      if (!name || !blockId) {
        return res.status(400).json({ message: "Name and block are required" });
      }

      // Verify block belongs to organization
      const block = await storage.getBlock(blockId);
      if (!block || block.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Block not found" });
      }

      // Get organization for logo
      const organization = await storage.getOrganization(user.organizationId!);

      const group = await storage.createCommunityGroup({
        organizationId: user.organizationId!,
        blockId,
        name,
        description: description || null,
        createdBy: user.id,
        status: "approved", // Auto-approve operator-created groups
      });

      // Update with approved status since operator created it
      await storage.updateCommunityGroup(group.id, { approvedBy: user.id } as any);

      // Automatically add all active tenants from this block to the community group
      try {
        const tenantAssignments = await storage.getTenantAssignmentsByBlock(blockId);
        const activeTenants = tenantAssignments
          .filter(ta => ta.assignment.isActive === true)
          .map(ta => ta.user.id);

        // Add each active tenant to the group (skip if already a member)
        for (const tenantId of activeTenants) {
          const isMember = await storage.isGroupMember(group.id, tenantId);
          if (!isMember) {
            await storage.joinGroup({ groupId: group.id, tenantId });
          }
        }
        console.log(`[Community] Auto-added ${activeTenants.length} active tenants to group ${group.id}`);
      } catch (error) {
        console.error(`[Community] Error auto-adding tenants to group ${group.id}:`, error);
        // Don't fail the request if auto-adding tenants fails
      }

      // Generate AI banner in the background (don't block the response)
      const objectStorageService = new ObjectStorageService();
      generateGroupBanner(
        name,
        description || null,
        organization?.logoUrl || null,
        objectStorageService
      ).then(async (bannerUrl) => {
        if (bannerUrl) {
          await storage.updateCommunityGroup(group.id, { coverImageUrl: bannerUrl });
          console.log(`[BannerGen] Updated group ${group.id} with banner: ${bannerUrl}`);
        }
      }).catch((error) => {
        console.error(`[BannerGen] Failed to generate banner for group ${group.id}:`, error);
      });

      res.json(group);
    } catch (error: any) {
      console.error("Error creating group:", error);
      res.status(500).json({ message: "Failed to create group" });
    }
  });

  // Operator get group threads
  app.get("/api/community/groups/:id/threads", async (req, res) => {
    if (!req.isAuthenticated() || !["owner", "clerk"].includes(req.user?.role || "")) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const group = await storage.getCommunityGroup(req.params.id);
      if (!group || group.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Group not found" });
      }

      const threads = await storage.getCommunityThreads(req.params.id);

      // Add author info (check if user is operator or tenant)
      const threadsWithDetails = await Promise.all(threads.map(async (thread) => {
        const author = await storage.getUser(thread.createdBy);
        return {
          ...thread,
          authorName: author ? `${author.firstName || ''} ${author.lastName || ''}`.trim() || author.username : 'Unknown',
          isOperator: author ? ['owner', 'clerk'].includes(author.role || '') : false,
        };
      }));

      res.json(threadsWithDetails);
    } catch (error: any) {
      console.error("Error fetching threads:", error);
      res.status(500).json({ message: "Failed to fetch threads" });
    }
  });

  // Operator create thread
  app.post("/api/community/groups/:id/threads", async (req, res) => {
    if (!req.isAuthenticated() || !["owner", "clerk"].includes(req.user?.role || "")) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const { title, content } = req.body;

      if (!title || !content) {
        return res.status(400).json({ message: "Title and content are required" });
      }

      const group = await storage.getCommunityGroup(req.params.id);
      if (!group || group.organizationId !== user.organizationId) {
        return res.status(404).json({ message: "Group not found" });
      }

      const thread = await storage.createCommunityThread({
        groupId: req.params.id,
        title,
        content,
        createdBy: user.id,
      });

      res.json(thread);
    } catch (error: any) {
      console.error("Error creating thread:", error);
      res.status(500).json({ message: "Failed to create thread" });
    }
  });

  // Operator get thread with posts
  app.get("/api/community/threads/:id", async (req, res) => {
    if (!req.isAuthenticated() || !["owner", "clerk"].includes(req.user?.role || "")) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const thread = await storage.getCommunityThread(req.params.id);
      if (!thread) {
        return res.status(404).json({ message: "Thread not found" });
      }

      const group = await storage.getCommunityGroup(thread.groupId);
      if (!group || group.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      // Get thread author details
      const threadAuthor = await storage.getUser(thread.createdBy);
      const threadAuthorName = threadAuthor
        ? `${threadAuthor.firstName || ''} ${threadAuthor.lastName || ''}`.trim() || threadAuthor.username
        : 'Unknown';
      const threadIsOperator = threadAuthor
        ? ['owner', 'clerk'].includes(threadAuthor.role || '')
        : false;

      const posts = await storage.getCommunityPosts(req.params.id);

      const postsWithDetails = await Promise.all(posts.map(async (post) => {
        const author = await storage.getUser(post.createdBy);
        return {
          ...post,
          authorName: author ? `${author.firstName || ''} ${author.lastName || ''}`.trim() || author.username : 'Unknown',
          isOperator: author ? ['owner', 'clerk'].includes(author.role || '') : false,
        };
      }));

      res.json({
        ...thread,
        authorName: threadAuthorName,
        isOperator: threadIsOperator,
        posts: postsWithDetails,
        group
      });
    } catch (error: any) {
      console.error("Error fetching thread:", error);
      res.status(500).json({ message: "Failed to fetch thread" });
    }
  });

  // Operator create post
  app.post("/api/community/threads/:id/posts", async (req, res) => {
    if (!req.isAuthenticated() || !["owner", "clerk"].includes(req.user?.role || "")) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const { content } = req.body;

      if (!content) {
        return res.status(400).json({ message: "Content is required" });
      }

      const thread = await storage.getCommunityThread(req.params.id);
      if (!thread) {
        return res.status(404).json({ message: "Thread not found" });
      }

      const group = await storage.getCommunityGroup(thread.groupId);
      if (!group || group.organizationId !== user.organizationId) {
        return res.status(403).json({ message: "Access denied" });
      }

      const post = await storage.createCommunityPost({
        threadId: req.params.id,
        content,
        createdBy: user.id,
      });

      res.json(post);
    } catch (error: any) {
      console.error("Error creating post:", error);
      res.status(500).json({ message: "Failed to create post" });
    }
  });

  // Get moderation log (operator)
  app.get("/api/community/moderation-log", async (req, res) => {
    if (!req.isAuthenticated() || !["owner", "clerk"].includes(req.user?.role || "")) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const logs = await storage.getCommunityModerationLog(user.organizationId!);

      // Get moderator names
      const logsWithDetails = await Promise.all(logs.map(async (log) => {
        const moderator = await storage.getUser(log.moderatorId);
        return {
          ...log,
          moderatorName: moderator ? `${moderator.firstName || ''} ${moderator.lastName || ''}`.trim() || moderator.username : 'Unknown',
        };
      }));

      res.json(logsWithDetails);
    } catch (error: any) {
      console.error("Error fetching moderation log:", error);
      res.status(500).json({ message: "Failed to fetch moderation log" });
    }
  });

  // Get blocked tenants list (operator)
  app.get("/api/community/blocked-tenants", async (req, res) => {
    if (!req.isAuthenticated() || !["owner", "clerk"].includes(req.user?.role || "")) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const blocks = await storage.getCommunityTenantBlocks(user.organizationId!);

      // Get tenant and blocker names
      const blocksWithDetails = await Promise.all(blocks.map(async (block) => {
        const tenant = await storage.getUser(block.tenantUserId);
        const blocker = await storage.getUser(block.blockedByUserId);
        return {
          ...block,
          tenantName: tenant ? `${tenant.firstName || ''} ${tenant.lastName || ''}`.trim() || tenant.username : 'Unknown',
          tenantEmail: tenant?.email || '',
          blockedByName: blocker ? `${blocker.firstName || ''} ${blocker.lastName || ''}`.trim() || blocker.username : 'Unknown',
        };
      }));

      res.json(blocksWithDetails);
    } catch (error: any) {
      console.error("Error fetching blocked tenants:", error);
      res.status(500).json({ message: "Failed to fetch blocked tenants" });
    }
  });

  // Block a tenant (operator)
  app.post("/api/community/blocked-tenants", async (req, res) => {
    if (!req.isAuthenticated() || !["owner", "clerk"].includes(req.user?.role || "")) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const { tenantUserId, reason } = req.body;

      if (!tenantUserId) {
        return res.status(400).json({ message: "Tenant user ID is required" });
      }

      // Check if already blocked
      const existing = await storage.getCommunityTenantBlock(user.organizationId!, tenantUserId);
      if (existing) {
        return res.status(400).json({ message: "Tenant is already blocked" });
      }

      const block = await storage.createCommunityTenantBlock({
        organizationId: user.organizationId!,
        tenantUserId,
        blockedByUserId: user.id,
        reason: reason || null,
      });

      // Log the moderation action
      await storage.createCommunityModerationLog({
        organizationId: user.organizationId!,
        moderatorId: user.id,
        action: 'tenant_blocked' as any,
        targetType: 'tenant',
        targetId: tenantUserId,
        reason: reason || 'Tenant blocked from community',
      });

      res.json(block);
    } catch (error: any) {
      console.error("Error blocking tenant:", error);
      res.status(500).json({ message: "Failed to block tenant" });
    }
  });

  // Unblock a tenant (operator)
  app.delete("/api/community/blocked-tenants/:tenantUserId", async (req, res) => {
    if (!req.isAuthenticated() || !["owner", "clerk"].includes(req.user?.role || "")) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const { tenantUserId } = req.params;

      await storage.deleteCommunityTenantBlock(user.organizationId!, tenantUserId);

      // Log the moderation action
      await storage.createCommunityModerationLog({
        organizationId: user.organizationId!,
        moderatorId: user.id,
        action: 'tenant_unblocked' as any,
        targetType: 'tenant',
        targetId: tenantUserId,
        reason: 'Tenant unblocked from community',
      });

      res.json({ success: true });
    } catch (error: any) {
      console.error("Error unblocking tenant:", error);
      res.status(500).json({ message: "Failed to unblock tenant" });
    }
  });

  // Check if current user (tenant) is blocked
  app.get("/api/community/am-i-blocked", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const isBlocked = await storage.isTenantBlocked(user.organizationId!, user.id);
      res.json({ blocked: isBlocked });
    } catch (error: any) {
      console.error("Error checking block status:", error);
      res.status(500).json({ message: "Failed to check block status" });
    }
  });

  // ==================== MARKETPLACE & MODULES API ====================

  // Get all available marketplace modules with pricing
  app.get("/api/marketplace/modules", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const modules = await storage.getMarketplaceModules();

      // Fetch pricing for each module (default to GBP)
      const modulesWithDetails = await Promise.all(modules.map(async (mod) => {
        const pricing = await storage.getModulePricing(mod.id, "GBP");
        return {
          ...mod,
          pricing
        };
      }));

      const bundles = await storage.getModuleBundles(); // Assumes this exists in storage.ts or I handled it
      // Note: storage.getModuleBundles might trigger error if not defined. I saw it in the seed script using db directly.
      // I should define it in the routes or ensure storage has it.
      // storage.ts showed `getModuleBundles`? I'll check.
      // Line 4750 in storage.ts: async getModuleBundles(): Promise<any[]> {
      // Yes it exists.

      res.json({ modules: modulesWithDetails, bundles });
    } catch (error: any) {
      console.error("Error fetching marketplace modules:", error);
      res.status(500).json({ message: "Failed to fetch modules" });
    }
  });

  // Get enabled modules for the current instance
  app.get("/api/marketplace/my-modules", async (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    }

    try {
      const user = req.user as User;
      const instanceSub = await storage.getInstanceSubscription(user.organizationId!);

      if (!instanceSub) {
        return res.json([]);
      }

      const myModules = await storage.getInstanceModules(instanceSub.id);

      // Enrich with module details (key, name)
      // We need all modules to look up names
      const allModules = await storage.getMarketplaceModules();

      // Calculate and update current usage for each module
      const enrichedModules = await Promise.all(myModules.map(async (im) => {
        const mod = allModules.find(m => m.id === im.moduleId);
        
        // Calculate current usage based on module type
        let calculatedUsage = im.currentUsage || 0;
        if (mod?.moduleKey && im.isEnabled) {
          try {
            calculatedUsage = await storage.calculateModuleUsage(user.organizationId!, mod.moduleKey);
            
            // Update the database if usage has changed
            if (calculatedUsage !== im.currentUsage) {
              await storage.updateModuleUsage(im.id, calculatedUsage);
            }
          } catch (error) {
            console.error(`Error calculating usage for module ${mod.moduleKey}:`, error);
            // Use existing usage if calculation fails
            calculatedUsage = im.currentUsage || 0;
          }
        }
        
        return {
          ...im,
          moduleKey: mod?.moduleKey,
          moduleName: mod?.name,
          currentUsage: calculatedUsage
        };
      }));

      res.json(enrichedModules);
    } catch (error: any) {
      console.error("Error fetching my modules:", error);
      res.status(500).json({ message: "Failed to fetch my modules" });
    }
  });

  // Toggle a module (Enable/Disable) - Simulating Purchase for now
  app.post("/api/marketplace/modules/:moduleId/toggle", async (req, res) => {
    const userRole = req.user?.role as string;
    if (!req.isAuthenticated() || (userRole !== "owner" && userRole !== "admin")) { // Allow admin too for testing
      // Strictly speaking "owner" is best for billing.
      // Role check: "owner" is standard.
      return res.status(403).json({ message: "Unauthorized. Only owners can manage modules." });
    }

    try {
      const user = req.user as User;
      const { moduleId } = req.params;
      const { enable } = req.body; // true or false

      // 1. Get or Create Instance Subscription if it doesn't exist
      let instanceSub = await storage.getInstanceSubscription(user.organizationId!);
      if (!instanceSub) {
        // Create default subscription record
        try {
          // Need insertInstanceSubscriptionSchema types
          instanceSub = await storage.createInstanceSubscription({
            organizationId: user.organizationId!,
            registrationCurrency: "GBP",
            inspectionQuotaIncluded: 0,
            billingCycle: "monthly",
            subscriptionStatus: "active"
          });
        } catch (e) {
          console.error("Failed to create subscription:", e);
          return res.status(500).json({ message: "Failed to create subscription record" });
        }
      }

      // Prevent enabling modules if subscription is inactive
      if (enable && instanceSub.subscriptionStatus !== "active") {
        return res.status(403).json({ 
          message: "Cannot enable modules. Your subscription is inactive. Please subscribe to a plan to enable modules.",
          error: "subscription_inactive"
        });
      }

      // 2. Get organization for Stripe customer ID
      const org = await storage.getOrganization(user.organizationId!);
      if (!org) {
        return res.status(404).json({ message: "Organization not found" });
      }

      // 3. Get module details for response
      const module = (await storage.getMarketplaceModules()).find(m => m.id === moduleId);
      const modulePricing = module ? await storage.getModulePricing(module.id, instanceSub.registrationCurrency) : null;
      
      // 4. Calculate prorated charge if enabling mid-cycle
      let proratedCharge = 0;
      let proratedChargeMinorUnits = 0; // Store in minor units for Stripe
      if (enable && modulePricing && instanceSub.billingCycle) {
        const now = new Date();
        const renewalDate = instanceSub.subscriptionRenewalDate || new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
        const daysRemaining = Math.max(1, Math.ceil((renewalDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)));
        const daysInCycle = instanceSub.billingCycle === "monthly" ? 30 : 365;
        const monthlyPrice = modulePricing.priceMonthly || 0;
        proratedChargeMinorUnits = Math.round((monthlyPrice * daysRemaining) / daysInCycle);
        proratedCharge = proratedChargeMinorUnits / 100; // Convert to major units for response
        
        // Add prorated charge to Stripe as invoice item (will be included in next invoice)
        if (org.stripeCustomerId && proratedChargeMinorUnits > 0) {
          try {
            const stripe = await getUncachableStripeClient();
            await stripe.invoiceItems.create({
              customer: org.stripeCustomerId,
              amount: proratedChargeMinorUnits,
              currency: instanceSub.registrationCurrency.toLowerCase(),
              description: `Prorated charge for ${module?.name || "Module"} (enabled mid-cycle)`,
              metadata: {
                organizationId: user.organizationId!,
                moduleId: moduleId,
                moduleName: module?.name || "Unknown Module",
                type: "prorated_module_enable",
                billingCycle: instanceSub.billingCycle
              }
            });
            console.log(`[Module Toggle] Added prorated charge of ${proratedCharge.toFixed(2)} ${instanceSub.registrationCurrency} to Stripe invoice for module ${module?.name}`);
          } catch (stripeError: any) {
            console.error(`[Module Toggle] Failed to add prorated charge to Stripe:`, stripeError.message);
            // Don't fail the module enable if Stripe invoice item creation fails
            // The prorated charge is still calculated and returned in response
          }
        } else if (!org.stripeCustomerId) {
          console.warn(`[Module Toggle] Cannot add prorated charge to Stripe: organization ${user.organizationId} has no Stripe customer ID`);
        }
      }

      // 5. Toggle module
      const updatedModule = await storage.toggleInstanceModule(instanceSub.id, moduleId, enable);
      
      // 6. Return response in spec format
      res.json({
        success: true,
        module_id: moduleId,
        module_name: module?.name || "Unknown Module",
        enabled: enable,
        billing_start_date: updatedModule.enabledDate?.toISOString().split('T')[0] || new Date().toISOString().split('T')[0],
        prorated_charge: proratedCharge, // Already in major currency units
        message: enable 
          ? `${module?.name || "Module"} enabled. ${proratedCharge > 0 ? `Prorated charge of ${instanceSub.registrationCurrency} ${(proratedCharge / 100).toFixed(2)} will be added to next invoice.` : "No prorated charge for this billing cycle."}`
          : `${module?.name || "Module"} disabled.`
      });
    } catch (error: any) {
      console.error("Error toggling module:", error);
      res.status(500).json({ message: "Failed to toggle module" });
    }
  });

  // Marketplace Checkout
  app.post("/api/marketplace/checkout", async (req, res) => {
    if (!req.isAuthenticated() || req.user?.role !== "owner") {
      return res.status(403).json({ message: "Unauthorized" });
    }

    try {
      const { type, id, interval } = req.body;
      const user = req.user as User;
      const organization = await storage.getOrganization(user.organizationId!);

      if (!organization) return res.status(404).json({ message: "Organization not found" });

      const stripe = await getUncachableStripeClient();
      const billingInterval = interval === 'annual' ? 'annual' : 'monthly';
      const stripeInterval = interval === 'annual' ? 'year' : 'month';

      let priceData;
      let itemName;

      if (type === 'module') {
        const modules = await storage.getMarketplaceModules();
        const module = modules.find(m => m.id === id);
        if (!module) return res.status(404).json({ message: "Module not found" });

        const pricing = await storage.getModulePricing(id, "GBP");
        if (!pricing) return res.status(404).json({ message: "Pricing not found" });

        const amount = billingInterval === 'annual' ? pricing.priceAnnual : pricing.priceMonthly;
        itemName = module.name;

        priceData = {
          currency: 'gbp',
          product_data: {
            name: module.name,
            description: module.description || `Subscription to ${module.name}`,
            metadata: { moduleId: module.id }
          },
          unit_amount: amount,
          recurring: { interval: stripeInterval }
        };
      } else if (type === 'bundle') {
        const bundles = await storage.getModuleBundles();
        const bundle = bundles.find(b => b.id === id);
        if (!bundle) return res.status(404).json({ message: "Bundle not found" });

        const pricing = await storage.getBundlePricing(id, "GBP");
        if (!pricing) return res.status(404).json({ message: "Pricing not found" });

        const amount = billingInterval === 'annual' ? pricing.priceAnnual : pricing.priceMonthly;
        itemName = bundle.name;

        priceData = {
          currency: 'gbp',
          product_data: {
            name: bundle.name,
            description: bundle.description || `Subscription to ${bundle.name}`,
            metadata: { bundleId: bundle.id }
          },
          unit_amount: amount,
          recurring: { interval: stripeInterval }
        };
      } else {
        return res.status(400).json({ message: "Invalid type" });
      }

      const successUrl = `${req.headers.origin}/settings?tab=marketplace&success=true&session_id={CHECKOUT_SESSION_ID}`;
      const cancelUrl = `${req.headers.origin}/settings?tab=marketplace&canceled=true`;

      // TypeScript workaround for Stripe API - mode is valid but types are incorrect
      const session = await stripe.checkout.sessions.create({
        mode: 'subscription' as any,
        payment_method_types: ['card'],
        line_items: [{
          price_data: priceData,
          quantity: 1,
        }],
        success_url: successUrl,
        cancel_url: cancelUrl,
        customer_email: user.email,
        client_reference_id: user.organizationId,
        metadata: {
          organizationId: user.organizationId,
          type: type,
          itemId: id
        }
      } as any);

      res.json({ url: session.url });
    } catch (error: any) {
      console.error("Error creating marketplace checkout:", error);
      res.status(500).json({ message: error.message });
    }
  });

  // Stripe Webhook
  // NOTE: Duplicate webhook handler removed - all webhook handling consolidated into /api/billing/webhook

  const httpServer = createServer(app);

  // Set up WebSocket server for real-time notifications
  const { setupWebSocketServer } = await import("./websocket");
  setupWebSocketServer(httpServer, storage);

  return httpServer;
}
